---
categories:
  - 2. 工作
  - Unity
---
# <font color="yellow">执行顺序</font>
## 现象
- Start,Update全部按批执行
- Awake在场景初始化回调前触发
- 后拖入场景的脚本先执行
## 结论
Awake被认为是一种初始化，而Start不是



# <font color="yellow">创建</font>
## AddComponent | Instantiate | ...
### 现象
- Awake在物体创建后立即触发
- Start必在当前帧被执行
- 只要在当前帧的Update之前创建，Update肯定会在当前帧触发，否则跳到下一帧触发
- Start每帧会有多个批次，Update一帧只触发一批
### 结论
Awake是构造函数的代替品</br>
Start可以确保给予你在正式开始前（其他各种杂项事件前）的回调机会</br>
多个事件执行前都会检查一次Start调用，以提到保底的作用，所以其和Update并没有直接关系



# <font color="yellow">销毁</font>
- 都不是真正的从内存中移除，而是以标记的方式来使物体不可见。
## Destroy
### 现象
- 物体被销毁后本应执行的事件函数立即不再执行
- 物体被销毁的当前帧，该物体的所有属性依旧可以被读写复制和查找
- 从第二帧开始，Unity属性失效，但用户属性仍可继续乃至持续访问
### 结论
被销毁物体不会没有立即消失，而是进入了一种冻结状态，但自身仍带有所有属性。
所以说调用该函数实际是将该物体标记为需要删除，并立即停止其行动能力，待当前帧结束后，Unity系统才会正式将其移出可见环境。
但这仍只是一种标记，物体仍在内存中。</br>
Unity是C++引擎，其所有功能都通过C++过了一遍，相信是其通过了某些条件判断，所以大家都当做看不见该物体了。
但用户层的代码写在C#中，并没有这一审核的过程，所以依旧可以“看见”该物体。

## DestroyImmediate
### 现象
- 用户属性依旧可以读写，但Unity属性全部失效
- 不再可见，无法搜索到
### 结论
从Unity层来看确实消失的无影无踪了，这与Destroy的情况类似。
只是将Unity不可见的这一过程从当前帧结束时提前为了调用函数后立即触发。



# <font color="yellow">其他</font>
- 所有可以使用Awake事件的脚本都无法用构造函数创建
