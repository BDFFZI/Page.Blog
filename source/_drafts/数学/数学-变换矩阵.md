---
categories:
  - 1. 学习
  - 数学
---
# 矩阵分量
## 缩放矩阵（Scale）
$
\begin{bmatrix}
x&0&0\\
0&y&0\\
0&0&z
\end{bmatrix}
$
## 旋转矩阵(Rotation)
### 矩阵分量
$
Z轴旋转 = 
\begin{bmatrix}
\cos(z)&-\sin(z)&0\\
\sin(z)&\cos(z)&0\\
0&0&1
\end{bmatrix}
$

$
X轴旋转=
\begin{bmatrix}
1&0&0&\\
0&\cos(x)&-\sin(x)&\\
0&\sin(x)&\cos(x)
\end{bmatrix}
$

$
Y轴旋转=
\begin{bmatrix}
\cos(y)&0&\sin(y)&\\
0&1&0&\\
-\sin(y)&0&\cos(y)
\end{bmatrix}  
$

### 复合矩阵（一般复合顺序：z\*x\*y）
$
\begin{bmatrix}
y_1z_1+y_3x_2z_2&y_1z_3+y_3x_2z_4&y_3x_4\\
x_1z_2&x_1z_4&x_3\\
y_2z_1+y_4x_2z_2&y_2z_3+y_4x_2z_4&y_4x_4
\end{bmatrix}
$

## 转移矩阵(Translate)
$
\begin{bmatrix}
1&0&0&x\\
0&1&0&y\\
0&0&1&z\\
0&0&0&1
\end{bmatrix}
$
# 复合矩阵
转移矩阵 * 旋转矩阵 * 缩放矩阵
# 矩阵拆解
```
Vector3 position;
Vector3 rotation;
Vector3 scale;
Matrix4x4 matrix4X4 = transform.localToWorldMatrix;
position = matrix4X4.GetColumn(3);
Matrix4x4 sqrScaleMatrix = matrix4X4.transpose * matrix4X4;
scale = new Vector3(Mathf.Sqrt(sqrScaleMatrix.m00), Mathf.Sqrt(sqrScaleMatrix.m11), Mathf.Sqrt(sqrScaleMatrix.m22));
Matrix4x4 rotationMatrix = matrix4X4 * Matrix4x4.Scale(new Vector3(1 / scale.x, 1 / scale.y, 1 / scale.z));
if (Mathf.Abs(Mathf.Abs(rotationMatrix.m12) - 1) > 0.001f) //A(Sinx) != 1,CosX != 0
{
    //cosX为负?
    rotation.y = Mathf.Atan2(rotationMatrix.m02, rotationMatrix.m22);
    rotation.z = Mathf.Atan2(rotationMatrix.m10, rotationMatrix.m11);
    float cosX = rotationMatrix.m02 != 0
        ? rotationMatrix.m02 / Mathf.Sin(rotation.y)
        : rotationMatrix.m22 / Mathf.Cos(rotation.y);
    rotation.x = cosX > 0
        ? Mathf.Asin(-rotationMatrix.m12)
        : Mathf.PI - Mathf.Asin(-rotationMatrix.m12);
 }
else //Abs(Sinx) == 1,CosX == 0
{
    if (-rotationMatrix.m12 > 0)
    {
        float yMinusZ = Mathf.Atan2(rotationMatrix.m01,rotationMatrix.m00);
        rotation.z = 0;
        rotation.y = yMinusZ;
        rotation.x = Mathf.PI / 2;
    }
    else
    {
        float yAddZ = Mathf.Atan2(-rotationMatrix.m01,rotationMatrix.m00);
        rotation.z = 0;
        rotation.y = yAddZ;
        rotation.x = -Mathf.PI / 2;
    }
}
rotation *= Mathf.Rad2Deg;
```