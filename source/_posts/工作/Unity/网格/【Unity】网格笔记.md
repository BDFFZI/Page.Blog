---
abbrlink: 810271066
date: 2024-5-15 17:26
categories:
  - 工作
  - Unity
  - 网格
---

# 【Unity】网格笔记

https://docs.unity.cn/cn/2022.3/Manual/mesh.html

## 网格的作用

网格用于描述物体的形状结构。

- 在图形上：配合材质球进行渲染。网格负责描述形状，材质球负责描述外观。
- 在物理上：用于确定碰撞体的形状范围。

## 获取网格

可以通过以下方式将网格添加到 Unity 中。

- 在 3D 建模软件中建模，网格将作为模型的一部分导入。
- 通过 Unity 内置的原始形状或建模插件（如 ProBuilder）创建网格。
- 使用 Unity 提供的 API，在代码中创建网格。

## 访问网格

网格资源对应于`Mesh`类，具体结构参考另外的网格数据结构笔记。

每种数据都有函数和属性两种方式访问：

- 属性访问：旧方法，每次使用都会创建新数组，性能极低。如`Mesh.vertices`。
- 函数访问：不会每次访问时都分配新数组，建议使用。如`Mesh.GetVertices`。

此外 Unity 还提供一些更低级的函数可以直接操控原始网格数据缓冲区，用于满足高性能需求：

- 底层访问：如`Mesh.SetIndexBufferData`、`Mesh.SetVertexBufferData`等。

## 特别网格功能

### 可变形网格

网格的形状可以实时发生改变，从而实现动态性的渲染效果，具体而言有以下几种类型：

- 蒙皮网格：网格中额外带有骨骼骨架信息，可在骨骼移动时逼真的控制网格形状，通常用于实现角色动作动画或物理上的布娃娃效果。
- 具有混合形状的网格：网格中额外带有混合形状数据，使网格可以在多个形状之间的插值，通常用于实现角色的面部动画。
- 配合 Cloth 组件的网格：用于实现逼真的布料模拟。

上述的可变性网格都必须借助`SkinnedMeshRenderer`组件实现。

### 网格 LOD

网格的面越多渲染开销就越大，特别是随着网格与相机的距离增加，此时高精度的模型在渲染效果上已失去优势，反而会造成 GPU 运算资源的浪费。

借助 `LODGroup` 组件，Unity 支持在不同的距离下使用不同的模型进行渲染。所以要按照从近到远，准备多个不同精度的模型按需渲染，从而优化渲染性能。

#### 配置 LOD 网格

Unity 支持两种方式配置 LOD 网格：

- 手动创建带有`LODGroup`组件的游戏对象，并手动配置 LOD 级别。
- 在外部建模软件中创建符合 LOD 规范的模型：文件内存在多个同名模型，且都有自己 LOD 后缀。如“Cube_LOD0”、“Cube_LOD1”。

#### 项目中的 LOD 设置

在 Quality settings 窗口中有一些关于 LOD 的选项。

- Maximum LOD Level：从构建中排除高于指定 LOD 级别的网格。
- LOD Bias：决定了处于阈值距离时选用更高还是更低的 LOD 级别。

### 压缩网格

Unity 支持两种方法压缩网格来减少大小或提高性能。

#### 顶点压缩

- 设置方式：在 Player 面板设置，默认启用部分。将影响项目中的所有网格。
- 实现方式：将选择的网格数据从默认的 32 位浮点数改为较低精度的 16 位来存储。
- 优点：可减少网格的文件、内存大小，并可能略微提高 GPU 性能。
- 缺点：会造成精度损失，如果压缩 Position 和 Tex Coord 1 通道还可能造成伪影。
- 限制条件：
  - 网格必须禁用“Read/Write Enabled”功能。
  - 网格必须禁用“网格压缩”功能。
  - 网格不能是蒙皮网格。
  - 网格不能符合动态批处理条件，或设置中有关闭动态批处理。
  - 目标平台必须支持 16 位浮点数。

#### 网格压缩

- 设置方式：在每个模型导入面板设置，默认关闭。仅影响被设置的单个网格。
- 实现方式：将网格数据换成用最大值最小值间的位置信息存储，运行时再解压回原始数据。
- 优点：大幅减少文件大小。
- 缺点：造成精度损失，增加加载时间和临时内存使用，并可能造成网格显示伪影。

## 加载纹理和网格数据

Unity 使用同步和异步两种方式加载纹理和网格到 GPU，如果资源支持，则 Unity 将**默认使用异步加载**。同步加载会导致游戏卡顿，但异步则不会，所以考虑性能优化，**应尽可能保证资源满足异步加载条件**。

### 工作原理

资源数据由“元数据”（标头数据）和“像素顶点数据”（二进制数据）组成。当资源被要求加载时，其中标头数据必须立即被加载，但二进制数据实际可以在后续慢慢加载。

#### 同步上传管线

- 构建时：Unity 将标头数据和二进制数据打包在同一文件中（.res）。
- 运行时：需要资源时，Unity 将 .res 加载到内存中，并在加载完毕后将二进制数据上传 GPU，所有操作在同一帧中完成。

#### 异步上传管线

- 构建时：Unity 仅将标头数据存储在 .res 文件中，二进制数据存在单独的 .resS 文件中。
- 运行时：先将标头数据加载进内存，随后利用异步上传方式上传二进制文件，具体流程如下：

  1. 异步等待所需的内存在环形缓冲区中可用。
  2. 将数据从源 .resS 文件读取到分配的内存中。
  3. 执行后处理（纹理解压缩、网格碰撞生成、每个平台修复等）。
  4. 在渲染线程上以时间切片方式分多帧上传数据至 GPU。
  5. 释放环形缓冲器内存。

- 存在多个异步上传命令时：

  可以同时进行多个异步上传命令，所有命令共享环形缓冲区，如果环形缓冲区已满，后续命令将等待，这不会造成主线程阻塞，只是减慢异步加载过程。

- 当资源超出缓冲区最大大小时：

  加载单个数据到 CPU 内存是一次性完成的，如果缓冲区完全无法容纳，Unity 会待缓冲区使用完毕后临时重新分配缓冲区大小，上传完后再还原，但这个过程非常缓慢。

### 异步加载要求

资源必须满足以下要求才可支持异步上传管线，否则将一律被 Unity 用同步的方式加载。

- 纹理与网格的通用要求

  - 未启用读/写权限。
  - 不在 Resources 文件夹中。
  - 如果构建目标是 Android，在项目的构建设置 (Build Settings) 中启用了 LZ4 压缩。

- 针对网格的额外要求

  - 网格没有混合形状数据。
  - 网格没有骨骼权重数据。
  - 网格拓扑不是四边形。
  - 网格没有启用网格压缩。
  - 网格不会被动态批处理。
  - 网格数据没有被粒子系统、地形、碰撞器使用。

### 判断是否被异步加载

可通过 Profiler 分析工具观察线程活动来识别，具有以下任意特征时表示被异步加载：

- 具有以下标记的活动：
  - AsyncUploadManager.ScheduleAsyncRead
  - AsyncReadManager.ReadFile
  - Async.DirectTextureLoadBegin
- AsyncRead 线程上活动。

除此之外都表明未使用异步加载。即使依然能看到一些带有 async 的活动，但那只有 Unity 用于检测是否需要异步加载而已。

### 配置异步加载管线

质量设置面板可以调节部分异步加载管线的参数：

- Async Upload Time Slice：上传时间片，每帧花多少毫秒用于上传数据。
- Async Upload Buffer Size：环形缓冲区的大小，二进制数据加载进内存的临时空间。
- Async Upload Persistent Buffer：是否持续保留环形缓冲区内存而不释放。

最佳的设置方法是：

1. 保证不丢帧的情况下尽可能把上传时间片调大，在一些不影响视觉效果的时候（如加载界面）还可以临时进一步调大。
2. 通过分析器检查时间片时间是否被完全利用，如果未完全利用一般说明缓冲区大小不够用，需增加环形缓冲区大小。
3. 超出缓冲区上限的大型资源会导致 Unity 临时重建缓冲区，如果这种情况较多，应增加默认缓冲区大小以避免发生。
4. 释放内存会导致内存碎片，所以除非有令人信服的理由，否则不要关闭保留缓冲区内存选项。
