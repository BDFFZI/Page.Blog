---
categories:
  - 工具使用
  - Unity
abbrlink: 4114572923
---
# 【Unity】脚本生命周期

## 执行顺序

### 现象

- Start,Update 全部按批执行
- Awake 在场景初始化回调前触发
- 后拖入场景的脚本先执行

### 结论

Awake 被认为是一种初始化，而 Start 不是

## 创建

### AddComponent | Instantiate | ...

#### 现象

- Awake 在物体创建后立即触发
- Start 必在当前帧被执行
- 只要在当前帧的 Update 之前创建，Update 肯定会在当前帧触发，否则跳到下一帧触发
- Start 每帧会有多个批次，Update 一帧只触发一批

#### 结论

Awake 是构造函数的代替品</br>
Start 可以确保给予你在正式开始前（其他各种杂项事件前）的回调机会</br>
多个事件执行前都会检查一次 Start 调用，以提到保底的作用，所以其和 Update 并没有直接关系

## 销毁

- 都不是真正的从内存中移除，而是以标记的方式来使物体不可见。

### Destroy

#### 现象

- 物体被销毁后本应执行的事件函数立即不再执行
- 物体被销毁的当前帧，该物体的所有属性依旧可以被读写复制和查找
- 从第二帧开始，Unity 属性失效，但 C# 端属性仍可继续乃至持续访问

#### 结论

被销毁物体不会没有立即消失，而是进入了一种冻结状态，但自身仍带有所有属性。
所以说调用该函数实际是将该物体标记为需要删除，并立即停止其行动能力，待当前帧结束后，Unity 系统才会正式将其移出可见环境。
但这仍只是一种标记，物体仍在内存中。</br>
Unity 是 C++引擎，其所有功能都通过 C++过了一遍，相信是其通过了某些条件判断，所以大家都当做看不见该物体了。
但用户层的代码写在 C#中，并没有这一审核的过程，所以依旧可以“看见”该物体。

### DestroyImmediate

#### 现象

- C# 端属性依旧可以读写，但 Unity 属性全部失效
- 不再可见，无法搜索到

#### 结论

从 Unity 层来看确实消失的无影无踪了，这与 Destroy 的情况类似。
只是将 Unity 不可见的这一过程从当前帧结束时提前为了调用函数后立即触发。

## 其他

- 所有可以使用 Awake 事件的脚本都无法用构造函数创建
