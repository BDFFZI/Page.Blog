---
abbrlink: 2308421870
date: 2024-6-11 16:38
categories:
  - 个人研究
  - 软件开发
---

# 【软件开发】C++使用笔记

## 数据类型

### 值类型

存放在栈空间中的一段内存。

- T：左值，最普通的变量，是具有变量名且可取地址的值。
- $~$ ：右值，常量或不具备名称的值，无变量名不可取地址。通常都是一些生命周期极短的临时值，例如未接收的函数返回值。

备注：
右值及其相关的一系列操作都是 C++11 才新增的功能。

### 指针类型

一种用于保存内存地址的值类型，可以利用特定的访问运算符访问其指向的内存。

- T\*
- T[]

### 引用类型

一种封装的指针类型，像指针一样存储着内存地址信息，但像值类型一样直接访问该内存。

- T&：引用左值的引用，针对普通变量的引用。
- T&&：引用右值的引用，使右值类型得以被标识和传递，可借此区分左值来实现一些高性能代码。
- const T&：可用右值赋值的，引用常量左值的引用
- T&&（当 T 是一个由编译器推导的类型）：万能引用，既可能作为左值引用也可能作为右值引用。

#### 关于引用值类型的重点说明

要注意的是引用类型也是值类型，若有变量名就是左值类型，无关其引用对象的类型。所以无论是右值引用还是万能引用，只要它有变量名，那它就是一个左值。

由于引用类型的使用就相当于引用对象的值类型，因此引用的左值特性会影响到引用对象的值类型，只要其是左值类型的引用，那该引用的对象也就是左值。

- 右值的本质：

  所以应将右值引用看成一种特殊的左值引用，该引用的目的仅仅是为了声明引用的对象是一个尚无人认领的临时值，以鼓励使用者按需处理。

- 右值的传递：

  因此传递右值引用的本质就是如何将一个左值引用转为右值引用传递出去。非常简单，强制转换就行。若想泛型化，则可借助模板自动推导返回值万能引用的特性，自动强制转换为所需的引用类型。

#### 不同引用值类型间的转换

- 左值转右值：直接强制转换即可，其标准函数为`std::move`（很多函数对右值有特殊处理，因此转换后原本的左值引用不该再继续使用）。
- 右值转左值：使用变量承接即可（因此当一个右值传入函数时，由于函数参数有名称，该右值将被转换为左值）。
- 完美转发：当不希望传递的引用因规则导致类型转换时，可以利用万能引用加传递时强制类型转换实现，其标准函数为`std::forward`。

## 函数匹配顺序

1. 参数完全匹配的普通函数
2. 参数满足要求的模板函数
3. 类型转换后可以匹配的普通函数

需要注意的是，自动推导的模板函数不支持自动类型转换，必须要输入值与函数参数类型完全匹配才行。

## 模板

### 使用场景

- 函数模板
- 变量模板
- 类模板

### 需求与概念

需求（requires）和概念（concept）是从 C++20 开始新增的两个关键字，可借此轻松实现对模板参数的约束。

两者相关功能简述如下：

- **需求**
  1. 一种语法符号，表示接下来要声明模板约束。
  2. 一种返回布尔值的运算，支持多种运算方法，包括表达式有效性。
- **概念**
  1. 一种基于模板的编译时推导的常量布尔值。
  2. 一种具有限制要求的模板参数类型。
  3. 一种模板限制要求。

#### 创建概念和需求

```cpp
template <class T> //概念必须使用模板
concept userConcept = requires(T t) //requires表达式中要用的变量
{
    t + t; //有效性验证：表达式是合法可编译的
    { t + t } noexcept; //异常验证：表达式是不会抛出异常的
    { t + t } -> std::same_as<int>; //返回类型验证：表达式计算结果满足特定要求
    typename T::x; //类型要求：目标类型结构满足的指定的要求
    requires std::is_same_v<T, int>; //条件验证：基于布尔值的验证要求
};
```

#### 使用概念和需求

```cpp
template <userConcept T> //将概念作为模板参数类型
    requires //通过requires语法引入约束
    userConcept //将概念作为布尔值条件
    && requires(T t) {} //通过requires计算的布尔值
    && std::is_same_v<T, int> //其他返回布尔值的手段
void Func()
{
}
```

#### 其他说明

- 这些条件和运算本质都是布尔值，因此也支持布尔值的`&&`和`||`运算。
- 建议将计算布尔值的表达式用`()`括起来，不然有时会因计算顺序问题导致编译失败。

### 可变参数模板

#### 展开方式

- 递归函数展开：通过传参的方式逐渐取出可变参数依次处理。
- 逗号表达式展开：部分场景下省略号会将可变参数展开并用逗号分隔，可借此配合逗号表达式对每个参数执行自定义代码。
- 折叠表达式展开：可以自定义分隔符号和执行顺序的展开方式，相比默认省略号展开更加强大。

## 默认成员函数

创建类结构时 C++编译器会默认生成如下 9 个函数：

- 构造函数
  - 默认构造函数
  - 默认拷贝构造函数
  - 默认移动构造函数（C++ 11）
  - 默认初始化列表构造函数（C++ 11）
- 析构函数
  - 默认析构函数
- 赋值运算符
  - 默认拷贝赋值运算符
  - 默认移动赋值运算符（C++ 11）
- 取址运算符
  - 默认取址运算符
  - 默认常量取址运算符

### 生成方式

- 默认初始化列表构造函数
  - 有显式的构造函数时，始终生成多个与其参数对应的初始化列表构造函数。
  - 没有显式的构造函数时，生成一个自带默认值并与成员对应的初始化列表构造函数。

### 失效条件

- 默认构造函数:
  - 定义了任何构造函数。
  - 成员无法被默认构造。
- 默认拷贝构造函数 / 移动构造函数：
  - 定义了拷贝或移动构造函数中的任何一个。
  - 成员无法被拷贝 / 移动构造。
- 默认拷贝赋值函数 / 移动赋值运算符：
  - 定义了拷贝或移动赋值运算符中的任何一个。
  - 成员无法被拷贝 / 移动赋值。
  - 成员是引用类型。
- 析构函数：
  - 成员无法被析构。

## 参考资料

- [现代 C++之万能引用、完美转发、引用折叠](https://zhuanlan.zhihu.com/p/99524127)
- [现代 C++ 模板教程](https://mq-b.github.io/Modern-Cpp-templates-tutorial/)
- [理解 C++可变参数模板的几种展开方式](https://zhuanlan.zhihu.com/p/670867561)
