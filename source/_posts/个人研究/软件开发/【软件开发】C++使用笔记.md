# 【软件开发】C++使用笔记

## 数据类型

### 值类型

存放在栈空间中的一段内存。

- T：左值，最普通的变量，是具有变量名且可取地址的值。
- $~$ ：右值，常量或不具备名称的值，无变量名不可取地址。通常都是一些生命周期极短的临时值，例如未接收的函数返回值。

### 指针类型

一种用于保存内存地址的值类型，可以利用特定的访问运算符访问其指向的内存。

- T\*
- T[]

### 引用类型

一种封装的指针类型，像指针一样存储着内存地址信息，但像值类型一样直接访问该内存。

- T&：引用左值的引用，针对普通变量的引用。
- T&&：引用右值的引用，使右值类型得以被标识和传递，可借此区分左值来实现一些高性能代码。
- const T&：可用右值赋值的，引用常量左值的引用
- T&&（当 T 是一个由编译器推导的类型）：万能引用，既可能作为左值引用也可能作为右值引用。

#### 关于引用值类型的重点说明

要注意的是引用类型也是值类型，若有变量名就是左值类型，无关其引用对象的类型。所以无论是右值引用还是万能引用，只要它有变量名，那它就是一个左值。

由于引用类型的使用就相当于引用对象的值类型，因此引用的左值特性会影响到引用对象的值类型，只要其是左值类型的引用，那该引用的对象也就是左值。

- 右值的本质：

  所以应将右值引用看成一种特殊的左值引用，该引用的目的仅仅是为了声明引用的对象是一个尚无人认领的临时值，以鼓励使用者按需处理。

- 右值的传递：

  因此传递右值引用的本质就是如何将一个左值引用转为右值引用传递出去。非常简单，强制转换就行。若想泛型化，则可借助模板自动推导返回值万能引用的特性，自动强制转换为所需的引用类型。

#### 不同引用值类型间的转换

- 左值转右值：直接强制转换即可，其标准函数为`std::move`（很多函数对右值有特殊处理，因此转换后原本的左值引用不该再继续使用）。
- 右值转左值：使用变量承接即可（因此当一个右值传入函数时，由于函数参数有名称，该右值将被转换为左值）。
- 完美转发：当不希望传递的引用因规则导致类型转换时，可以利用万能引用加传递时强制类型转换实现，其标准函数为`std::forward`。

## 函数匹配顺序

1. 参数完全匹配的普通函数
2. 参数满足要求的模板函数
3. 类型转换后可以匹配的普通函数

需要注意的是，自动推导的模板函数不支持自动类型转换，必须要输入值与函数参数类型完全匹配才行。

## 模板需求与概念

需求（requires）和概念（concept）是从 C++20 开始新增的两个表达式关键字，可借此轻松实现对模板参数的约束。

从本质来说：

- 需求：一种可以将表达式有效性反映成布尔值的运算。
- 概念：一种编译时运算的常量布尔值。

### 创建概念

1. 概念是对模板的约束，所以创建时必须提供模板。
2. 概念是常量布尔值，所以赋值时必须用返回布尔值的运算。

```c++
template <class T>
concept Int = std::is_same_v<T, int>; //直接使用常量布尔运算符
```

```c++

```

## 参考资料

[现代 C++之万能引用、完美转发、引用折叠](https://zhuanlan.zhihu.com/p/99524127)
