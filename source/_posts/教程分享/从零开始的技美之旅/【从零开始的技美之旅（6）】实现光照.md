# 【从零开始的技美之旅（6）】实现光照

理论上现在已经能成功实现绘制网格了，但由于片段着色器过于简单，所以画面并不出好看。所以现在来实现最关键常用的光照部分。

## 光照构成

和现实一样，即使是游戏中的虚拟物体，我们也可以认为都是因为发光才可见，包括不含光照计算的特效，因为本质上他们是发出的自发光。

光是可以叠加的，而光照可以分为由四种类型组成。

- 漫射光：光经过多次内部反弹再反射的光，均匀而柔和。
- 镜射光：光仅经过一次反弹后直接进入眼睛的光，集中而高亮，与观察角度相关。
- 自发光：物体自身直接发出的光，相当于给物体直接上一层颜色。
- 环境光：受环境影响的全局光照。

## 光照计算

针对各类光照，现已有很多成熟的公式，可以近似模拟现实效果。

- `float3 n`：法线
- `float3 v`：相机方向
- `float3 l`：灯光方向
- `float i`：最终反射的光强度

### 漫射光

#### Lambert

经典漫射光照，哪怕如今的PBR也仍在使用。

```hlsl
float i = saturate(dot(n,l));
```

#### Half-Lambert

能额外模拟环境光和此表面散射，因此得到的光效柔和阴影过渡自然，在一些特殊光效场景中经常被使用

- b（brightness）：背光面的亮度值变化，越低越暗，越高越亮。也可以看成是lambert到half-lambert的比例，为0时为lambert，为0.5时是标准的half-lambert。

```hlsl
float i = saturate(dot(n,l) * (1-b) + b);
```

### 镜射光

#### Phong

最早期的镜射光实现，使用最直观的方式计算。

- s（shininess）：光泽度，越大光斑越小。
- b（brightness）：亮度，越大光斑越亮。

```hlsl
float i = pow(saturate(dot(reflect(-v,n),l)), s) * b;
```

#### Blinn-Phong

改进版的Phong，采用一种称为半角向量（h）的参数进行计算，开销更小，掠角观察光斑依旧圆润。

```hlsl
float3 h = normalize(v + l);
float i = pow(saturate(dot(h,n)), s) * b;
```

#### GGX

同样采用半角向量进行计算，同时光斑效果更加真实，并采用基于01范围的光滑度来控制（不过最终会转换为粗糙度）。

- s：光滑度

```hlsl
float a = max(HALF_MIN_SQRT, pow(1 - s, 2)) //粗糙度
float a2 = a * a;
float i = a2 / pow(1 + (a2 - 1) * pow(dot(h, n), 2), 2)
```

该公式有如下特点：

- 粗糙度越大时，视角权重越小，光斑越分散；
- 分子分母都受粗糙度权重影响，但分母的变化速度约等于分子的平方，故粗糙度较小时，其强度成指数变大。

结果就是该高光是可以满足能量守恒的，其光斑越大亮度越低，光斑越小时亮度越高。
