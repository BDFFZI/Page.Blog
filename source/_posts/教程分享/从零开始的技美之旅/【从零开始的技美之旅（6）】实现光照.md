# 【从零开始的技美之旅（6）】实现光照

理论上现在已经能成功实现绘制网格了，但由于片段着色器过于简单，所以画面并不出好看。所以现在来实现最关键常用的光照部分。

和现实一样，即使是游戏中的虚拟物体，我们也可以认为都是因为发光才可见，包括不含光照计算的特效，因为本质上他们是发出的自发光。所以说，任何物体的渲染，本质都是在做光的渲染。

## 光的属性

- 可溯源的：光不是凭空产生的，一定是有源头的。
- 可传递的：光是可以通过介质传递的，也正是因为传递会使光的能量发生变化，我们才能观测到传递的介质。
- 可叠加的：光的能量可以直接简单的相加来合成的，大部分情况下光都是由若干不同类型的光组合而成。

## 光照分类

### 按光的能量来源分类

- 直接光：从光源直接打到物体后反射到眼睛的光。
- 间接光：从其他物体反射到物体再反射到眼睛的光。
- 自发光：物体自身表面发出的光。

### 按光的传递方式分类

- 反射光：物体充当介质后传递进眼睛的光。
- 自发光：物体本身就是光源，导致光线直接进入眼睛的光。

### 按光的反射方式分类

- 漫射光：光在物体表面或内部多次弹射后再反射进眼睛的光。
- 镜射光：光在物体表面未经二次弹射，直接反射进眼睛的光。

## 光照物理

关于光有很多物理现象，人们对此总结出了各种经验公式和解决方案。（此处暂只讨论与光有关的物理现象，更多的是描述光的组成和物体间的关系，不涉及具体的光照反射计算）

首先我们需要获取一些关照计算上所需的参数：

- `float3 n`：法线方向（normal）
- `float3 v`：相机方向（viewDir）
- `float3 l`：灯光方向（lightDir）
- `float3 albedo`：反照率。物体反射光照的比例，更通俗名称叫颜色。
- `float metallic`：金属度。确定漫射和镜射的权重分配。
- `float smoothness`：光滑度。用于形容物体表面形状，对镜射光影响很大。

此外在此基础上还有些可预计算的常用参数：

- `float3 h = normalize(v + l);`：半角向量。一种经验参数，其混合了相机和灯光方向信息。
- `float roughness = max(HALF_MIN_SQRT, pow(1 - smoothness, 2));`：粗糙度。

### 微表面模型

从整体来看，物体表面各式各样没有规则。但利用积分的思想，我们可以想象这些表面都是有无数个相同的微小表面组合而成，于是我们便可以对各种物体的表面进行一套统一计算，一套针对微表面的计算。

### 辐射度量学

辐射度量学是一种物理学科，但我们不需要深入学习，仅仅了解其中的一些学术概念就行。

- 辐射能量：光源做工。
- 辐射功率：光源每单位时间做工。
- 辐射强度：光源从每单位立体角发出的辐射功率。
- 辐照度（Irradiance）：光源照射到表面的辐射强度。
- 辐射率（Radiance）：光源照射到表面后反射的辐射强度。

我们光照计算实际上只要考虑：获取“辐照度”和计算“辐射率”就行，这个过程也不是一定非要物理的，只是单纯用他们的名字和关系来表示一些计算中的光照参数。

### 双向反射分布

人们发现光的反射从表现效果上，实际上可以分为“漫反射”和“镜面反射”两种，漫射低频模糊，镜射高频清晰，也因此催生出了两种不同的反射光计算方法，任何非自发光都可以由这两种反射函数叠加计算而成。

针对这些反射函数的组合以及考虑其反射方向，人们将其分为了 3 类：

- BRDF：双向反射分布函数（描述反射现象）
- BTDF：双向透射分布函数（描述透射现象）
- BSDF：双向散射分布函数（BRDF+BTDF）

注意：这仅仅是一种类型，以及告诉我们计算光照，要同时考虑漫射和镜射两种。所以其具体实现完全可以因人而异自由搭配。

### 介电质全反射

只要是介电质，那就一定会发生轻微的全反射（即入射光不受反照率影响，没有被吸收且全部反射），这在后续的镜射率和非涅尔效应中也会有所体现，其最低全反射率是一个常量。

```hlsl
float dielectricSpec = 0.04;
```

### 能量守恒

如果要制作一个真实的光照，我们同样要考虑到能量守恒（当然，非物理的风格化光照不需要，否则反而还不好看）。根据“双向反射分布”，我们将光拆分为了“漫射光”和“镜射光”分开计算，因此也要注意两者在光能量上的分配。

对此人们使用一种称为“金属度”的参数，来分配两者的权重，越金属其漫射光越弱，镜射光越强，而这权重具体反映到的则是“反照率”的变化。

```hlsl
float3 diffuse = lerp(albedo * (1 - dielectricSpec), 0, metallic); //漫射反照率
float3 specular = lerp(dielectricSpec, albedo, metallic); //镜射反照率
```

注意：虽然非物理光照一般不用遵照能量守恒，但其金属度的概念却已经深度人性，即使卡通渲染，也经常会利用金属度来控制高光（镜射光）的强弱。

### 菲涅尔效应

菲涅尔是一种物理现象，其反应了物体的反照率强会随着物体折射率、法线、观察角度的不同而发生变化。最显著的例子是水面，垂直看水面时，清澈见底，平行看水面时则只能看到倒影而看不清水底了。

原始的非涅尔公式较为复杂还涉及折射率信息，难以使用，因为人们根据其实际表现形式，推出了一套经验公式（越掠角反射率越强，甚至全反射）。此外非涅尔只会影响到镜射光，故可简单将其视作是对镜射光的一道后处理。虽然漫射光也是一种反射光，但其是经过多次随机反弹后反射的光，故可以简单认为其丢失了法线、方向等信息，因此不会因为菲涅尔效应而发生变化。

```hlsl
float F = pow(1 - saturate(dot(n, v)), 5); //反射率增强系数（非涅尔系数）
```

在Unity中，非涅尔引起的反射率是有上限的，故不一定全反射，具体和物体的镜射率和光滑度有关。

```hlsl
float reflectivity = lerp(dielectricSpec, 1, metallic) //镜射率
float grazingTerm = saturate(reflectivity + smoothness);//掠角反射率
specular = lerp(specular, grazingTerm, F);
```

### 几何遮蔽

几何遮蔽用于表现微表面之间的遮挡导致的光线衰减现象，这在粗糙的表面尤为明显。这同样只对镜射光生效（漫射光本身就是经历过各种遮挡反弹返回的光，所以实际上已经考虑了几何遮蔽），可视作是镜射光的一道系数，其越大镜射光越亮，越小镜射光越小。

几何遮蔽有多种近似公式，在Unity中使用的是 sksm 几何遮蔽算法。

```hlsl
float roughness = max(HALF_MIN_SQRT, pow(1 - smoothness, 2)); //粗糙度
float G = dot(n, l) * dot(n, v) / lerp(roughness, 1, pow(dot(l,h), 2))
```

从该公式中可以观察到：

- 灯光或观察角度与表面方向越倾斜，其分子越小分母越大，故光线越容易被遮挡。
- 当角度固定时，其粗糙度越大，分母越接近上限，故光线越容易被遮挡。

## 辐照度计算

辐照度（irradiance）是指光线经过传递后最终落到微表面上的光照强度，是进行反射计算前的实际输入光照。

### 直接光

#### 实时灯光

直接从原始光源获取的灯光。Unity中将实时灯光分为“主灯光”和“附加灯光”两类，“主灯光”是平行光，但平行光也可以成为“附加灯光”，“附加灯光”自身也有很多种类。不过这些灯光信息都已经被Unity封装，成了一种可以统一处理的存在。

- `float3 positionWS`：微表面所在的世界空间位置。

```hlsl
float shadowMask = 1; //阴影遮罩技术，用于实现超远距离烘焙阴影，具体数值从哪来的，目前我也不知道
Light mainLight = GetMainLight(TransformWorldToShadowCoord(positionWS), positionWS, shadowMask);
for (int i = 0; i < GetAdditionalLightsCount(); i++)
    Light additionalLight = GetAdditionalLight(i, positionWS, shadowMask);
```

Unity提供的光照信息中并没有直接提供辐照度，需要利用光照信息计算。

- `float occlusion`：可选的环境光遮蔽参数，用于自定义辐照度强弱。
- `Light light`：从Unity中获取的原始灯光信息（上文的计算结果）。

```hlsl
float3 irradiance = light.color * light.distanceAttenuation * light.shadowAttenuation * occlusion;
```

### 间接光

间接光又叫环境光，是来自于环境中即四面八方的光。相比直接光，环境光是不可数的，因此无法实时计算，故环境光一般是基于一种叫“IBL”（基于图像的照明）的烘焙灯光技术实现的。由于“双向反射分布”的存在，故环境光针对“漫射”、“镜射”两种光，也根据其特性，使用了两种不同的烘焙方式：“光照探针”和“反射探针”。

#### 光照探针

光照探针存储的是漫射光信息。漫射光是粗糙的低频灯光，因此不需要形成像镜子那种清晰的反射画面，依此特性，为了减少内存提高性能，可以将其用球谐函数（SH）存储。

球谐函数类似于用泰勒级数解三角函数，通过有限的多项式就可以近似出超越函数的效果，进而使得三角函数可被实际用于计算，非常实用。同理球谐函数只需要存储几个参数，就可以实现输入方向输出该方向大概亮度的功能，内存占用少计算也高效。

```hlsl
float3 irradiance = SampleSH(n);
```

#### 反射探针

镜射光是高频的能形成清晰镜面的光照，因此不能使用SH，而是用一张全景贴图存储。此外镜射光还与视角和材质粗糙度有关，其中视角是动态的因此无法烘焙，但粗糙度是固定的01范围，因此可以针对不同的粗糙度多烘焙几张。由于越粗糙频率越低，贴图分辨率需求越小，因此这多张不同粗糙度烘焙的贴图可以利用mipmap存储，同时还能实现GPU自动插值光照信息。

IBL 的镜射光存储在一张具有mipmap中的环境贴图中，首先第一步就是要根据粗糙度，取出对应的光照信息。

- UNITY_SPECCUBE_LOD_STEPS：unity中默认环境贴图的最大mipmap等级。
- unity_SpecCube0：unity中的默认环境贴图。
- samplerunity_SpecCube0：unity中默认环境贴图的采样器。

```hlsl
float pr = 1 - s; //直觉上的粗糙度（perceptualRoughness）
float mipLevel = pr * (1.7 - 0.7 * pr) * UNITY_SPECCUBE_LOD_STEPS;
float4 encodedIrradiance = unity_SpecCube0.SampleLevel(samplerunity_SpecCube0, reflect(-v, n), mipLevel);
```

注意，由于IBL通常是配合HDR使用的，但部分平台不支持存储HRP纹理，导致Unity读写HRP纹理时需要编码解码，所以纹理中读取到光照数据后还需要一步解码操作（windows平台支持，故可以不解码，但移动平台需要）。

- unity_SpecCube0_HDR：unity中默认环境贴图的编码信息。

```hlsl
float3 i = DecodeHDREnvironment(encodedIrradiance, unity_SpecCube0_HDR);
```

环境镜射光较为复杂，

### 自发光

#### 光照贴图

## 辐射率计算

### 漫反射

漫反射因为多次反弹的缘故，其入射信息颜色等都大幅丢失，所以其表现效果均匀柔和，而且计算方法也变的非常简单。

- `float3 l`：灯光方向（lightDir）
- `float i`：反射光强（intensity）

#### Lambert

经典漫射光照，哪怕如今的PBR也仍在使用。

```hlsl
float i = saturate(dot(n,l));
```

#### Half-Lambert

能额外模拟环境光和此表面散射，因此得到的光效柔和阴影过渡自然，在一些特殊光效场景中经常被使用

- `float b`：亮度（brightness）。影响背光面亮度，越低越暗，越高越亮。也可以看成是lambert到half-lambert的比例，为0时为lambert，为0.5时是标准的half-lambert。

```hlsl
float i = saturate(dot(n,l) * (1-b) + b);
```

### 镜射

#### Phong

最早期的镜射光实现，使用最直观的方式计算。

- `float s`：光泽度（shininess）。越大光斑越小。
- `float b`：亮度（brightness）。越大光斑越亮。

```hlsl
float i = pow(saturate(dot(reflect(-v,n),l)), s) * b;
```

#### Blinn-Phong

改进版的Phong，采用一种称为半角向量（h）的参数进行计算，开销更小，掠角观察光斑依旧圆润。

```hlsl
float3 h = normalize(v + l);
float i = pow(saturate(dot(h,n)), s) * b;
```

#### GGX

同样采用半角向量进行计算，同时光斑效果更加真实，并采用基于01范围的光滑度来控制（不过最终会转换为粗糙度）。

- `float s`：光滑度（smoothness）

```hlsl
float r2 = r * r;
float i = r2 / pow(1 + (r2 - 1) * pow(dot(h, n), 2), 2)
```

该公式有如下特点：

- 粗糙度越大时，视角权重越小，光斑越分散；
- 分子分母都受粗糙度权重影响，但分母的变化速度约等于分子的平方，故粗糙度较小时，其强度成指数变大。

结果就是该高光是可以满足能量守恒的，其光斑越大亮度越低，光斑越小时亮度越高。

### 环境光

环境光也分漫射光和镜射光，但和传统的漫射镜射的单个光源相比，环境光来自于四面八方，相当于是无数光源，因此不可能用传统方法实时计算。不过环境光通常是固定的，且无论对什么样的材质，其同一方向区域的反射光总量肯定是一样的，因此可以对这部分进行预计算，然后再根据材质特性进行补充计算，这种方法就叫“IBL”（基于图像的照明）。

IBL就是将针对每个法向的光照反射强度，提前烘焙到一张环境贴图中，后续只需采样贴图就可以获得周围所有光的总量，而不需要真的把无数灯光都遍历一遍。

注：由于IBL中，灯光颜色也会被烘焙到数据中，因此 `i` 的类型改用 `float3` 表示。

###
## 特殊光照

### 次表面散射

次表面散射类似漫射光，只是它是从物体背面出来的光，实现类似玉石之类的透光但不透明的物体。



### 各向异性高光
