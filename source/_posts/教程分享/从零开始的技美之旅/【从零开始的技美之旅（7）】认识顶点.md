# 【从零开始的技美之旅（7）】认识顶点

顶点是GPU渲染管线中顶点着色器的输入，其结构完全由用户自定义。不过在行业中，一些顶点属性已经成了事实标准。通常来讲，顶点具有如下属性：

- `float3 position`：位置（绘制坐标，一般基于物体空间，通过变换转到NDC空间）
- `float3 normal`：法线（顶点的朝向，用于实现需要方向信息的计算，如光照）
- `float4 tangent`：切线（与法线配合可构成切线空间，实现以顶点为坐标系的功能，如法线贴图）
- `float2 uv`：纹理坐标（实现顶点到纹理的映射，从而支持采样额外的纹理数据）
- `float4 color`：颜色（额外的基于顶点存储的数据，可以按需使用）

## 顶点属性唯一性

对于每种属性，顶点同时只能持有一个。

但在一些建模软件中会发现，顶点可以同时持有多个不同的同名属性值，例如一个顶点根据不同的相邻面可以有多个法线，从而实现锐边。不过这些其实是建模软件自行实现的功能，并不能存储到GPU中实际使用的顶点数据中。当带有这种顶点的网格放入到Unity中时，Unity实际会将这些数据拆分，分配到多个新生成的顶点中。

如果此时制作一些顶点偏移的特效，就很容易出现破面的情况。虽然原始模型中，这些面是相连的，但 Unity 为了保证顶点属性的唯一性，为每个面分配了各自的顶点，于是面就断开了。

## 顶点光栅化

顶点数据是基于顶点存储，但利用光栅化，这些数据也可以通过插值传递给像素。但这种插值方式是线性插值的，因此针对某些数据时，存在一些问题。

### 非线性数据错误

![非线性数据错误](../../../assets/images/非线性顶点数据.drawio.svg)

黑色箭头是来自顶点的法线，而红色箭头是其经过光栅化插值的结果。显然由于法线作为方向，其应该是归一化的，所以那些绿色箭头才是期望的正确的结果。

### 非线性布局错误

![非线性数据错误](../../../assets/images/非线性顶点布局.drawio.svg)

黑色圆点是顶点，红色线是线性插值带来的数据变化分布。明显可以看到中间顶点与两点顶点间的数据变化形成了尖角，这种忽然的不连续变化会导致视觉上接缝的产生。实际上我们期望制作的是一个圆润的圆盘，所以绿色实线才是期望的数据变化分布。

## 切线空间

有些功能例如“法线贴图”、“视差贴图”等期望能在一个基于顶点的空间坐标系进行计算，这就引出了切线空间的需求。切线、法线和由两者叉乘得出的副切线，就构成了形成切线空间的3个基向量。

### 世界切线空间

顶点中的法线和切线默认是基于物体空间的，但实际使用中我们我们期望切线空间是基于世界空间的，因此需要先对这些基向量进行空间变换。但由于物体变换可能是非正交的，因此为了确保基向量的相互垂直，其变换方式上也要注意。

![错误的法线变换](../../../assets/images/image-8.png)

对于切线而言其采用传统的方向变换即可，而法线则需要利用特殊的技巧，来实现和切线传统变换的对冲。详细原理参考[《法线的空间变换》](../../个人研究/技术美术/【技术美术】法线的空间变换.md)。

```hlsl
float3 tangentWS = mul((float3x3)GetObjectToWorldMatrix(), tangentOS.xyz);
float3 normalWS = mul(normalOS, (float3x3)GetWorldToObjectMatrix());
```

提示：`mul`是可以交换矩阵和向量参数顺序的，这样就变成了行向量和行矩阵的计算。而因为行矩阵和列矩阵正好是相互转置的关系，所以可以利用这一机制，省去推导中转置矩阵的操作，直接计算。

### 切线空间与纹理空间

和法线不同，切线是由软件基于uv分布自动生成的。具体而言切线方向对应纹理的x轴方向（u方向），副切线对应纹理的y轴方向（v方向）。故切线空间和纹理空间是可以相互转换的，这点在“视差贴图”功能中就得到了应用。

但要注意的是，纹理空间是存在左右手两种的，也因此导致“切线空间”和“法线贴图”也存在两种：“DX”（左手系）和“OpenGL”（右手系）。

### 切线空间手系

切线空间存在左右手两种手系，手系的不同直接影响到法线贴图的数据布局。Unity 中采用的 OpenGL 的右手坐标系，故从模型内部向外看，切线在其左侧，副切线在其上方。

从贴图角度来看，当贴图内容是一个凹槽时，其凹槽图案的下方为绿色。因为从贴图角度看凹槽，下方的法向应该是向上的，故y轴值较大，表现为绿色。

![Unity中的法线贴图方向](../../../assets/images/BelievableVisualsNormalMaps.jpg)

或许是为了解决当网格自带切线时，其为非右手坐标系的问题，Unity为切线增加了额外的分量来决定是否反转副切线，从而统一手系。不过要注意的是：Unity默认计算切线的叉乘方式是法线在左，切线在右，因此计算出的副切线总是副的，所以通常 `tangent.w = -1`。

由此我们便可以得出副切线的计算方法：

```hlsl
float3 bitangentWS = cross(normalWS, tangentWS) * tangentOS.w;
```

### 构建切线空间矩阵

有了上述计算的3个切线空间基向量，我们便可以得出最终的切线空间矩阵：

```hlsl
float3x3 tangentToWorld = transpose(float3x3(tangentWS, bitangentWS, normalWS));
```

提示：hlsl 默认是基于行矩阵的，所以其矩阵赋值也是按行赋值，而 Unity 默认是基于列矩阵的，所以按行赋值构建出行矩阵后需要再进行一步转置操作，使其成为列矩阵（或者直接按行矩阵的方法用也行，Unity就是这么干的）。

## 顶点颜色

当顶点需要存储额外数据时有两种方式：

- uv+纹理
- 顶点颜色

但当存储一些特定于顶点的非纹理数据时，“uv+纹理”的方案存在一些问题：

1. 由于需要经过二次查找才能拿到数据，根据uv精度、纹理分辨率、采样器的不同很容易导致数据读取不准确。
2. uv存在缝合边的问题，逻辑上相同的顶点uv却不一定相同，进一步导致了数据读写的误差产生，还会导致断面。

所以部分情况下采用顶点颜色存储数据比纹理更加方便易用，不过可惜的是 Unity 仅提供一个顶点颜色属性，因此其存储容量是有限的。
