# 【质点弹簧实现教程（1）】认识质点弹簧

质点弹簧是一种物理模型，它将所有物体看成是由若干质点和弹簧组成的结构。这种思想其实和现实中的实际物体结构是一样的，质点对应的就是组成物质基本粒子，弹簧则是对应粒子间的相互作用力。

所以理论上质点弹簧可以模拟现实中的一切物理效果，包括刚体（刚体本质就是弹力无限大的弹簧）。只可惜计算机是有性能上线的，因此质点弹簧主要还是用于软体模拟。

## 模拟质点

质点是质点弹簧模型中的实际物理对象，弹簧则是对质点的一种力约束，两者并非密不可分的关系，所以先了解一下如何实现质点。

此处的质点与物理学中的同名概念一致，是一种研究物理规律时的理想物体，具体为一个有质量但没有体积或形状的点[^1]。另外通过分析牛顿第一、第二运动定律，以及加速度、速度、位移的关系定义，我们可以得到有关质点的如下信息：

### 质点的属性

- 位置（质点是一个点）
- 质量（质点没有体积形状，但有质量）
- 速度（牛顿第一定律说物体可以保持速度）

### 属性间关系

质点的属性是可以被改变的，若我们将这种改变看成是这些属性相对于时间的某种函数的话，还可以得到它们的关系式：

- $a(t)=f(t)/m$（牛顿第二定律公式说明了力、加速度、质量的关系）
- $v(t+\Delta t)=v(t) + a(t) * \Delta t$（牛顿第一定律说速度会被力改变）
- $p(t + \Delta t)=p(t) + v(t)*\Delta t$

（上述公式中，t 表示当前时间，$\Delta t$ 表示计算时间间隔，a 表示加速度，f 表示在 $\Delta t$ 期间物体受到的力，m 表示质量，v 表示速度，p 表示位置）

### 位置积分

通过观察质点属性间关系，可以发现很多属性在时间上是前后相关的，因此如果我们设定好间隔时间，并不断的迭代上述公式，我们便能得到质点在每一帧上的位置信息，从而模拟出质点随时间变化的物理效果。而这种不断迭代质点位置的方式，就叫对质点的位置积分。

位置积分有很多种，它们的目的都是为了求解质点每一帧的位置信息，但使用的具体算法各有不同。而我们上述计算位置的算法，如果仔细观察会发现它和求解微分方程的“显式欧拉法”是一样的，也因此我们将这种位置积分方式，叫做“显式欧拉积分”。

### 积分误差

“利用积分不断求解质点位置我们便能成功模拟质点的物理效果”，但真的是这样的吗？

积分函数中，我们使用 $\Delta t$ 来转换质点的各个属性，这表明我们假定了质点在 $\Delta t$ 期间内，其各属性都是恒定的。但在现实中这种情况显然不可能：

- 圆周运动中的物体，其受力时时刻刻都在变化，而不是某一段时间始终保持一样的速度；
- 相撞的物体，在相撞的那一刻就会立即发生反作用力而停下，而不是在一个固定时间间隔后，发觉此刻体积已相互嵌入后才受力。

而这就是 $\Delta t$ 带来的积分误差。

除了从逻辑上理解，我们还可以从数学上直观感受积分误差：

1.  根据泰勒展开，可得 $p(t)$ 在 $t_0$ 处的展开式为：

    $p(t) =p(t_0)+\frac{p'(t_0)}{1!}(t-t_0)+\frac{p''(t_0)}{2!}(t-t_0)^2+\frac{p'''(t_0)}{3!}(t-t_0)^3+\dots$

2.  其中的一些项可以替换成我们熟悉的物理属性（例如位置的一阶导是速度）

    $p(t) =p(t_0)+v(t_0)(t-t_0)+\frac{a(t_0)}{2}(t-t_0)^2+\frac{p'''(t_0)}{6}(t-t_0)^3+\dots$

3.  现在带入 $t=t_0+\Delta t$，并进一步整理，可得：

    $p(t_0+\Delta t) =p(t_0)+v(t_0)\Delta t+\frac{a(t_0)}{2}\Delta t^2+O(\Delta t^3)$

于是我们便得到了测量积分误差的基准函数 $p(t+\Delta t) = p(t)+v(t)\Delta t+\frac{a(t)}{2}\Delta t^2+O(\Delta t^3)$。将其减去任意积分函数，便可得到对应的误差大小：

- 显式欧拉：

  $\big( p(t)+v(t)\Delta t+\frac{a(t)}{2}\Delta t^2+O(\Delta t^3) \big)- \big(p(t) + v(t)\Delta t\big) \\= O(\Delta t^3) + \frac{a(t)}{2}\Delta t^2$

- 半隐式欧拉（欧拉法的另一个版本）：

  $\big( p(t)+v(t)\Delta t+\frac{a(t)}{2}\Delta t^2+O(\Delta t^3) \big)- \big(p(t) + v(t)\Delta t +a(t) \Delta t^2\big) \\= O(\Delta t^3)- \frac{a(t)}{2}\Delta t^2$

### 决定积分方法

显示欧拉和半隐式欧拉的优点是易于理解和实现，但误差还是比较大的，太大的误差容易导致物理模拟出错，严重的会导致弹簧约束无法收敛而崩溃。而另一个隐式版本的欧拉法，其精度很高，但需要求解隐函数方程，上手难度比较大。

所以虽然上述花了很多篇幅讲解欧拉法，但我并不准备用这些。介绍欧拉法最主要的原因还是为了建立对质点概念的理解。

在实际使用中，我更推荐的是一种叫韦尔莱的积分方法，该方法通过泰勒展开式推导得出，易于理解，精度也很不错。此外，利用这种积分方法可以实现一种与增量时间无关的质点弹簧系统，彻底消除应时间误差导致的弹簧崩溃问题。[^2]

故我们最终的质点积分伪代码是这样的：

```cpp
struct Particle
{
    float3 lastPosition = 0;
    float3 position = 0;
    float mass = 1;
};

void Update()
{
  for (Particle& point : allPoints)
  {
      float3 currentPosition = particle.position;
      particle.position += particle.position - particle.lastPosition;
      particle.lastPosition = currentPosition;
  }
}
```

## 模拟弹簧

质点弹簧模型中的弹簧并不是真正的弹簧，它实质是一种力约束，用于将两个质点之间的距离限制在一定范围内。

根据胡克定律有：`弹力=弹力系数*距离*方向`，其中距离和方向是由弹簧初始长度，以及当前目标约束位置计算得出。故由此可知，弹簧具有以下属性：

- 被约束的质点 A
- 被约束的质点 B
- 弹力系数
- 初始长度

接着我们可以在每次质点积分前，利用这些属性以及胡克定律，计算出每个质点受到的弹力，以便后续的质点积分能利用这些力重新计算质点的位置。

当然，上述流程是在欧拉法中的弹簧实现，由于先前的质点积分中，我们选择了另外一种特别的积分方法，因此此处的弹簧实现伪代码实际是这样的：

```cpp
struct Spring
{
    Particle particleA;
    Particle particleB;
    float length;
    float elasticity;
};

void Update()
{
  ...//质点积分代码

  for (Spring& spring : Spring)
  {
      Particle& particleA = *spring.particleA;
      Particle& particleB = *spring.particleB;
      float3 vector = particleA.position - particleB.position;
      float distance = length(vector) - spring.length;
      float3 direction = normal(vector);
      float3 move = spring.elasticity * tendency * direction;
      particleB.position += 0.5f / particleB.mass * move;
      particleA.position += 0.5f / particleA.mass * -move;
  }
}
```

## 模拟软体

当有了质点弹簧模型后，便可以进行一些简单的软体模拟了。我们唯一要做的就是利用质点和弹簧这两个物理工具，搭建出目标软体的物理结构。在如何搭建这件事上，没有什么强制性规定，我们只需要充分发挥质点和弹簧的作用，按实际需求设计即可。

当然，对于一些常见的软体，例如软绳和布料等，也会有一些前人使用过的最佳实践，下面一次来介绍，如何使用质点弹簧构建软体。

### 模拟软绳

软绳非常简单，因为其形状就是一条线。最简单的软绳只需要通过几个质点，再通过弹簧挨个串联即可。其伪代码实现如下：

```cpp
Particle particles[n];
for (int i = 0; i < std::size(particles); i++)
  particles[i] = AddParticle(float3(i, 0, 0));
for (int i = 0; i < std::size(points) - 1; i++)
  AddSpring(particles[i], particles[i + 1], 1, 1);
```

若我们希望增加软绳的硬度，例如使其能抗弯折，在外观上更像钢筋，可以额外用一些弹簧，将每个质点的间接邻居相连，这样这些多出的弹簧就生成抗弯折力：

```cpp
...//软绳代码
for (int i = 0; i < std::size(points) - 2; i+=2)
  AddSpring(particles[i], particles[i + 2], 1, 2);
```

### 模拟布料

## 参考文献

- [^1][百度百科-质点](https://baike.baidu.com/item/%E8%B4%A8%E7%82%B9/495707)
- [^2][如何做一个不会崩溃的质点弹簧](https://www.cnblogs.com/BDFFZI/p/18733944)
