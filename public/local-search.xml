<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【软件开发】vcpkg 学习笔记</title>
    <link href="/posts/4146197106.html"/>
    <url>/posts/4146197106.html</url>
    
    <content type="html"><![CDATA[<h1 id="【软件开发】vcpkg-学习笔记"><a href="#【软件开发】vcpkg-学习笔记" class="headerlink" title="【软件开发】vcpkg 学习笔记"></a>【软件开发】vcpkg 学习笔记</h1><p>“vcpkg”是一个免费开源的 C++包管理器，可以以此很方便的处理第三方库的接入，且可嵌入进 CMake 中。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>入门教程请参照：<br><a href="https://learn.microsoft.com/zh-cn/vcpkg/get_started/get-started?pivots=shell-cmd">https://learn.microsoft.com/zh-cn/vcpkg/get_started/get-started?pivots=shell-cmd</a></p><p>大概的接入流程是：</p><ol><li>安装 vcpkg。</li><li>编写 CMakePresets，接入 vcpkg 的 CMake 工具链工具。（CMake 笔记中的 CMakePresets 示例）</li><li>使用<code>vcpkg new --application</code>创建清单文件，填写所需库。</li><li>在 CMakeLists 中使用<code>find_package()</code>获取 vcpkg 库。</li><li>使用带有 vcpkg 的 CMakePresets 生成项目，完成接入。</li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="查找包"><a href="#查找包" class="headerlink" title="查找包"></a>查找包</h3><p>若要查看 vcpkg 支持的所有包，有两种方式：</p><ul><li>可以在安装目录的“vcpkg&#x2F;ports”文件夹内查看。</li><li>或者从在线的 github 仓库也可以：<br> <a href="https://github.com/microsoft/vcpkg/tree/master/ports">https://github.com/microsoft/vcpkg/tree/master/ports</a></li></ul><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><p>vcpkg 支持“经典模式”和“清单模式”两种方式安装包：</p><ul><li>经典模式，通过终端指令程序化处理。</li><li>清单模式，通过编辑根目录的“vcpkg.json”文件处理。</li></ul><p>推荐使用清单模式，因为这样使用更透明更清晰:<br><a href="https://learn.microsoft.com/zh-cn/vcpkg/reference/vcpkg-json">https://learn.microsoft.com/zh-cn/vcpkg/reference/vcpkg-json</a></p><p>文件内容示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;gtest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;imgui&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;features&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;dx12-binding&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;win32-binding&quot;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="引用包"><a href="#引用包" class="headerlink" title="引用包"></a>引用包</h3><p>关于每个包在 CMakeLists 中的使用，基本由以下两个命令构成：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(&lt;pkgCMakeName&gt; CONFIG REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(&lt;projectName&gt; PRIVATE &lt;pkgCMakeProjectName&gt;)<br></code></pre></td></tr></table></figure><p>其中 <code>projectName</code> 是你自己需要用到该包的项目，而 <code>pkgCMakeName</code> 和 <code>pkgCMakeProjectName</code> 的内容则需要进行推断，具体有两种方法：</p><ol><li>通过官方的<code>usage</code>文件得出，这是官方编写的默认引入方法。</li><li>通过查看包安装目录的一个文件得出：<br>例如要引入 gtest，通过查看 vcpkg_installed\x64-windows\share\GTestTargets.cmake 文件，其中文件名前缀<code>GTest</code>即<code>pkgCMakeName</code>，文件内的 add_library(GTest::gtest) 则表明<code>GTest::gtest</code>是<code>pkgCMakeProjectName</code>。</li></ol><p>示例引用方式如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 改编自 gtest 的 usage 文件</span><br><span class="hljs-keyword">find_package</span>(GTest CONFIG REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(Executable PRIVATE GTest::gtest GTest::gtest_main GTest::gmock GTest::gmock_main)<br><span class="hljs-comment"># 通过分析 imguiTargets.cmake 得出</span><br><span class="hljs-keyword">find_package</span>(imgui CONFIG REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(Executable PRIVATE imgui::imgui)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【软件开发】CMake 学习笔记</title>
    <link href="/posts/2795034225.html"/>
    <url>/posts/2795034225.html</url>
    
    <content type="html"><![CDATA[<h1 id="【软件开发】CMake-学习笔记"><a href="#【软件开发】CMake-学习笔记" class="headerlink" title="【软件开发】CMake 学习笔记"></a>【软件开发】CMake 学习笔记</h1><h2 id="CMake-指令"><a href="#CMake-指令" class="headerlink" title="CMake 指令"></a>CMake 指令</h2><p><a href="https://cmake.org/cmake/help/latest/manual/cmake.1.html">https://cmake.org/cmake/help/latest/manual/cmake.1.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将目标位置的CMakeLists生成为原生构建系统的项目</span><br>cmake &lt;path&gt;<br><span class="hljs-comment"># 编译已生成的原生构建系统的项目</span><br>cmake --build &lt;path&gt;<br></code></pre></td></tr></table></figure><h2 id="CMakeLists-指令"><a href="#CMakeLists-指令" class="headerlink" title="CMakeLists 指令"></a>CMakeLists 指令</h2><h3 id="核心指令"><a href="#核心指令" class="headerlink" title="核心指令"></a>核心指令</h3><p>通常必不可少的指令。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 描述CMake的最低支持版本（顶层CMake文件必带）</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION &lt;version&gt;)<br><span class="hljs-comment"># 创建一个项目</span><br><span class="hljs-keyword">project</span>(&lt;projectName&gt;)<br><span class="hljs-comment"># 添加一个子目录（子目录需要带有CMakeLists）</span><br><span class="hljs-keyword">add_subdirectory</span>(&lt;source_dir&gt;)<br><span class="hljs-comment"># 寻找一个模块（带有特定配置文件的目录将会被识别为模块，可当成项目使用）</span><br><span class="hljs-keyword">find_package</span>(&lt;packageName&gt; CONFIG REQUIRED)<br></code></pre></td></tr></table></figure><h3 id="工具指令"><a href="#工具指令" class="headerlink" title="工具指令"></a>工具指令</h3><p>一些功能性的实用指令。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置开发中的环境变量</span><br><span class="hljs-keyword">set</span>(&lt;variableName&gt; &lt;variableValue&gt;)<br><br><span class="hljs-comment"># 获取一组文件并将其路径打包在一个环境变量中，支持glob语法</span><br><span class="hljs-keyword">file</span>(&#123;GLOB | GLOB_RECURSE&#125; &lt;outputVarName&gt; &lt;inputFile&gt;...)<br><span class="hljs-comment"># 在vs中将指定文件分类到与文件系统一致的筛选器结构，而不是默认筛选器。</span><br><span class="hljs-keyword">source_group</span>(TREE &lt;fileRootDir&gt; FILES &lt;inputFile&gt;...)<br><br><span class="hljs-comment"># 复制并修改文件到指定位置。自动替换文件中的环境变量值（@&lt;var&gt;@）并自动移入当前CMakeLists的构建目录。</span><br><span class="hljs-keyword">configure_file</span>(&lt;inputFile&gt; &lt;outputFile&gt;)<br></code></pre></td></tr></table></figure><h3 id="环境指令"><a href="#环境指令" class="headerlink" title="环境指令"></a>环境指令</h3><p>用于描述开发环境</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置所需的C++标准库版本（需在指定项目输出前使用）</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD &lt;version&gt;)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">True</span>)<br><span class="hljs-comment"># 添加全局附加包含目录</span><br><span class="hljs-keyword">include_directories</span>(&lt;headerDir&gt;...)<br><span class="hljs-comment"># 添加全局附加库</span><br><span class="hljs-keyword">link_libraries</span>(&#123;&lt;projectName&gt;|&lt;libFile&gt;...&#125;)<br></code></pre></td></tr></table></figure><h3 id="项目指令"><a href="#项目指令" class="headerlink" title="项目指令"></a>项目指令</h3><p>针对单个项目的信息描述指令。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 描述项目输出（必须要设置）</span><br><br><span class="hljs-comment"># 输出为可执行文件</span><br><span class="hljs-keyword">add_executable</span>(&lt;projectName&gt; &lt;sourceFile&gt;...)<br><span class="hljs-comment"># 输出为静态/动态库文件</span><br><span class="hljs-keyword">add_library</span>(&lt;projectName&gt; [STATIC|SHARED] &lt;sourceFile&gt;...)<br><span class="hljs-comment"># 特殊的没有输出的项目</span><br><span class="hljs-keyword">add_custom_target</span>(&lt;projectName&gt; SOURCES &lt;sourceFile&gt;...)<br><br><span class="hljs-comment"># 描述项目环境（指定完项目输出后才可用）</span><br><br><span class="hljs-comment"># 添加附加包含目录</span><br><span class="hljs-keyword">target_include_directories</span>(&lt;projectName&gt; &#123;PUBLIC|PRIVATE&#125; &lt;headerDir&gt;...)<br><span class="hljs-comment"># 添加附加库</span><br><span class="hljs-keyword">target_link_libraries</span>(&lt;projectName&gt; &#123;PUBLIC|PRIVATE&#125; &#123;&lt;projectName&gt;|&lt;libFile&gt;...&#125;)<br><span class="hljs-comment"># 分类到vs中的解决方案文件夹（3.26之前需先打开 USE_FOLDERS 功能）</span><br><span class="hljs-keyword">set_target_properties</span>(&lt;projectName&gt; PROPERTIES FOLDER &lt;folderName&gt;)<br></code></pre></td></tr></table></figure><h4 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h4><ul><li><code>PUBLIC</code>：使用该选项添加引用，引用将传染给使用该项目的其他项目。</li><li><code>PRIVATE</code>：引用不具备传染性，其他使用该项目的项目可能要再次添加引用。</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>仅写出部分通常只读的变量，需用户配置的变量见“环境指令”章节。</p><h3 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h3><ul><li><code>&lt;projectName&gt;_VERSION_MAJOR</code>：声明项目时额外提供的主版本号。</li><li><code>&lt;projectName&gt;_VERSION_MINOR</code>：声明项目时额外提供的次版本号。</li></ul><h3 id="目录相关"><a href="#目录相关" class="headerlink" title="目录相关"></a>目录相关</h3><ul><li><code>PROJECT_BINARY_DIR</code>：上次调用<code>project()</code>的 CMakeLists 对应的构建目录。</li><li><code>PROJECT_SOURCE_DIR</code>：上次调用<code>project()</code>的 CMakeLists 对应的源目录。</li></ul><p>注意：<code>add_subdirectory()</code>不会影响以上两条变量的值。</p><ul><li><code>CMAKE_SOURCE_DIR</code>：顶级 CMakeLists 的源目录。</li><li><code>CMAKE_BINARY_DIR</code>：顶级 CMakeLists 的构建目录。</li><li><code>CMAKE_CURRENT_SOURCE_DIR</code>：当前 CMakeLists 的源目录。</li><li><code>CMAKE_CURRENT_BINARY_DIR</code>：当前 CMakeLists 的构建目录。</li></ul><h2 id="CMakePresets"><a href="#CMakePresets" class="headerlink" title="CMakePresets"></a>CMakePresets</h2><p><a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html">https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html</a></p><p>“CMakePresets.json”是 CMake 的配置文件，存放在项目的根目录中，用于配置一些 CMake 构建选项。</p><p>示例内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">//CMakePresets所用的版本</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-comment">//定义生成配置。可定义多个，然后在构建指令中指明。</span><br>  <span class="hljs-attr">&quot;configurePresets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">//配置名称</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">//所用的生成器，用于将CMake项目转为原生项目</span><br>      <span class="hljs-attr">&quot;generator&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Visual Studio 17 2022&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">//生成输出目录（构建目录）</span><br>      <span class="hljs-attr">&quot;binaryDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;sourceDir&#125;/build&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">//配置CMake缓存变量（一种长期存储的环境变量，存在CMakeCache.txt文件中）</span><br>      <span class="hljs-attr">&quot;cacheVariables&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-comment">//构建中使用的一些构建工具，由cmake语言写成</span><br>        <span class="hljs-attr">&quot;CMAKE_TOOLCHAIN_FILE&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$env&#123;VCPKG_ROOT&#125;/scripts/buildsystems/vcpkg.cmake&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>配置完毕后生成时通过添加<code>--preset</code>选项，如<code>cmake --preset=&lt;presetName&gt;</code>指令使用。</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li><p>仅添加些文件到 CMake 生成的解决方案文件夹中？</p><p>无法直接支持，但可使用<code>add_custom_target</code>指令间接实现：<br><a href="https://stackoverflow.com/questions/20251829/is-it-possible-to-add-files-to-a-cmake-generated-solution-folder-in-visual-studi">https://stackoverflow.com/questions/20251829/is-it-possible-to-add-files-to-a-cmake-generated-solution-folder-in-visual-studi</a></p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">CMake 官方教程</a></li><li><a href="https://cmake.org/cmake/help/latest/index.html">CMake 官方文档</a></li><li><a href="https://blog.csdn.net/qq_41314786/article/details/129970547">理解 cmake 中 PRIVATE、PUBLIC、INTERFACE 的含义和用法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【引擎开发】纹理相关属性说明</title>
    <link href="/posts/3631212322.html"/>
    <url>/posts/3631212322.html</url>
    
    <content type="html"><![CDATA[<h1 id="【引擎开发】纹理相关属性说明"><a href="#【引擎开发】纹理相关属性说明" class="headerlink" title="【引擎开发】纹理相关属性说明"></a>【引擎开发】纹理相关属性说明</h1><h2 id="伽马与线性空间"><a href="#伽马与线性空间" class="headerlink" title="伽马与线性空间"></a>伽马与线性空间</h2><p>伽马与线性空间都是一种颜色空间，也即颜色存储时的分布方式，伽马空间相比线性空间会更多的存储图片的暗色部分。</p><p>伽马空间现在是图片存储的标准格式。选择伽马空间的原因有两点：</p><ol><li>早期阴极射线管（CRT）显示器的输出会比输入颜色看上去偏暗，所以需要抬高输入值。</li><li>人的眼睛对暗色比亮色更加敏感，所以更多的保存暗色，图片视觉效果也越保真。</li><li>如今的显示器虽然可以实现线性输入输出，但也继承了 CRT 显示器的非线性特性。</li></ol><p>线性空间更符合现实光线的物理特性，所以着色器计算需要线性空间颜色。</p><h3 id="sRGB"><a href="#sRGB" class="headerlink" title="sRGB"></a>sRGB</h3><p>sRGB 是公认的标准伽马空间，所以 sRGB 也是图片的默认保存方式。</p><p>sRGB 的具体保存方式就是对原本的线性颜色值进行调色（$y&#x3D;x^{\frac{1}{2.2}}$），从而牺牲亮色空间以存储更多暗色。</p><p>光照计算时需要线性颜色，因此使用 sRGB 纹理需先将颜色逆推转回线性空间（$y&#x3D;x^{2.2}$），不然纹理就会看上去比原本亮的多。</p><h2 id="mipmaps"><a href="#mipmaps" class="headerlink" title="mipmaps"></a>mipmaps</h2><p>mipmaps 是一种 GPU 采样策略。其先基于原纹理生成多张分辨率逐渐降低的小纹理，然后根据实际渲染时纹理在屏幕上的大小占比，选择其中最合适的纹理进行采样。</p><ol><li>分辨率降低以 2 的倍数进行，mipmap 等级越高分辨率越小。</li><li>判断纹理占比大小的方式是通过<code>DDX</code>和<code>DDY</code>函数来对比当前像素与旁边像素的 uv 变化率来确定的，屏幕占比越小，变化率越大，采样所用的 mipmap 等级越大。</li></ol><p>mipmaps 可以解决纹理分辨率和实际显示分辨率不同导致的过采样问题，具体而言有以下两点：</p><ol><li>减少过采样导致的性能浪费，因为分辨率越低的纹理采样性能越高。</li><li>解决过采样导致的显示异常（摩尔纹）。</li></ol><p>为了存储额外的低分辨率纹理，mipmaps 会占用一定额外空间，如果纹理的使用常见不存在上述问题（如 UI），则不应该使用 mipmap 功能。</p><h3 id="各向异性"><a href="#各向异性" class="headerlink" title="各向异性"></a>各向异性</h3><p>各项异性指物体从不同角度来看其性质会有所不同，放在纹理中是指 uv 两个轴的变化率不同：</p><ul><li>如果正着看纹理，uv 双轴的变化率是差不多的，此时为各向同性。</li><li>如果倾斜看纹理，uv 双轴变化率可能相差非常大，此时为各项异性。</li></ul><p>默认情况下 mipmaps 只考虑正视情况，生成的 mipmap 会均匀的混合周围所有的点，但倾斜时相比正视所能看到的点数量和位置是不同的。继续用这样的 mipmap 采样就会错误采到本该消失的点，导致出现晕影，看起来就像远处被模糊了一样。</p><p>所以启用 mipmaps 后应默认启用各项异性功能。这样 mipmaps 会额外存储一些不同宽高缩放比的 mipmap 以应对倾斜采样的情况。各向异性等级越高，这种 mipmap 就越多，应对能力也就越强。</p><h2 id="过滤模式"><a href="#过滤模式" class="headerlink" title="过滤模式"></a>过滤模式</h2><p>指示 GPU 如何采用纹理。</p><ul><li>点（无过滤）：只取 uv 最近像素的颜色信息。</li><li>双线性：取 uv 最近四个像素的颜色信息并混合。</li><li>三线性：对最近两张 mipmap 进行双线性采样，然后再混合。</li></ul><h2 id="包裹模式"><a href="#包裹模式" class="headerlink" title="包裹模式"></a>包裹模式</h2><p>指示 GPU 当采样时的 uv 输入值超出 $[0,1]$ 范围时如何处理。</p><ul><li>重复：对输入值取模以纠正回范围内。</li><li>夹紧：将输入值限制在最大范围内。</li><li>镜像：类似乒乓的方式将输入值纠正回范围。</li><li>镜像一次：只在 $[-1,0]$ 范围内镜像一次，其他范围使用夹紧。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.unity.cn/cn/2022.3/Manual/LinearLighting.html">Unity 文档-颜色空间</a></li><li><a href="https://en.wikipedia.org/wiki/SRGB">Wikipedia-sRGB</a></li><li><a href="https://www.zhihu.com/question/411035839/answer/1986329452">游戏画面设置中的“各向异性过滤”是做什么的？</a></li><li><a href="https://docs.unity3d.com/2020.3/Documentation/Manual/class-TextureImporter.html">Unity 文档-纹理导入设置</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>引擎开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【软件开发】Doxygen 使用笔记</title>
    <link href="/posts/1794241118.html"/>
    <url>/posts/1794241118.html</url>
    
    <content type="html"><![CDATA[<h1 id="【软件开发】Doxygen-使用笔记"><a href="#【软件开发】Doxygen-使用笔记" class="headerlink" title="【软件开发】Doxygen 使用笔记"></a>【软件开发】Doxygen 使用笔记</h1><p>Doxygen 是通过代码注释生成文档的事实标准，借用该工具可以将文档内容与代码写在一起方便维护。</p><p><a href="https://github.com/doxygen/doxygen">https://github.com/doxygen/doxygen</a></p><h2 id="注释语法"><a href="#注释语法" class="headerlink" title="注释语法"></a>注释语法</h2><p>采用特殊的注释形式，以便 Doxygen 识别为文档内容。</p><p>文档内容支持使用一些基本 Markdown 语法编写。</p><ul><li><p>多行注释（放在注释目标的上面）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*!</span><br><span class="hljs-comment">注释内容</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>单行注释</p><ul><li>放在注释目标的上面<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//! 注释内容</span><br></code></pre></td></tr></table></figure></li><li>放在注释目标的后面<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//!&lt; 注释内容</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>文件注释（需放在文件开头）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*! @file</span><br><span class="hljs-comment">注释内容</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="生成方式"><a href="#生成方式" class="headerlink" title="生成方式"></a>生成方式</h2><p>Doxygen 必须通过读取配置文件来运行构建程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">doxygen -g <span class="hljs-comment"># 创建默认配置文件（Doxyfile）</span><br>doxygen [&lt;file&gt;] <span class="hljs-comment"># 以默认[指定]配置文件运行构建</span><br></code></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>一些常用的配置文件参数，构建前一般需要调整：</p><h3 id="生成配置"><a href="#生成配置" class="headerlink" title="生成配置"></a>生成配置</h3><ul><li>PROJECT_NAME：项目名称。</li><li>EXTRACT_ALL：实行强力提取。</li><li>GENERATE_TREEVIEW：生成侧边树样式的文档。</li><li>DISABLE_INDEX：当启用 GENERATE_TREEVIEW 时建议打开。</li></ul><h3 id="输入配置"><a href="#输入配置" class="headerlink" title="输入配置"></a>输入配置</h3><ul><li>INPUT：需要构建的源文件目录。</li><li>RECURSIVE：是否递归源文件目录。</li><li>FILE_PATTERNS：需要构建的源文件类型。</li><li>EXTENSION_MAPPING：扩展名映射。</li></ul><h3 id="输出配置"><a href="#输出配置" class="headerlink" title="输出配置"></a>输出配置</h3><ul><li>OUTPUT_LANGUAGE：输出语言。</li><li>GENERATE_LATEX：是否输出 Latex 格式。一般不需要，建议关闭。</li><li>GENERATE_HTML：是否输出 HTML 格式。</li><li>HTML_OUTPUT：HTML 格式输出目录。</li></ul><h2 id="其他提示"><a href="#其他提示" class="headerlink" title="其他提示"></a>其他提示</h2><ul><li>关于文件路径参数的填写，若要使用本地路径，必须添加<code>./</code>前缀。</li></ul><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><ul><li><a href="https://cedar-renjun.github.io/2014/03/21/learn-doxygen-in-10-minutes/">Doxygen 10 分钟入门教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】可编程渲染管线</title>
    <link href="/posts/2520479343.html"/>
    <url>/posts/2520479343.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】可编程渲染管线"><a href="#【Unity】可编程渲染管线" class="headerlink" title="【Unity】可编程渲染管线"></a>【Unity】可编程渲染管线</h1><p>Unity 最早的内置渲染管线，其代码写死在引擎内核，仅能进行一些有限的阶段控制。因此后来 SRP（可编程渲染管线）来了，使完全由用户定义渲染管线成为现实。</p><p>SRP 是一个封装的小型 API 层，提供了从 C# 脚本调度和配置渲染命令的功能。Unity 会将这些命令传递给低级图形框架，后者随后将指令发送给图形 API。</p><h2 id="SRP-的组成部分"><a href="#SRP-的组成部分" class="headerlink" title="SRP 的组成部分"></a>SRP 的组成部分</h2><h3 id="渲染管线实例和渲染管线资源"><a href="#渲染管线实例和渲染管线资源" class="headerlink" title="渲染管线实例和渲染管线资源"></a>渲染管线实例和渲染管线资源</h3><p>基于 SRP 的渲染管线都有两个关键的自定义元素，这是接入 SRP 的入口，必须要先实现它们。</p><ul><li>渲染管线资源：负责存储渲染管线所需的数据和配置。</li><li>渲染管线实例：利用渲染管线资源提供的数据，进行实际的渲染流程。</li></ul><h3 id="ScriptableRenderContext"><a href="#ScriptableRenderContext" class="headerlink" title="ScriptableRenderContext"></a>ScriptableRenderContext</h3><p>ScriptableRenderContext 是一个核心类，它是 C# 层代码与 Unity 低级图形代码的接口，借此就可以实际的调度 Unity 的图形功能。</p><h3 id="入口点和回调"><a href="#入口点和回调" class="headerlink" title="入口点和回调"></a>入口点和回调</h3><p>SRP 通过定时调用以下回调，以使用自定义的渲染流程。</p><ul><li>RenderPipeline.Render：渲染管线的核心函数，由每帧渲染时自动调用。</li><li>RenderPipelineManager 类：提供了一些额外的渲染事件函数可供注册。</li></ul>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
      <category>渲染管线</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】Mipmaps（多级渐进纹理）</title>
    <link href="/posts/865694442.html"/>
    <url>/posts/865694442.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】Mipmaps（多级渐进纹理）"><a href="#【Unity】Mipmaps（多级渐进纹理）" class="headerlink" title="【Unity】Mipmaps（多级渐进纹理）"></a>【Unity】Mipmaps（多级渐进纹理）</h1><p><a href="https://docs.unity.cn/cn/2022.3/Manual/texture-mipmaps.html">https://docs.unity.cn/cn/2022.3/Manual/texture-mipmaps.html</a></p><p>Mipmaps 是 GPU 支持的一项可选的纹理功能，这会导致额外生成一组基于原纹理但分辨率逐渐降低的小纹理，级别越高分辨率越低，之后 GPU 采样纹理时将通过一套规则选择其中最合适的纹理来进行采样。</p><h2 id="Mipmaps-的优缺点"><a href="#Mipmaps-的优缺点" class="headerlink" title="Mipmaps 的优缺点"></a>Mipmaps 的优缺点</h2><ul><li><p>加快 GPU 渲染速度：</p><p>因为越低 mip 级别的纹理分辨率也越低，所以 GPU 采样执行的操作也越少。</p></li><li><p>避免锯齿和摩尔纹出现：</p><p>自动降分辨率，可以解决当物体在屏幕的像素大小远小于纹理大小时的过采样导致的渲染显示异常。</p></li><li><p>占用额外的磁盘内存大小：</p><p>额外生成的低级别贴图也会像正常贴图一样占用磁盘和内存，约增加 33%的大小。</p></li></ul><p>所以仅当使用纹理的对象与相机有远近变化时才该使用，对于不会缩放移动的 UI 来说，使用 mipmaps 只有单纯的负面影响。</p><h2 id="GPU-如何对-mip-级别采样"><a href="#GPU-如何对-mip-级别采样" class="headerlink" title="GPU 如何对 mip 级别采样"></a>GPU 如何对 mip 级别采样</h2><p>Mipmaps 主要用在 3D 渲染中，根据现象来看，通常根据纹理对象与相机的距离，越近 GPU 越会选择 mip 级别较高的纹理，越远则选择 mip 级别越低的纹理。</p><p>更具体的过程是，当 GPU 对纹理采样时，GPU 会检查当前像素与旁边和上边像素的 uv 距离差异（通过对 uv 执行 DDX 和 DDY 函数得出）。距离越大说明物体越远，所以使用低分辨率 mip；距离越小说明物体越近，所以用高分辨率 mip。</p><p>如果为纹理启用了三线性过滤模式，GPU 对 mip 采样时还会考虑同时采样和混合相邻的 mip，从而使 mip 间过渡变得更加平滑（就像把 mip 索引从 int 变成了 float 类型）。</p><h2 id="mip-bias（Mip-偏差）"><a href="#mip-bias（Mip-偏差）" class="headerlink" title="mip bias（Mip 偏差）"></a>mip bias（Mip 偏差）</h2><p>采样器支持名为 mip bias 的设置，这可以使 GPU 选取 mip 时计算出的参照数发生偏移，从而采样比原本更高或更低级别的 mip。</p><ul><li>当未启用三线性过滤时，mipbias 为整数类型，可直接影响选取的 mip 的索引。</li><li>当启用三线性过滤时，mipbias 为小数类型，可更精细化的使采样偏向于一边的 mip，而不只是调整采样的 mip 范围。</li></ul><h2 id="Mipmap-流系统"><a href="#Mipmap-流系统" class="headerlink" title="Mipmap 流系统"></a>Mipmap 流系统</h2><p><a href="https://docs.unity.cn/cn/2022.3/Manual/TextureStreaming.html">https://docs.unity.cn/cn/2022.3/Manual/TextureStreaming.html</a></p><p>Mipmap 流系统是 Unity 上传 Mipmap 的一种方式。</p><p>默认情况下 Unity 会加载纹理的所有的 mipmaps，但并不是每个都能用上，因此存在浪费内存的性能问题。而该系统可以强迫 Unity 只加载当前摄像机渲染所要用到的 mipmaps，只需少量的 CPU 资源为代价就可能大幅减少 GPU 内存占用。</p>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
      <category>纹理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】纹理</title>
    <link href="/posts/1386286002.html"/>
    <url>/posts/1386286002.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】纹理"><a href="#【Unity】纹理" class="headerlink" title="【Unity】纹理"></a>【Unity】纹理</h1><p><a href="https://docs.unity.cn/cn/2022.3/Manual/Textures.html">https://docs.unity.cn/cn/2022.3/Manual/Textures.html</a></p><h2 id="纹理的作用"><a href="#纹理的作用" class="headerlink" title="纹理的作用"></a>纹理的作用</h2><ul><li>用于表示 3D 模型表面。</li><li>用于表示 2D 图形。</li><li>用于 GUI。</li><li>用于粒子系统。</li><li>用于地形高度贴图。</li></ul><h2 id="导入纹理"><a href="#导入纹理" class="headerlink" title="导入纹理"></a>导入纹理</h2><p>纹理是一种位图图像，通常通过其他外部软件制作后导入 Unity 中。</p><p>纹理有两种主要导入模式：</p><ul><li>纹理：3D 项目的默认格式，常做贴图使用。</li><li>精灵：2D 项目的默认格式，常做精灵、UI 使用。</li></ul><h3 id="纹理尺寸限制"><a href="#纹理尺寸限制" class="headerlink" title="纹理尺寸限制"></a>纹理尺寸限制</h3><h4 id="建议尺寸"><a href="#建议尺寸" class="headerlink" title="建议尺寸"></a>建议尺寸</h4><p>为了最佳性能，应保证纹理尺寸长宽都是 2 的幂，允许非正方形。</p><p>非 NPOT（非 2 的幂）大小的纹理，通常会占用更多的内存且 GPU 采样速度更慢且无法被压缩。甚至有些平台都不支持 NPOT 纹理大小，此时 Unity 将对纹理进行缩放填充，以牺牲更多的内存和加载速度，使其达到下个最近的 2 的幂大小。</p><p>对于非 NPOT 的图像，Unity 会在检视面板的图像大小旁标注。为了使图像满足 POT 要求，在 Unity 内可尝试以下方法：</p><ul><li>对于纹理模式图像：可利用图像检视面板的“Non-Power of 2”功能强制缩放。</li><li>对于精灵模式图像：可利用图集功能将多个 NPOT 合成一个大的 POT 图像。</li></ul><h4 id="最大尺寸"><a href="#最大尺寸" class="headerlink" title="最大尺寸"></a>最大尺寸</h4><p>不同的平台对最大纹理大小也有限制，目前最大为 16384，最小如 OpenGL ES 2.0 平台，仅支持 2048。</p><h3 id="特殊纹理导入"><a href="#特殊纹理导入" class="headerlink" title="特殊纹理导入"></a>特殊纹理导入</h3><ul><li>导入 HRP 纹理：Unity 支持包含 HDR 信息的 EXR 或 HDR 文件，导入时会自动根据目标平台选择正确的格式。</li><li>导入法线贴图：将纹理类型设为 Normal map 即可。Unity 使用基于 RGB 格式的法线贴图，或者也可以选择从灰度高度贴图生成。</li><li>导入 Alpha 贴图：确保图片中包含了 Alpha 通道信息，或者选择从灰度纹理生成 Alpha 信息。</li><li>导入细节贴图：当模型很大时受分辨率影响，主纹理无法清晰表示细节内容，此时可使用细节贴图，通常设为灰色为不可见，白色会使主纹理变量，黑色则使主纹理完全变黑。</li><li>导入反射（立方体贴图）：将纹理形状设置为 Cube 即可。</li><li>各向异性过滤：各向异性过滤使从斜掠角观察模型时依然清晰，这是一种资源密集型操作。可在质量设置面板为所有图片强制设置（若图片自己有设置，则将覆盖）。</li></ul><h2 id="纹理格式"><a href="#纹理格式" class="headerlink" title="纹理格式"></a>纹理格式</h2><p>Unity 支持导入一些常见图片格式，例如 jpg、png 等，但实际上 GPU 并不支持这些，而是使用一些对内存、采样等更加优化的硬件编码格式。</p><p>所以 Unity 导入图片后实际会转换成 GPU 支持的格式来进行存储使用，不同平台间支持的格式也有所不同。</p><p>通常 Unity 会自动选择最适合当前平台的纹理格式，但对于一些特殊纹理，例如仅使用一个通道做遮罩用，此时可以手动选择更适合的格式，例如 BC4 格式，从而在减少文件大小的同时仍能保证质量。</p><h3 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h3><p>每像素位数 (bpp) 表示单个纹理像素所需的存储量。bpp 越低磁盘内存占用越小，GPU 的内存传输带宽也会降低，所以<strong>减少纹理大小是一种可对空间时间都进行优化的手段</strong>，而纹理压缩就是一种减少 bpp 的方法。</p><p><strong>所有纹理压缩都是有损的</strong>，但为了性能考虑应保证 bpp 始终在满足视觉要求的最小值上。</p><p><strong>确保选择的目标设备支持的压缩格式</strong>，因为当目标设备不支持当前的压缩格式时，Unity 会将其解压成支持的默认未压缩格式，并将压缩与非压缩版本都存储在内存中，从而造成纹理加载变慢且占用额外的内存。</p><h3 id="Crunch-压缩"><a href="#Crunch-压缩" class="headerlink" title="Crunch 压缩"></a>Crunch 压缩</h3><p>Crunch 压缩是一种较特别的压缩格式，其能在 DXT 或 ETC 压缩的基础上，<strong>提供额外的可变比特率压缩</strong>，可以更精细的控制文件大小和质量平衡。</p><p>Crunch 压缩不是 GPU 的原生压缩格式，所以使用时会由 Unity 解压成 DXT 或 ETC 格式，然后再上传到 GPU。虽然 Crunch 压缩在压缩时比较慢，但解压速度是非常快的，所以不用太担心影响加载时间。</p><p>Crunch 压缩有助于进一步减少纹理的磁盘空间，但对运行时内存没有影响。</p><h3 id="各平台推荐、默认、支持的纹理格式"><a href="#各平台推荐、默认、支持的纹理格式" class="headerlink" title="各平台推荐、默认、支持的纹理格式"></a>各平台推荐、默认、支持的纹理格式</h3><p><a href="https://docs.unity.cn/cn/2022.3/Manual/class-TextureImporterOverride.html">https://docs.unity.cn/cn/2022.3/Manual/class-TextureImporterOverride.html</a></p><h2 id="特殊纹理"><a href="#特殊纹理" class="headerlink" title="特殊纹理"></a>特殊纹理</h2><p>这些纹理都基于 GPU 支持的功能特性。</p><h3 id="渲染纹理"><a href="#渲染纹理" class="headerlink" title="渲染纹理"></a>渲染纹理</h3><p>渲染纹理是一种 Unity 在运行时创建和更新的纹理，可交予摄像机或自行渲染其画面，然后像正常纹理一样使用。</p><h3 id="自定义渲染纹理"><a href="#自定义渲染纹理" class="headerlink" title="自定义渲染纹理"></a>自定义渲染纹理</h3><p>自定义渲染纹理是渲染纹理的扩展实现，额外提供了非常多的高级功能，常用于实现焦散、雨水效果、波纹模拟等效果。</p><ul><li>支持使用着色器更新内容，并提供了相应框架。</li><li>可自定义更新区域、更新所用着色器通道。</li><li>可自定义更新频率包括用脚本精细控制。</li><li>支持使用双缓冲区更新，在更新时自动交换纹理，解决自读写问题。</li><li>可链接自定义纹理，将多个自定义纹理串起来，Unity 会自动按需更新。</li><li>可以通过 Export 菜单将自定义渲染纹理导出成图片文件。</li></ul><p>注意双缓冲更新目前有性能问题，因为每次交换都会复制纹理，对性能影响较大。</p><h3 id="3D-纹理"><a href="#3D-纹理" class="headerlink" title="3D 纹理"></a>3D 纹理</h3><p>3D 纹理是位图图形，其中包含三维信息，而不是标准的二维信息。</p><p>通常用于仿真诸如雾或烟的体积效果，模拟体积 3D 网格，或存储动画纹理并在这些动画纹理之间平滑混合。</p><h3 id="纹理数组"><a href="#纹理数组" class="headerlink" title="纹理数组"></a>纹理数组</h3><p>纹理数组是具有相同大小&#x2F;格式&#x2F;标记的 2D 纹理的集合，这些纹理对于 GPU 而言像是单个对象，并可在着色器中使用纹理元素索引进行采样。</p><p>它们可以用于实现自定义地形渲染系统或其他特殊效果，让您高效访问大量相同大小和格式的纹理。2D 纹理数组的元素也称为切片或图层。</p><h3 id="立方体贴图"><a href="#立方体贴图" class="headerlink" title="立方体贴图"></a>立方体贴图</h3><p>立方体贴图是六个正方形纹理的集合，这些纹理代表环境中的反射。六个正方形组成一个包围着对象的虚构立方体的各面；每个面代表沿世界轴方向（向上、向下、向左、向右、 向前和向后）的视图。</p><p>立方体贴图常用于捕获对象的反射或“周围环境”；例如 天空盒和环境反射通常使用立方体贴图。</p><h3 id="立方体贴图数组"><a href="#立方体贴图数组" class="headerlink" title="立方体贴图数组"></a>立方体贴图数组</h3><p>立方体贴图数组是一个包含有大小和格式均相同的立方体贴图的数组，GPU 可以将其作为单个纹理资源进行访问。</p><p>立方体贴图数组通常用于实现高效的反射探针、光照和阴影系统。</p><h3 id="稀疏纹理"><a href="#稀疏纹理" class="headerlink" title="稀疏纹理"></a>稀疏纹理</h3><p>稀疏纹理是太大而无法完全存入显存的纹理。为了处理它们，Unity 将主纹理分解为更小的矩形部分，称为“区块”(tile)。然后，可根据需要加载各个区块。</p><p>该功能目前仅在一些相当新的 GPU 上受到支持，如 DirectX 11.2 (Windows 8.1) 系统，或者使用支持 ARB_sparse_texture 的 OpenGL。</p><h2 id="流式虚拟纹理"><a href="#流式虚拟纹理" class="headerlink" title="流式虚拟纹理"></a>流式虚拟纹理</h2><p><a href="https://docs.unity.cn/cn/2022.3/Manual/svt-streaming-virtual-texturing.html">https://docs.unity.cn/cn/2022.3/Manual/svt-streaming-virtual-texturing.html</a></p><p>流式虚拟纹理是一项实验性功能，目前仅 HDRP 支持。它将纹理拆分为瓦片，然后在需要时将这些瓦片逐步上传到 GPU 内存中。</p><p>这是 mipmap 流系统的另一种替代品，另一种优化手段。当场景中具有很多高分辨率纹理时可大幅减少 GPU 内存使用量和纹理加载时间。</p>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
      <category>纹理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Linux】Linux 使用笔记</title>
    <link href="/posts/2845903494.html"/>
    <url>/posts/2845903494.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Linux】Linux-使用笔记"><a href="#【Linux】Linux-使用笔记" class="headerlink" title="【Linux】Linux 使用笔记"></a>【Linux】Linux 使用笔记</h1><h2 id="权限属性"><a href="#权限属性" class="headerlink" title="权限属性"></a>权限属性</h2><p>权限属性共 10 位，如 drwxrwxrwx。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>第一位表示文件类型：</p><ul><li>d：目录。</li><li>l：目录映射。</li><li>-：文件。</li></ul><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>其他位分别是面向不同用户的读写权限：</p><ul><li>区间一：文件所属者。</li><li>区间二：与所属者同组的用户。</li><li>区间三：其他用户。</li></ul><p>读写权限分三种类型，对目录和文件作用各不同：</p><ul><li>对于文件：<ul><li>r：可读。</li><li>w：可写。</li><li>x：可执行（对二进制程序外没意义）。</li></ul></li><li>对于目录：<ul><li>r：可查看目录下文件。</li><li>w：可创建删除目录下文件。</li><li>x：可 cd 进目录，查看目录下文件的详细属性和文件内容。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】加载纹理和网格数据</title>
    <link href="/posts/36610906.html"/>
    <url>/posts/36610906.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】加载纹理和网格数据"><a href="#【Unity】加载纹理和网格数据" class="headerlink" title="【Unity】加载纹理和网格数据"></a>【Unity】加载纹理和网格数据</h1><p>Unity 使用同步和异步两种方式加载纹理和网格到 GPU，如果资源支持，则 Unity 将<strong>默认使用异步加载</strong>。同步加载会导致游戏卡顿，但异步则不会，所以考虑性能优化，<strong>应尽可能保证资源满足异步加载条件</strong>。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>资源数据由“元数据”（标头数据）和“像素顶点数据”（二进制数据）组成。当资源被要求加载时，其中标头数据必须立即被加载，但二进制数据实际可以在后续慢慢加载。</p><h3 id="同步上传管线"><a href="#同步上传管线" class="headerlink" title="同步上传管线"></a>同步上传管线</h3><ul><li>构建时：Unity 将标头数据和二进制数据打包在同一文件中（.res）。</li><li>运行时：需要资源时，Unity 将 .res 加载到内存中，并在加载完毕后将二进制数据上传 GPU，所有操作在同一帧中完成。</li></ul><h3 id="异步上传管线"><a href="#异步上传管线" class="headerlink" title="异步上传管线"></a>异步上传管线</h3><ul><li><p>构建时：Unity 仅将标头数据存储在 .res 文件中，二进制数据存在单独的 .resS 文件中。</p></li><li><p>运行时：先将标头数据加载进内存，随后利用异步上传方式上传二进制文件，具体流程如下：</p><ol><li>异步等待所需的内存在环形缓冲区中可用。</li><li>将数据从源 .resS 文件读取到分配的内存中。</li><li>执行后处理（纹理解压缩、网格碰撞生成、每个平台修复等）。</li><li>在渲染线程上以时间切片方式分多帧上传数据至 GPU。</li><li>释放环形缓冲器内存。</li></ol></li><li><p>存在多个异步上传命令时：</p><p>可以同时进行多个异步上传命令，所有命令共享环形缓冲区，如果环形缓冲区已满，后续命令将等待，这不会造成主线程阻塞，只是减慢异步加载过程。</p></li><li><p>当资源超出缓冲区最大大小时：</p><p>加载单个数据到 CPU 内存是一次性完成的，如果缓冲区完全无法容纳，Unity 会待缓冲区使用完毕后临时重新分配缓冲区大小，上传完后再还原，但这个过程非常缓慢。</p></li></ul><h2 id="异步加载要求"><a href="#异步加载要求" class="headerlink" title="异步加载要求"></a>异步加载要求</h2><p>资源必须满足以下要求才可支持异步上传管线，否则将一律被 Unity 用同步的方式加载。</p><ul><li><p>纹理与网格的通用要求</p><ul><li>未启用读&#x2F;写权限。</li><li>不在 Resources 文件夹中。</li><li>如果构建目标是 Android，在项目的构建设置 (Build Settings) 中启用了 LZ4 压缩。</li></ul></li><li><p>针对网格的额外要求</p><ul><li>网格没有混合形状数据。</li><li>网格没有骨骼权重数据。</li><li>网格拓扑不是四边形。</li><li>网格没有启用网格压缩。</li><li>网格不会被动态批处理。</li><li>网格数据没有被粒子系统、地形、碰撞器使用。</li></ul></li></ul><h2 id="判断是否被异步加载"><a href="#判断是否被异步加载" class="headerlink" title="判断是否被异步加载"></a>判断是否被异步加载</h2><p>可通过 Profiler 分析工具观察线程活动来识别，具有以下任意特征时表示被异步加载：</p><ul><li>具有以下标记的活动：<ul><li>AsyncUploadManager.ScheduleAsyncRead</li><li>AsyncReadManager.ReadFile</li><li>Async.DirectTextureLoadBegin</li></ul></li><li>AsyncRead 线程上活动。</li></ul><p>除此之外都表明未使用异步加载。即使依然能看到一些带有 async 的活动，但那只有 Unity 用于检测是否需要异步加载而已。</p><h2 id="配置异步加载管线"><a href="#配置异步加载管线" class="headerlink" title="配置异步加载管线"></a>配置异步加载管线</h2><p>质量设置面板可以调节部分异步加载管线的参数：</p><ul><li>Async Upload Time Slice：上传时间片，每帧花多少毫秒用于上传数据。</li><li>Async Upload Buffer Size：环形缓冲区的大小，二进制数据加载进内存的临时空间。</li><li>Async Upload Persistent Buffer：是否持续保留环形缓冲区内存而不释放。</li></ul><p>最佳的设置方法是：</p><ol><li>保证不丢帧的情况下尽可能把上传时间片调大，在一些不影响视觉效果的时候（如加载界面）还可以临时进一步调大。</li><li>通过分析器检查时间片时间是否被完全利用，如果未完全利用一般说明缓冲区大小不够用，需增加环形缓冲区大小。</li><li>超出缓冲区上限的大型资源会导致 Unity 临时重建缓冲区，如果这种情况较多，应增加默认缓冲区大小以避免发生。</li><li>释放内存会导致内存碎片，所以除非有令人信服的理由，否则不要关闭保留缓冲区内存选项。</li></ol>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】作业系统</title>
    <link href="/posts/305640944.html"/>
    <url>/posts/305640944.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】作业系统"><a href="#【Unity】作业系统" class="headerlink" title="【Unity】作业系统"></a>【Unity】作业系统</h1><p><a href="https://docs.unity.cn/cn/2022.3/Manual/JobSystem.html">https://docs.unity.cn/cn/2022.3/Manual/JobSystem.html</a></p><h2 id="技术概述"><a href="#技术概述" class="headerlink" title="技术概述"></a>技术概述</h2><p>作业系统是多线程技术的封装，使用户可以充分发挥 CPU 多核优势，大幅提高计算性能。</p><p>具体而言 Unity 封装了以下内容：</p><ul><li>多线程：Unity 将根据 CPU 内核数量智能创建和分配线程，而无需用户管理。</li><li>偷窃工作：Unity 将会自动平衡各个工作线程之间的任务量，充分利用每个线程。</li><li>安全系统：Unity 提供各种功能保证多线程中数据读写安全，从而解决多线程竞争问题。</li><li>其他可选功能包：<ul><li>Burst：高性能代码编译器，能大幅提高代码执行速度，即使不使用多线程技术。</li><li>Collections：针对作业系统使用场景，封装的一些支持更复杂操作的集合。</li><li>Entities：一种全新的 ESC 游戏框架。</li></ul></li></ul><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>作业是一个继承<code>IJob</code>等同类接口的结构体，用于描述一段需要利用作业系统完成的工作，内容包括自定义的工作参数和执行代码。</p><p>作业需要在主线程中创建调度，通常一个完整功能可能由多个作业构成，因此 Unity 允许作业间互相依赖。</p><p>根据不同的使用场景，Unity 提供了以下作业类型：</p><ul><li><code>IJob</code>：在一个作业线程上运行单个任务。</li><li><code>IJobParallelFor</code>：并行执行任务，通过每个任务的独占的索引来访问公共数据。</li><li><code>IJobParallelForTransform</code>：类似<code>IJobParallelFor</code>，但每个任务都有额外的独占转换层<code>Transform</code>可操作。</li><li><code>IJobFor</code>：类似<code>IJobParallelFor</code>，但允许以非并行的方式调度任务。</li></ul><p>所有接口都需要实现<code>Execute</code>方法，这是每个作业将会执行的代码。而自定义作业参数则需要自行使用安全类型进行声明。</p><h2 id="安全类型"><a href="#安全类型" class="headerlink" title="安全类型"></a>安全类型</h2><h3 id="Blittable-类型"><a href="#Blittable-类型" class="headerlink" title="Blittable 类型"></a>Blittable 类型</h3><p><a href="https://learn.microsoft.com/zh-cn/dotnet/framework/interop/blittable-and-non-blittable-types">https://learn.microsoft.com/zh-cn/dotnet/framework/interop/blittable-and-non-blittable-types</a></p><p>考虑 Burst 编译器的使用，Unity 的作业系统只能使用原生数据类型进行计算，因此 C# 中的很多托管类型无法使用。所以在作业系统中只能使用非托管类型数据，或者更准确的说叫 Blittable 类型。</p><h3 id="原生容器"><a href="#原生容器" class="headerlink" title="原生容器"></a>原生容器</h3><p>由于托管容器无法在作业系统中使用，为此需要改用 Unity 特制容器类型，其是 C# 层对原生内存的包装器。</p><p>内置的原生容器有如下几个：</p><ul><li>NativeArray：一个非托管类型数组。</li><li>NativeSlice：可借此从<code>NativeArray</code>中获取切片。</li></ul><p>如果需要一些更复杂的原生容器，可参考容器包：<br><a href="https://docs.unity.cn/Packages/com.unity.collections@latest/">https://docs.unity.cn/Packages/com.unity.collections@latest/</a></p><h4 id="读写权限"><a href="#读写权限" class="headerlink" title="读写权限"></a>读写权限</h4><p>因为多线程的存在，原生容器的读写权限被严格控制。</p><p>默认情况下数据是同时可读写的，但这会导致 Unity 需要额外的处理来检查并行写入的问题。若显式声明只读，则可优化这部分功能。</p><p>所以<strong>正确设置数据的读写权限可以减少一定的性能损耗，并解锁一些读写功能</strong>，这主要由用户使用一些特性标签来进行控制。</p><ul><li><code>[ReadOnly]</code>：表明数据只读。</li></ul><h4 id="内存分配器"><a href="#内存分配器" class="headerlink" title="内存分配器"></a>内存分配器</h4><p>原生内存需要自己管理，所以创建原生容器时必须声明分配器类型，以告诉 Unity 需要使用多长时间。分配器类型将影响 Unity 创建和回收内存的方式，<strong>确保正确的类型声明将获得最佳性能</strong>。</p><ul><li>Allocator.Temp：最快的分配，从栈中申请的内存，生命周期为一帧或更短。不能传递给作业，但可以在作业代码中做局部变量使用。</li><li>Allocator.TempJob：中等的分配，声明周期为四帧。常用于给作业传递数据，需要手动及时回收。</li><li>Allocator.Persistent：最慢的分配，可一直存在直到被手动回收。这是直接通过调用<a href="https://cplusplus.com/reference/cstdlib/malloc/"><code>malloc</code></a>声明的堆内存。</li></ul><h4 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h4><ul><li><p>自定义原生容器：</p><p>可创建自己的原生容器类型，具体参考文档：<br><a href="https://docs.unity.cn/2022.3/Documentation/Manual/job-system-custom-nativecontainer.html">https://docs.unity.cn/2022.3/Documentation/Manual/job-system-custom-nativecontainer.html</a></p></li><li><p>复制原生容器：</p><p>深入了解原生容器的复制相关事宜，具体参考文档：<br> <a href="https://docs.unity.cn/2022.3/Documentation/Manual/job-system-copy-nativecontainer.html">https://docs.unity.cn/2022.3/Documentation/Manual/job-system-copy-nativecontainer.html</a></p></li></ul><h3 id="特别提示"><a href="#特别提示" class="headerlink" title="特别提示"></a>特别提示</h3><ul><li>原生容器不实现<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/declarations#reference-variables"><code>return ref</code></a>，所以<code>nativeArray[0]++</code>不会修改数组内容。</li><li>静态变量将绕过所有安全系统，并可能导致软件崩溃。</li><li>仅可用原生容器获取返回值，其他变量<a href="https://stackoverflow.com/questions/65260387/why-is-nativearray-needed-to-obtain-return-values-from-unitys-job-system">只会被封送到原生内存而不会送回</a>。</li></ul><h2 id="创建并运行作业"><a href="#创建并运行作业" class="headerlink" title="创建并运行作业"></a>创建并运行作业</h2><p>创建并运行作业需要以下几步：</p><ol><li><p>创建作业：</p><p>实现<code>IJob</code>接口，并创建作业实例，传入自定义的作业数据。</p></li><li><p>安排作业：</p><p>调用<code>Schedule</code>方法，Unity 将复制作业数据（避免和其他作业同时读写），并开始在工作线程执行作业。返回的<code>JobHandle</code>可用于建立依赖项。</p></li><li><p>完成作业：</p><p>调用<code>Complete</code>方法，如果作业已完成将立即返回，否则阻塞等待。此时安全系统状态将清理，作业中的数据可再次访问。</p></li></ol><h3 id="作业依赖"><a href="#作业依赖" class="headerlink" title="作业依赖"></a>作业依赖</h3><p>调用<code>Schedule</code>方法将返回一个<code>JobHandle</code>对象，可将该<code>JobHandle</code>作为其他作业的依赖项，表示其他作业需要该作业的完成结果。</p><p>此外可以使用<code>JobHandle.CombineDependencies</code>合并依赖项，以实现同时对多个作业结果的依赖。</p><h3 id="并行作业"><a href="#并行作业" class="headerlink" title="并行作业"></a>并行作业</h3><p>Unity 将所有<code>Execute</code>执行任务划分为多个批次，然后以批次为单位分配给工作线程处理，通常每个内核都会分配一个工作线程。</p><p>当一个工作线程完成所有分配给它的批次时，它还会尝试窃取其他工作线程中尚未完成的批次继续处理，每次最多窃取一半。</p><p><strong>要优化流程，需要指定批次计数</strong>。批次计数是指每个批次的包含的<code>Execute</code>执行数量，如果值为 1 可以确保批次分配均匀，但过多的批次分配会带来一定开销，为此应逐步增加批次，直至性能提升忽略不计。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li><p>尽可能延后<code>Complete</code>的调用时机：</p><p>调用<code>Complete</code>将阻塞主线程等待作业完成，否则作业可在后台异步执行。因此非必要情况应尽可能让作业多在后台执行，例如若能接收一帧延迟，可将作业放在每帧的结束开始之间运行。</p></li><li><p>避免运行长任务，应将其拆分成互相依赖的小任务：</p><p>增加任务数有助于提高并行性，使多个作业链同时进行。否则可能耗光工作线程，导致其他独立作业无法执行，从而引起等待完成时发生的卡顿。</p></li><li><p>任务过长且无法拆分时应考虑增加批次计数：</p><p>作业系统有意尝试在尽可能多的线程上运行作业批次，增加批次计数可增加单个工作线程的压力，从而减少对其他工作线程的占用。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>脚本</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】材质</title>
    <link href="/posts/289693924.html"/>
    <url>/posts/289693924.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】材质"><a href="#【Unity】材质" class="headerlink" title="【Unity】材质"></a>【Unity】材质</h1><p><a href="https://docs.unity.cn/cn/2022.3/Manual/Materials.html">https://docs.unity.cn/cn/2022.3/Manual/Materials.html</a></p><h2 id="材质简介"><a href="#材质简介" class="headerlink" title="材质简介"></a>材质简介</h2><p>在 Unity 中绘制任何东西都需要网格和材质两种资源，网格描述形状，材质描述外观。</p><p>材质与着色器紧密相关，就好像是着色器的一个对象实例，必须先有着色器才能创建材质球。</p><h2 id="基于物理的渲染材质验证器"><a href="#基于物理的渲染材质验证器" class="headerlink" title="基于物理的渲染材质验证器"></a>基于物理的渲染材质验证器</h2><p>在 PBR 渲染中，对于物体的反照率和金属度等实际有一组确认符合现实的参数标准，利用该渲染模式可以检查这一点。<br><a href="https://docs.unity.cn/cn/2022.3/Manual/MaterialValidator.html">https://docs.unity.cn/cn/2022.3/Manual/MaterialValidator.html</a></p><h2 id="材质变体"><a href="#材质变体" class="headerlink" title="材质变体"></a>材质变体</h2><p>从 Unity2022 开始增加了材质变体功能，类似材质版的预制体功能。<br><a href="https://docs.unity.cn/cn/2022.3/Manual/materialvariant-landingpage.html">https://docs.unity.cn/cn/2022.3/Manual/materialvariant-landingpage.html</a></p>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】网格笔记</title>
    <link href="/posts/810271066.html"/>
    <url>/posts/810271066.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】网格笔记"><a href="#【Unity】网格笔记" class="headerlink" title="【Unity】网格笔记"></a>【Unity】网格笔记</h1><p><a href="https://docs.unity.cn/cn/2022.3/Manual/mesh.html">https://docs.unity.cn/cn/2022.3/Manual/mesh.html</a></p><h2 id="网格的作用"><a href="#网格的作用" class="headerlink" title="网格的作用"></a>网格的作用</h2><p>网格用于描述物体的形状结构。</p><ul><li>在图形上：配合材质球进行渲染。网格负责描述形状，材质球负责描述外观。</li><li>在物理上：用于确定碰撞体的形状范围。</li></ul><h2 id="获取网格"><a href="#获取网格" class="headerlink" title="获取网格"></a>获取网格</h2><p>可以通过以下方式将网格添加到 Unity 中。</p><ul><li>在 3D 建模软件中建模，网格将作为模型的一部分导入。</li><li>通过 Unity 内置的原始形状或建模插件（如 ProBuilder）创建网格。</li><li>使用 Unity 提供的 API，在代码中创建网格。</li></ul><h2 id="访问网格"><a href="#访问网格" class="headerlink" title="访问网格"></a>访问网格</h2><p>网格资源对应于<code>Mesh</code>类，具体结构参考另外的网格数据结构笔记。</p><p>每种数据都有函数和属性两种方式访问：</p><ul><li>属性访问：旧方法，每次使用都会创建新数组，性能极低。如<code>Mesh.vertices</code>。</li><li>函数访问：不会每次访问时都分配新数组，建议使用。如<code>Mesh.GetVertices</code>。</li></ul><p>此外 Unity 还提供一些更低级的函数可以直接操控原始网格数据缓冲区，用于满足高性能需求：</p><ul><li>底层访问：如<code>Mesh.SetIndexBufferData</code>、<code>Mesh.SetVertexBufferData</code>等。</li></ul><h2 id="特别网格功能"><a href="#特别网格功能" class="headerlink" title="特别网格功能"></a>特别网格功能</h2><h3 id="可变形网格"><a href="#可变形网格" class="headerlink" title="可变形网格"></a>可变形网格</h3><p>网格的形状可以实时发生改变，从而实现动态性的渲染效果，具体而言有以下几种类型：</p><ul><li>蒙皮网格：网格中额外带有骨骼骨架信息，可在骨骼移动时逼真的控制网格形状，通常用于实现角色动作动画或物理上的布娃娃效果。</li><li>具有混合形状的网格：网格中额外带有混合形状数据，使网格可以在多个形状之间的插值，通常用于实现角色的面部动画。</li><li>配合 Cloth 组件的网格：用于实现逼真的布料模拟。</li></ul><p>上述的可变性网格都必须借助<code>SkinnedMeshRenderer</code>组件实现。</p><h3 id="网格-LOD"><a href="#网格-LOD" class="headerlink" title="网格 LOD"></a>网格 LOD</h3><p>网格的面越多渲染开销就越大，特别是随着网格与相机的距离增加，此时高精度的模型在渲染效果上已失去优势，反而会造成 GPU 运算资源的浪费。</p><p>借助 <code>LODGroup</code> 组件，Unity 支持在不同的距离下使用不同的渲染器进行渲染。所以要按照从近到远，准备多个不同精度的模型按需渲染（对于末尾的 LOD，通常会改用广告牌渲染器），从而优化渲染性能。</p><h4 id="配置-LOD-网格"><a href="#配置-LOD-网格" class="headerlink" title="配置 LOD 网格"></a>配置 LOD 网格</h4><p>Unity 支持两种方式配置 LOD 网格：</p><ul><li>手动创建带有<code>LODGroup</code>组件的游戏对象，并手动配置 LOD 级别。</li><li>在外部建模软件中创建符合 LOD 规范的模型：文件内存在多个同名模型，且都有自己 LOD 后缀。如“Cube_LOD0”、“Cube_LOD1”。</li></ul><h4 id="项目中的-LOD-设置"><a href="#项目中的-LOD-设置" class="headerlink" title="项目中的 LOD 设置"></a>项目中的 LOD 设置</h4><p>在 Quality settings 窗口中有一些关于 LOD 的选项。</p><ul><li>Maximum LOD Level：从构建中排除高于指定 LOD 级别的网格。</li><li>LOD Bias：决定了处于阈值距离时选用更高还是更低的 LOD 级别。</li></ul><h3 id="压缩网格"><a href="#压缩网格" class="headerlink" title="压缩网格"></a>压缩网格</h3><p>Unity 支持两种方法压缩网格来减少大小或提高性能。</p><h4 id="顶点压缩"><a href="#顶点压缩" class="headerlink" title="顶点压缩"></a>顶点压缩</h4><ul><li>设置方式：在 Player 面板设置，默认启用部分。将影响项目中的所有网格。</li><li>实现方式：将选择的网格数据从默认的 32 位浮点数改为较低精度的 16 位来存储。</li><li>优点：可减少网格的文件、内存大小，并可能略微提高 GPU 性能。</li><li>缺点：会造成精度损失，如果压缩 Position 和 Tex Coord 1 通道还可能造成伪影。</li><li>限制条件：<ul><li>网格必须禁用“Read&#x2F;Write Enabled”功能。</li><li>网格必须禁用“网格压缩”功能。</li><li>网格不能是蒙皮网格。</li><li>网格不能符合动态批处理条件，或设置中有关闭动态批处理。</li><li>目标平台必须支持 16 位浮点数。</li></ul></li></ul><h4 id="网格压缩"><a href="#网格压缩" class="headerlink" title="网格压缩"></a>网格压缩</h4><ul><li>设置方式：在每个模型导入面板设置，默认关闭。仅影响被设置的单个网格。</li><li>实现方式：将网格数据换成用最大值最小值间的位置信息存储，运行时再解压回原始数据。</li><li>优点：大幅减少文件大小。</li><li>缺点：造成精度损失，增加加载时间和临时内存使用，并可能造成网格显示伪影。</li></ul>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
      <category>网格</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】网格数据结构</title>
    <link href="/posts/3454640855.html"/>
    <url>/posts/3454640855.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】网格数据结构"><a href="#【Unity】网格数据结构" class="headerlink" title="【Unity】网格数据结构"></a>【Unity】网格数据结构</h1><p><a href="https://docs.unity.cn/cn/2022.3/Manual/AnatomyofaMesh.html">https://docs.unity.cn/cn/2022.3/Manual/AnatomyofaMesh.html</a></p><h2 id="基本构成"><a href="#基本构成" class="headerlink" title="基本构成"></a>基本构成</h2><p>网格由以下几部分数据组成：</p><ul><li>顶点：3D 空间中的位置集合以及可选的附加数据。</li><li>拓扑：网格每个面的结构类型，默认情况下都是三角型。</li><li>索引：描述如何将顶点组合成拓扑表面。</li></ul><p>对于可变性网格，还包含些额外数据：</p><ul><li>混合形状：混合形状数据。</li><li>绑定姿势：蒙皮网格中骨架基本姿势数据。</li></ul><h2 id="顶点数据"><a href="#顶点数据" class="headerlink" title="顶点数据"></a>顶点数据</h2><p>顶点数据由多个数组构成，每个数组负责存储一组顶点数据的元素（又称为顶点属性），数组的长度与顶点数量一致，以保证每个顶点对于一组顶点数据。</p><p>Unity 支持以下顶点属性：</p><ul><li>位置</li><li>法线</li><li>切线</li><li>颜色</li><li>纹理坐标</li><li>混合指数和骨骼权重</li></ul><h3 id="位置（float3-）"><a href="#位置（float3-）" class="headerlink" title="位置（float3[]）"></a>位置（float3[]）</h3><p>表示顶点在对象空间中的位置，用于确定网格的表面。</p><h3 id="法线（float3）"><a href="#法线（float3）" class="headerlink" title="法线（float3）"></a>法线（float3）</h3><p>从顶点位置的曲面直接“向外”指向的方向，用于计算光照反射效果。</p><h3 id="切线（float4）"><a href="#切线（float4）" class="headerlink" title="切线（float4）"></a>切线（float4）</h3><p>在顶点位置沿曲面的“u”（水平纹理）轴指向的方向，其中 w 分量额外用于表示双法线方向（解决图形 API 手系差异），用于实现法线贴图映射。</p><h3 id="颜色（float4）"><a href="#颜色（float4）" class="headerlink" title="颜色（float4）"></a>颜色（float4）</h3><p>表示顶点的基色，可借此存储一些自定义顶点数据以实现特效。</p><h3 id="纹理坐标（float2）"><a href="#纹理坐标（float2）" class="headerlink" title="纹理坐标（float2）"></a>纹理坐标（float2）</h3><p>指示纹理的哪个位置与顶点位置的网格表面对齐，以实现纹理到网格表面的映射。</p><p>纹理坐标通常称为 UV， 而这些集合称为通道，最多 8 个通道（UV0~UV7）。默认情况下 Unity 使用 UV0 存储常规纹理 UV；UV1 存储光照贴图 UV；UV2 存储实时光照贴图 UV。</p><h3 id="混合指数和骨骼权重（int，float）"><a href="#混合指数和骨骼权重（int，float）" class="headerlink" title="混合指数和骨骼权重（int，float）"></a>混合指数和骨骼权重（int，float）</h3><p>混合指数是骨骼的索引，用于表示顶点受哪些骨骼的控制；骨骼权重则描述这些控制骨对顶点的影响程度。Unity 将两者放在一起存储。</p><p>过去 Unity 最多允许一个顶点受 4 根骨骼的影响（使用 BoneWeight 存储），现在则支持最多 256 个骨骼（使用 BoneWeight1 存储）。</p><h2 id="拓扑学（enum）"><a href="#拓扑学（enum）" class="headerlink" title="拓扑学（enum）"></a>拓扑学（enum）</h2><p>拓扑描述网格所具有的面类型，其确定了索引缓冲区的数据结构。</p><p>Unity 支持以下拓扑类型：</p><ul><li>点</li><li>线条</li><li>三角形（默认）</li><li>四边形</li></ul><h2 id="索引数据（int-）"><a href="#索引数据（int-）" class="headerlink" title="索引数据（int[]）"></a>索引数据（int[]）</h2><p>索引数组表示了网格面所引用的顶点数据在顶点属性数组中的位置，其布局受拓扑类型影响。</p><p>索引顶点的顺序将决定面的正反，能观察面的顶点索引顺序为顺时针的一面为正面。正反面将影响剔除功能的执行结果。</p><h2 id="混合形状"><a href="#混合形状" class="headerlink" title="混合形状"></a>混合形状</h2><p>混合形状存储了网格的不同形状的版本，Unity 通过对这些形状进行插值以实现变形效果，常用于实现人物表情动画。</p><p>混合形状的数据是“稀疏的”，只会存储受影响的顶点数据。数据包括位置、法线、切线的增量，以及用于表示对应顶点的索引值。索引值的具体映射与向 Unity 请求数据的方式有关。</p><h2 id="绑定姿势（Matrix4x4-）"><a href="#绑定姿势（Matrix4x4-）" class="headerlink" title="绑定姿势（Matrix4x4[]）"></a>绑定姿势（Matrix4x4[]）</h2><p>绑定姿势用于描述骨架处于初始状态时的变换信息，从而使顶点在后续可以按初始状态时与骨骼的相对位置进行运动。</p><p>这是一个与骨骼数量一致的矩阵数组，每个矩阵都是从网格的物体空间到对应骨骼空间的变换矩阵。</p>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
      <category>网格</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【软件开发】正则表达式</title>
    <link href="/posts/2373330896.html"/>
    <url>/posts/2373330896.html</url>
    
    <content type="html"><![CDATA[<h1 id="【软件开发】正则表达式"><a href="#【软件开发】正则表达式" class="headerlink" title="【软件开发】正则表达式"></a>【软件开发】正则表达式</h1><p>正则表达式是一种强大的高级字符串匹配方法。</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>用于代表某些字符。</p><h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><ul><li><code>.</code>：除了换行回车符以外的任何单个字符。</li><li><code>\w</code>：匹配任意一个字母、数字、下划线。</li><li><code>\d</code>：匹配任意一个阿拉伯数字。</li></ul><h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><ul><li><code>\f</code>：匹配一个换页符。</li><li><code>\n</code>：匹配一个换行符。</li><li><code>\r</code>：匹配一个回车符。</li><li><code>\t</code>：匹配一个制表符。</li><li><code>\v</code>：匹配一个垂直制表符。</li><li><code>\s</code>：匹配任何空白文字。</li><li><code>\S</code>：匹配任何非空白文字。</li><li><code>\cx</code>：匹配由 x 指定的控制字符，所有非打印字符都可通过该方式指定。</li></ul><h3 id="表达式字符"><a href="#表达式字符" class="headerlink" title="表达式字符"></a>表达式字符</h3><p>可借助表达式功能实现通过自定义规则表达单个字符。</p><ul><li><code>[]</code>：创建一个表达式，匹配其中的任何字符。</li><li><code>^</code>：表达式取反，不匹配其中的任何字符。</li><li><code>-</code>：表示一个区间，匹配区间内的所有字符。</li></ul><p>如<code>[^A-Z]</code>表示匹配所有非大写字母字符。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>部分字符有特殊功能，所以表示它们需要在前面加上<code>\</code>进行转义。</p><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>描述前述通配符的通配次数</p><ul><li><code>*</code>：匹配零次或多次。</li><li><code>+</code>：匹配一次或多次。</li><li><code>?</code>：匹配零次或一次。</li><li><code>&#123;n&#125;</code>：固定匹配 n 次。</li><li><code>&#123;n,&#125;</code>：至少匹配 n 次。</li><li><code>&#123;n,m&#125;</code>：最少匹配 n 次，最多匹配 m 次。</li></ul><h3 id="贪婪"><a href="#贪婪" class="headerlink" title="贪婪"></a>贪婪</h3><p><code>*</code>和<code>+</code>限定符都是贪婪的，它们会保证在正则表达式匹配的情况下，尽可能多的匹配文字。</p><p>但可通过在其后面加上一个<code>?</code>使其非贪婪，即匹配满足要求的最短文字。</p><h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><p>用于限制通配规则在句子中的位置。</p><ul><li><code>^</code>：句子开头。</li><li><code>$</code>：句子结尾。</li><li><code>\b</code>：单词边界。</li><li><code>\B</code>：非单词边界。</li></ul><h2 id="附加功能"><a href="#附加功能" class="headerlink" title="附加功能"></a>附加功能</h2><p>正则表达式支持的一些在特定情况才可使用且常用的功能。</p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>利用<code>()</code>可以从匹配的字符串中捕获分组。这主要在程序中使用，以便更精细获取匹配结果。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符又称标记，可用于指定额外的匹配。如果支持，通常需要将正则表达式用<code>//</code>括起来，然后在后面添加修饰符，修饰符可同时提供多个。</p><ul><li><code>i</code>：匹配时忽略大小写。</li><li><code>g</code>：全局匹配。查找所有的匹配项，否则仅匹配首个。</li><li><code>m</code>：多行匹配。使定位符<code>^</code>和<code>$</code>匹配每一行的开头和结尾，而不是字符串的开头结尾。</li><li><code>s</code>：使<code>.</code>也匹配换行回车符，即真正的任何字符。</li></ul><p>如<code>/a/gi</code>表示匹配所有的 a 或 A 字符。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.runoob.com/regexp/regexp-syntax.html">菜鸟教程-正则表达式</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】优化着色器性能笔记</title>
    <link href="/posts/4183025058.html"/>
    <url>/posts/4183025058.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】优化着色器性能笔记"><a href="#【Unity】优化着色器性能笔记" class="headerlink" title="【Unity】优化着色器性能笔记"></a>【Unity】优化着色器性能笔记</h1><p><a href="https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderPerformance.html">https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderPerformance.html</a></p><h2 id="仅执行所需的运算"><a href="#仅执行所需的运算" class="headerlink" title="仅执行所需的运算"></a>仅执行所需的运算</h2><ul><li><p>去除无效计算：</p><p>例如为材质增加了基础色功能，但所有材质都只用默认的白色，那这种功能就是无效功能，可去除或借助变体功能拆分成多个着色器。</p></li><li><p>减少计算频率：</p><p>尽可能将计算放在低频率的过程中，例如将像素着色器中的计算移到顶点着色器，甚至完全移出着色器在外部计算再设置回着色器。</p></li></ul><h2 id="降低计算精度"><a href="#降低计算精度" class="headerlink" title="降低计算精度"></a>降低计算精度</h2><p>由于改进的 GPU 寄存器分配或针对低精度数学的“快速路径”执行单元，较低的数字精度通常有更好的运算性能。哪怕没有原始性能优势，低精度运算通常也能起到降低功耗延长电池续航的效果。</p><p>因此只要精度够用，应尽可能降低数字精度。</p><ul><li><code>float</code>：世界位置、纹理坐标</li><li><code>half</code>：矢量、HDR 颜色</li><li><code>fixed</code>：普通纹理颜色（这只对非常老的设备有效，目前更推荐 half）</li></ul><p>对于精度的测试必须要在目标设备上进行，因为高端 GPU 通常会将默认精度以下的精度做和默认精度一样的处理（如统一看作<code>float</code>），所以只有在低端设备上才能感受到精度降低带来的优化或显示异常。</p><h2 id="减少复杂运算"><a href="#减少复杂运算" class="headerlink" title="减少复杂运算"></a>减少复杂运算</h2><ul><li>减少超越函数</li></ul><p>超越函数（如<code>pow</code>,<code>exp</code>,<code>log</code>,<code>cos</code>,<code>sin</code>,<code>tan</code>等），会占用大量的 GPU 资源，避免使用。如果可以建议改为在外部预计算然后通过缓冲区或纹理传入。</p><ul><li>减少自建函数</li></ul><p>如果所需操作可用内置函数实现，就不要自行实现，内置函数有特别的编译优化，会比自己写的好得多。</p><h2 id="选择性执行-Alpha-测试"><a href="#选择性执行-Alpha-测试" class="headerlink" title="选择性执行 Alpha 测试"></a>选择性执行 Alpha 测试</h2><p>Alpha 测试或等效函数<code>clip()</code>在不同平台有不同的性能特征。</p><ul><li>一般情况下使用该功能移除大部分平台上的透明像素时都可获得少量性能优势。</li><li>但在 ios 或某些 Android 设备的 PowerVR GPU 上，该功能是资源密集型任务，反而会对性能产生负面影响。</li></ul><h2 id="避免使用颜色遮罩"><a href="#避免使用颜色遮罩" class="headerlink" title="避免使用颜色遮罩"></a>避免使用颜色遮罩</h2><p>在某些平台（主要是 iOS 和 Android 设备的移动端 GPU）上，<code>Color Mask</code>是资源密集型的操作，除非绝对需要，否则不要使用。</p><h2 id="优化表面着色器"><a href="#优化表面着色器" class="headerlink" title="优化表面着色器"></a>优化表面着色器</h2><p>针对表面着色器也支持一些特定的功能优化，详细见官方文档。</p><h2 id="调试着色器"><a href="#调试着色器" class="headerlink" title="调试着色器"></a>调试着色器</h2><p>在使用 DirectX 11 或 12 的 Windows 平台上，可以使用 Visual Studio 调试 Unity 应用程序中的着色器，以便分析着色器问题或性能优化点。</p><p><a href="https://docs.unity.cn/cn/current/Manual/SL-DebuggingD3D11ShadersWithVS.html">https://docs.unity.cn/cn/current/Manual/SL-DebuggingD3D11ShadersWithVS.html</a></p><p>如果使用的是 DirectX 12，Microsoft 建议使用 PIX 而不是 Visual Studio 来调试着色器。</p><p><a href="https://docs.unity.cn/cn/current/Manual/DebuggingShadersWithPIX.html">https://docs.unity.cn/cn/current/Manual/DebuggingShadersWithPIX.html</a></p>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
      <category>着色器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】着色器平台差异笔记</title>
    <link href="/posts/3262553639.html"/>
    <url>/posts/3262553639.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】着色器平台差异笔记"><a href="#【Unity】着色器平台差异笔记" class="headerlink" title="【Unity】着色器平台差异笔记"></a>【Unity】着色器平台差异笔记</h1><p><a href="https://docs.unity.cn/cn/2022.3/Manual/SL-PlatformDifferences.html">https://docs.unity.cn/cn/2022.3/Manual/SL-PlatformDifferences.html</a></p><p>部分情况下，不同的图形 API 之间的渲染行为存在差异。通常 Unity 会隐藏这些差异，但有时候仍需要手动处理。</p><p>Unity 以 OpenGL 类平台约定作为标准，默认情况下会自动进行转换。</p><h2 id="渲染纹理坐标"><a href="#渲染纹理坐标" class="headerlink" title="渲染纹理坐标"></a>渲染纹理坐标</h2><ul><li>Direct3D 类：顶部坐标为 0 并向下增加。适用于 Direct3D、Metal 和游戏主机。</li><li>OpenGL 类：底部坐标为 0 并向上增加。适用于 OpenGL 和 OpenGL ES。</li></ul><p>受此影响采样的贴图可能上下翻转，并且创建的切线空间的也可能手系错误。</p><h2 id="裁剪空间坐标"><a href="#裁剪空间坐标" class="headerlink" title="裁剪空间坐标"></a>裁剪空间坐标</h2><ul><li>Direct3D 类：近平面为 1，远平面为 0。</li><li>OpenGL 类：近平面为-1，远平面为 1。</li></ul><h2 id="着色器计算精度"><a href="#着色器计算精度" class="headerlink" title="着色器计算精度"></a>着色器计算精度</h2><ul><li>PC GPU：所有浮点类型统一视为 float 处理。</li><li>移动 GPU：不同浮点类型精度不同，且可能不支持 IEEE754 浮点标准。</li></ul><p>建议确保在目标测试着色器。</p><h2 id="着色器中的-const-声明"><a href="#着色器中的-const-声明" class="headerlink" title="着色器中的 const 声明"></a>着色器中的 const 声明</h2><ul><li>HLSL：与 c# 相同，指在当前作用域变量只读，可按任何方式初始化。</li><li>GLSL：表示变量是编译时常量，不能使用运行时数据初始化。</li></ul><p>建议以 GLSL 规则为准。</p><h2 id="常量缓冲区布局"><a href="#常量缓冲区布局" class="headerlink" title="常量缓冲区布局"></a>常量缓冲区布局</h2><p>部分平台会对缓冲区内的数据进行内存对齐，导致如<code>float3</code>变成了<code>float4</code>，因而写入数据时可能会发生错误。</p><p>因此建议缓冲区布局应遵照如下规则。</p><ul><li>使用<code>float4</code>类型，代替<code>float3</code>，<code>float4</code>在各平台都是一致的。</li><li>变量声明顺序应从大到小，如<code>float4</code>然后<code>float2</code>最后<code>float</code>。</li></ul><h2 id="着色器使用的语义"><a href="#着色器使用的语义" class="headerlink" title="着色器使用的语义"></a>着色器使用的语义</h2><p>要让着色器在所有平台上运行，一些着色器值应该使用以下语义：</p><ul><li>顶点着色器输出（裁剪空间位置）：<code>SV_POSITION</code>。有时也可能是<code>POSITION</code>。注意这不适用于 Sony PS4 或曲面细分情况。</li><li>片元着色器输出（颜色）：<code>SV_Target</code>。有时也可能是<code>COLOR</code>或<code>COLOR0</code>。注意这不适用于 Sony PS4。</li><li>将网格渲染为点时，必须从顶点着色器输出：<code>PSIZE</code>。某些平台（如 OpenGL ES 或 Metal）若未提供<code>PSIZE</code>会将点大小视为未定义。</li></ul><h2 id="Direct3D-着色器编译器语法"><a href="#Direct3D-着色器编译器语法" class="headerlink" title="Direct3D 着色器编译器语法"></a>Direct3D 着色器编译器语法</h2><p>Direct3D 平台的 HLSL 着色器编译器相比其他编译器更加严格。</p><ul><li>变量在输出前必须完全初始化，包括分量值。</li><li>不可在顶点着色器使用<code>tex2D</code>，因为顶点阶段不存在 uv 导数。需要改用着色器模型 3.0 中的<code>tex2Dlod</code>。</li></ul><h2 id="着色器中的-DirectX-11-语法"><a href="#着色器中的-DirectX-11-语法" class="headerlink" title="着色器中的 DirectX 11 语法"></a>着色器中的 DirectX 11 语法</h2><p>表面着色器编译管线的某些部分不能理解 DirectX 11 语法。</p><p>如果用到了这些特别的语法，需将其包裹在<code>SHADER_API_D3D11</code>预处理器宏中。</p><h2 id="使用着色器帧缓冲提取"><a href="#使用着色器帧缓冲提取" class="headerlink" title="使用着色器帧缓冲提取"></a>使用着色器帧缓冲提取</h2><p>一些 GPU（最明显的是 iOS 上基于 PowerVR 的 GPU）允许您通过提供当前片元颜色作为片元着色器的输入来实现某种可编程的混合阶段。</p><p>详细参见官方文档。</p><h2 id="着色器中的深度方向"><a href="#着色器中的深度方向" class="headerlink" title="着色器中的深度方向"></a>着色器中的深度方向</h2><p>DirectX 11, DirectX 12, Metal: Reversed direction</p><ul><li>深度缓冲区值：在近平面为 1，在远平面为 0。</li><li>裁剪空间范围：$[near,0]$</li></ul><p>其他平台：传统方向</p><ul><li>深度缓冲区值：在近平面为 0，在远平面为 1。</li><li>裁剪空间范围：<ul><li>在 Direct3D 类平台：$[0,far]$</li><li>在 OpenGL 类平台：$[-near,far]$</li></ul></li></ul><p>有关深度的处理和其他信息，详见官方文档。</p>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
      <category>着色器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】PassCode 语法笔记</title>
    <link href="/posts/3793607597.html"/>
    <url>/posts/3793607597.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】PassCode-语法笔记"><a href="#【Unity】PassCode-语法笔记" class="headerlink" title="【Unity】PassCode 语法笔记"></a>【Unity】PassCode 语法笔记</h1><p><a href="https://docs.unity.cn/cn/2022.3/Manual/SL-ShaderPrograms.html">https://docs.unity.cn/cn/2022.3/Manual/SL-ShaderPrograms.html</a></p><p>PassCode 区域存放实际的渲染代码，目前支持 3 种写法。</p><ul><li><p>固定函数着色器（过时）</p><p><a href="https://docs.unity.cn/cn/2019.4/Manual/ShaderTut1.html">https://docs.unity.cn/cn/2019.4/Manual/ShaderTut1.html</a></p><p>一个早期旧版着色器，使用内置的函数快速编写一些简单的着色器，不需要会 HLSL，但扩展能力差。</p></li><li><p>表面着色器（过时）</p><p><a href="https://docs.unity.cn/cn/2019.4/Manual/SL-SurfaceShaders.html">https://docs.unity.cn/cn/2019.4/Manual/SL-SurfaceShaders.html</a></p><p>使用 HLSL 编写，但对光照等功能进行了封装，不需要自己实现，也因此编写比较简单同时具备一定扩展能力。但新出的 SRP 不支持该写法，看样子官方要用 Shader Graph 代替它。</p></li><li><p>顶点和片元着色器</p><p><a href="https://docs.unity.cn/cn/2019.4/Manual/SL-ShaderPrograms.html">https://docs.unity.cn/cn/2019.4/Manual/SL-ShaderPrograms.html</a></p><p>接近原生的 HLSL 体验，光照等功能都需要自行实现，难度较高，但通用性最强，一般考虑利用改源码的方式实现，从而简化制作流程。</p></li></ul><p>根据兼容性下面只记录“顶点和片元着色器”写法。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>所有的 PassCode 代码必须要写在代码块中，代码块里存放着 Shader 程序实际运行用的 HLSL 源代码。</p><p>共支持四种代码块形式：</p><ul><li>HLSLINCLUDE：可写在任意区域，区域下的所有 Pass 将自动包含块中的代码。</li><li>HLSLPROGRAM：写在 Pass 区域中，是当前 Pass 使用的 Shader 代码。</li><li>CGINCLUDE（仅内置管线）</li><li>CGPROGRAM（仅内置管线）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// 语法示例<br>Shader &quot;Examples/ExampleShader&quot;<br>&#123;<br>  SubShader&#123;<br><br>    HLSLINCLUDE<br>      // 当前区域内所有Pass的共享 HLSL 代码<br>    ENDHLSL<br><br>    Pass&#123;<br><br>      HLSLPROGRAM<br>        // 当前Pass的 HLSL 代码<br>      ENDHLSL<br><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="HLSL-语法"><a href="#HLSL-语法" class="headerlink" title="HLSL 语法"></a>HLSL 语法</h3><p>代码块中使用正常的 HLSL 编写着色器代码，对于常规的 HLSL 语法可见微软的 <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl">HLSL 文档</a></p><p>Unity 支持两种版本的 HLSL 语法，DirectX 9 样式和 DirectX 10+ 样式，两者主要在纹理采样有所区别，同时平台兼容性也不一样。</p><ul><li>DX 9：使用 <code>sampler2D</code>、<code>tex2D()</code> 采样纹理。全平台兼容。</li><li>DX 10+：使用 <code>Texture2D</code>、<code>SamplerState</code>、<code>.Sample()</code> 采样纹理。部分语法在 OpenGL 平台无效。</li></ul><p>部分操作也可选择使用 Unity 提供宏函数编写，从而解决兼容性差异。</p><h3 id="GLSL-语法"><a href="#GLSL-语法" class="headerlink" title="GLSL 语法"></a>GLSL 语法</h3><p><a href="https://docs.unity.cn/cn/2022.3/Manual/SL-GLSLShaderPrograms.html">https://docs.unity.cn/cn/2022.3/Manual/SL-GLSLShaderPrograms.html</a></p><p>除了 HLSL，Unity 还支持使用 GLSL 编写着色器，相应的 GLSL 代码必须使用相应的<code>GLSLPROGRAM</code>代码块，但这种方式并不提倡。</p><h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><ul><li><code>#include &quot;&lt;file&gt;&quot;</code></li></ul><p>插入其他文件（如 <code>.hlsl</code> 文件）内容。注意其不会插入内容中的<code>#pragma</code>指令。</p><h3 id="include-with-pragmas"><a href="#include-with-pragmas" class="headerlink" title="include_with_pragmas"></a>include_with_pragmas</h3><ul><li><code>#include_with_pragmas &quot;&lt;file&gt;&quot;</code></li></ul><p>插入其他文件内容，并且包含其中的<code>#pragma</code>指令。</p><p>使用该指令必须确保启用了编辑器中的缓存预处理器功能（2020.2.0a13 版开始默认启用）</p><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><ul><li><code>#define &lt;key&gt; &lt;value&gt;</code></li><li><code>#undef &lt;key&gt;</code></li></ul><p>定义或取消定义关键字，用于实现宏函数或编译时常量。</p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>配合关键字定义实现编译时分支功能。注意其无法控制内容中的<code>#pragma</code>指令。</p><ul><li><p>根据关键字是否被定义来分支。</p><ul><li><code>#ifdef &lt;key&gt;</code></li><li><code>#ifndef &lt;key&gt;</code></li></ul></li><li><p>根据关键字的值来分支</p><ul><li><code>#if &lt;key&gt;</code></li><li><code>#elif &lt;key&gt;</code></li></ul></li><li><p><code>#else</code></p></li><li><p><code>#endif</code></p></li></ul><h3 id="pragma"><a href="#pragma" class="headerlink" title="pragma"></a>pragma</h3><p>为着色器编译器提供其他类型的预处理器指令未涵盖的其他信息。</p><p>部分参数可多填，用空格分割。</p><h4 id="常用编码指令"><a href="#常用编码指令" class="headerlink" title="常用编码指令"></a>常用编码指令</h4><ul><li><p>声明表面着色器选项。</p><ul><li><code>#pragma surface &lt;surface function&gt; &lt;lighting model&gt; &lt;optional parameters&gt;</code></li></ul></li><li><p>声明着色器阶段函数。</p><ul><li><code>#pragma vertex &lt;name&gt;</code></li><li><code>#pragma fragment &lt;name&gt;</code></li><li><code>#pragma geometry &lt;name&gt;</code></li><li><code>#pragma hull &lt;name&gt;</code></li><li><code>#pragma domain &lt;name&gt;</code></li></ul></li><li><p>声明着色器变体和关键字。</p><p><a href="https://docs.unity.cn/2022.3/Documentation/Manual/SL-MultipleProgramVariants.html">https://docs.unity.cn/2022.3/Documentation/Manual/SL-MultipleProgramVariants.html</a></p><ul><li><code>#pragma multi_compile &lt;keywords&gt;</code>：声明着色器变体。相关变体将全部编译。</li><li><code>#pragma multi_compile_local &lt;keywords&gt;</code>：同上但改为使用本地关键字控制。</li><li><code>#pragma shader_feature &lt;keywords&gt;</code>：声明着色器变体。仅使用变体将编译。</li><li><code>#pragma shader_feature_local &lt;keywords&gt;</code>：同上但改为使用本地关键字控制。</li><li><code>#pragma hardware_tier_variants &lt;values&gt;</code>：在编译给定图形 API 时为图形层（内置管线功能）添加关键字。</li><li><code>#pragma skip_variants &lt;keywords&gt;</code>：删除指定的关键字。</li></ul></li><li><p>限定当前文件仅包含一次。</p><ul><li><code>#pragma once</code></li></ul></li></ul><h4 id="特殊功能开关"><a href="#特殊功能开关" class="headerlink" title="特殊功能开关"></a>特殊功能开关</h4><ul><li><p>声明着色器模型和所需 GPU 功能。</p><p><a href="https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderCompileTargets.html">https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderCompileTargets.html</a></p><p>部分功能不能满足跨平台的需求所以默认被隐藏，如有需要必须用下列指令显式声明。</p><ul><li><code>#pragma target &lt;model&gt;</code>：声明最小着色器模型。</li><li><code>#pragma require &lt;feature&gt;</code>：声明兼容的最低 GPU 功能。</li></ul></li><li><p>启用并设置 GPU 实例化功能。</p><ul><li><code>#pragma instancing_options &lt;options&gt;</code></li></ul></li><li><p>启用涉及 NaN 处理的精确 IEEE 754 规则。 当前这仅影响 Metal 平台。</p><ul><li><code>#pragma disable_fastmath</code></li></ul></li></ul><h4 id="编译阶段控制"><a href="#编译阶段控制" class="headerlink" title="编译阶段控制"></a>编译阶段控制</h4><ul><li><p>包含或排除给定图形 API 的代码。</p><p><a href="https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderCompilationAPIs.html">https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderCompilationAPIs.html</a></p><p>Unity 默认会为当前构建目标列表中所有的平台编译着色器，但实际有些平台可能不支持或不需要某些着色器程序，可借此排除。</p><ul><li><code>#pragma only_renderers &lt;api&gt;</code>：仅针对给定图形 API 编译程序。</li><li><code>#pragma exclude_renderers &lt;api&gt;</code>：不要为给定图形 API 编译程序。</li></ul></li><li><p>为目标 API 生成调试符号并禁用所有 API 优化。</p><ul><li><code>#pragma enable_&lt;api&gt;_debug_symbols</code></li></ul></li><li><p>关闭目标图形 API 的优化。</p><ul><li><code>#pragma skip_optimizations &lt;api&gt;</code>：可多写，用空格分割。</li></ul></li><li><p>将反汇编的 HLSLcc 字节码嵌入到转换的着色器中。</p><ul><li><code>#pragma hlslcc_bytecode_disassembly</code></li></ul></li><li><p>强制进行同步着色器编译。</p><ul><li><code>#pragma editor_sync_compilation</code></li></ul></li><li><p>使用 CBUFFER 宏时，即使目标平台不支持，也要写入相关代码。</p><ul><li><code>#pragma enable_cbuffer</code></li></ul></li></ul><h2 id="着色器语义"><a href="#着色器语义" class="headerlink" title="着色器语义"></a>着色器语义</h2><p>编写 HLSL 着色器程序时，输入和输出变量必须要通过语义来表明其“意图”，从而正确接收或传递渲染管线中的数据。</p><p>以下介绍一些 Unity 支持的常用语义，其他更特殊的语义需自行查看 HLSL 文档并检查是否可用。</p><h3 id="顶点着色器输入阶段"><a href="#顶点着色器输入阶段" class="headerlink" title="顶点着色器输入阶段"></a>顶点着色器输入阶段</h3><p>顶点阶段中的大多语义与用户定义的网格数据布局有关，此处以 Unity 默认的布局结构为准。</p><ul><li><code>POSITION</code>：顶点位置，通常为<code>float3</code>。</li><li><code>NORMAL</code>：顶点法线，通常为<code>float3</code>。</li><li><code>TEXCOORD0</code>、<code>TEXCOORD1</code>、<code>TEXCOORD2</code>、<code>TEXCOORD3</code>：顶点 uv，通常为<code>float2</code>。</li><li><code>TANGENT</code>：顶点切线，通常为<code>float4</code>。</li><li><code>COLOR</code>：顶点颜色，通常为<code>float4</code>。</li></ul><p>当声明的变量的分量多余实际的输入变量时，多余部分按默认值填充，默认值为<code>(0,0,0,1)</code>。</p><h3 id="顶点着色器输出及片元着色器输入阶段"><a href="#顶点着色器输出及片元着色器输入阶段" class="headerlink" title="顶点着色器输出及片元着色器输入阶段"></a>顶点着色器输出及片元着色器输入阶段</h3><ul><li><code>SV_POSITION</code>：顶点的裁剪空间位置，必须为<code>float4</code>。</li><li><code>其他非特殊语义</code>：用于标识从顶点传递到片元的自定义数据。</li></ul><h4 id="语义限制"><a href="#语义限制" class="headerlink" title="语义限制"></a>语义限制</h4><p>在渲染管线中传递的数据必须用语义标记，但大多数现代 GPU 其实并不关心语义是什么，所以当要传递自定义数据时随意搭配一些不冲突的语义即可。</p><p>但在一些老旧的系统在，比如着色器模型 2，会有一些特殊语义规则：</p><ul><li><code>TEXCOORD0</code>、<code>TEXCOORD1</code>：代表任意高精度数据，如纹理坐标、位置。</li><li><code>COLOR0</code>、<code>COLOR1</code>：任意 0-1 的低精度数据，如简单的颜色。</li></ul><p>因此为了最佳的跨平台支持，应尽可能使用类似<code>TEXCOORD&lt;num&gt;</code>这样的语义传递自定义数据。</p><h4 id="插值器限制"><a href="#插值器限制" class="headerlink" title="插值器限制"></a>插值器限制</h4><p>顶点着色器输出同时也可以作为片元着色器的输入，因为光栅化会自动将顶点数据通过插值器插值成像素数据。</p><p>但插值器也存在一些数量限制：</p><ul><li>最多 8 个：OpenGL ES 2.0(Android)、Direct3D 11 9.x level(Windows Phone)。</li><li>最多 10 个：着色器模型 3.0。</li><li>最多 16 个：OpenGL ES 3.0(Android)、Metal(iOS)。</li><li>最多 32 个：着色器模型 4.0。</li></ul><p>如果插值器数量不够用，可以考虑共用插值器，比如因为插值器是支持 4 位浮点数的，所以可以将两个 2 位浮点数放在一起传递。</p><p>此外从性能的角度考虑，通常也都应该尽可能减少插值器的使用数量。</p><h3 id="片元着色器输出阶段"><a href="#片元着色器输出阶段" class="headerlink" title="片元着色器输出阶段"></a>片元着色器输出阶段</h3><ul><li><code>SV_Target</code>：片元着色器输出的颜色，必须为任意精度的 4 分量浮点向量。</li><li><code>SV_Target&lt;number&gt;</code>：当使用“多渲染目标”渲染技术时的输出颜色，如 SV_TARGET4。</li><li><code>SV_Depth</code>：自定义深度输出，必须为 float 类型。非必要不要使用，这会产生和 alpha 测试（使用<code>clip()</code>）类似的性能成本。</li></ul><h3 id="其他特殊语义"><a href="#其他特殊语义" class="headerlink" title="其他特殊语义"></a>其他特殊语义</h3><p>这类语义可以提供一些额外的特殊信息，一般用来实现一些特殊效果。</p><h4 id="顶点着色器输入"><a href="#顶点着色器输入" class="headerlink" title="顶点着色器输入"></a>顶点着色器输入</h4><ul><li><code>SV_VertexID</code>：顶点在网格中的编号，为无符号整数。需要着色器模型 3.5 支持。</li></ul><h4 id="片元着色器输入"><a href="#片元着色器输入" class="headerlink" title="片元着色器输入"></a>片元着色器输入</h4><ul><li><code>VPOS</code>：屏幕空间像素位置，通常为<code>float4</code>但考虑兼容性应使用<code>UNITY_VPOS_TYPE</code>作为变量类型。需要着色器模型 3.0 支持。</li><li><code>VFACE</code>：表面是否正向摄像机，返回 0 或 1 的值。需要着色器模型 3.0 支持。</li></ul><h2 id="着色器属性"><a href="#着色器属性" class="headerlink" title="着色器属性"></a>着色器属性</h2><p>可以直接在代码块中定义变量，接着只需提供这些变量的名称和类型信息，就可以通过多种外部途径读写这些值，从而使着色器程序参数化。</p><h3 id="提供着色器属性值"><a href="#提供着色器属性值" class="headerlink" title="提供着色器属性值"></a>提供着色器属性值</h3><p>有以下方式可以向着色器程序提供着色器属性值，使用时需确保与代码块中的变量名一致且类型匹配。</p><ol><li>MaterialPropertyBlock 中设置的每渲染器值。</li><li>渲染对象所用材质球上的值，包括直接用代码传入的运行时值或<code>Properties</code>块中定义的序列化值。</li><li>全局着色器属性值。</li><li>该变量类型的默认值。</li></ol><p>当同时使用多种途径提供属性值时，将按上述顺序作为优先级进行调用。</p><h3 id="特殊的着色器属性值"><a href="#特殊的着色器属性值" class="headerlink" title="特殊的着色器属性值"></a>特殊的着色器属性值</h3><p>一些着色器属性在传入时还会附带一些额外数据，可通过定义符合这些额外属性命名和类型规范的变量来接收。</p><ul><li><code>float4 &lt;textureVarName&gt;_ST</code>：纹理属性额外的平铺和偏移信息。内容如下<code>(x平铺值,y平铺值,x偏移值,y偏移值)</code>。</li><li><code>float4 &lt;textureVarName&gt;_TexelSize</code>：纹理属性额外的大小信息，内容如下<code>(1.0/宽度,1.0/高度,宽度,高度)</code>。</li><li><code>float4 &lt;textureVarName&gt;_HDR</code>：纹理属性额外的 HDR 参数信息，指明如何在当前颜色空间下解码可能的 HDR 纹理，详见 UnityCG.cginc 中 DecodeHDR 函数。</li></ul><h3 id="颜色空间下的数据转换"><a href="#颜色空间下的数据转换" class="headerlink" title="颜色空间下的数据转换"></a>颜色空间下的数据转换</h3><p>通常情况下纹理颜色等信息都是基于 sRGB 空间存储的，其会更多的存储暗色部分的颜色，这也更符合人眼的认知特征。但现实的物理计算都是基于线性空间的，因此为了更真实的渲染效果，通常都需要进行转换。</p><p>幸运的是，当 Unity 的渲染设置为线性空间时，Unity 会自动将 sRGB 空间的输入转换为线性空间，确保在着色器程序中直接拿到手的就是线性值。这主要是针对以下类型起作用：</p><ul><li>纹理属性</li><li>颜色属性</li></ul><p>其他属性如浮点数、向量则不会转换，除非是显式的在属性块中添加了<code>[Gamma]</code>特性标签。</p><h2 id="内置着色器成员"><a href="#内置着色器成员" class="headerlink" title="内置着色器成员"></a>内置着色器成员</h2><p>Unity 提供一些必要和常用的内置成员以便获取着色器环境、渲染数据等。</p><p>但要注意的是，不同渲染管线中提供的内置成员并不完全兼容，实际使用时还要具体看文档。</p><h3 id="内置头文件"><a href="#内置头文件" class="headerlink" title="内置头文件"></a>内置头文件</h3><p><a href="https://docs.unity.cn/cn/2022.3/Manual/SL-BuiltinIncludes.html">https://docs.unity.cn/cn/2022.3/Manual/SL-BuiltinIncludes.html</a></p><p>所有内置成员都是通过头文件引入的，不同的功能会用到不同的头文件，如果是使用<code>GCPROGRAM</code>代码块，Unity 还会自动引入一些常用头文件。</p><p>不过可惜这仅是内置渲染管线所用的头文件，如果是其他 SRP，则需要选择引入不同的头文件。</p><h3 id="内置宏"><a href="#内置宏" class="headerlink" title="内置宏"></a>内置宏</h3><p><a href="https://docs.unity.cn/cn/2022.3/Manual/SL-BuiltinMacros.html">https://docs.unity.cn/cn/2022.3/Manual/SL-BuiltinMacros.html</a></p><p>Unity 内置了一些平台宏或宏函数，以在编译阶段帮助处理平台差异。</p><ul><li>当前编译的平台</li><li>当前编译的着色器模型</li><li>当前编译的 Unity 版本</li><li>当前编译的着色器阶段</li><li>当前平台的支持功能</li><li>当前平台的阴影贴图处理</li><li>当前平台的常量缓冲区处理</li><li>当前平台的纹理采样器处理</li><li>当前平台的深度纹理处理</li><li>禁用自动升级着色器代码</li><li>当前编译的表面着色器的通道</li></ul><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p><a href="https://docs.unity.cn/cn/2022.3/Manual/SL-BuiltinMacros.html">https://docs.unity.cn/cn/2022.3/Manual/SL-BuiltinMacros.html</a></p><p>一些常用的函数，实现空间变换、光照阴影等功能，可惜内置渲染管线和 SRP 中所用的函数并不相通。</p><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><p><a href="https://docs.unity.cn/cn/2022.3/Manual/SL-UnityShaderVariables.html">https://docs.unity.cn/cn/2022.3/Manual/SL-UnityShaderVariables.html</a></p><p>内置变量是外部传入的渲染计算所需的参数，通常应通过内置函数访问而不是直接使用。</p><ul><li>空间变换矩阵</li><li>相机与屏幕信息</li><li>时间</li><li>光照（光源信息、光照贴图、雾效和环境光）</li><li>其他（LODGroup 等级、UI 纹理格式）</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul><li><code>float</code>：32 位高精度浮点数。</li><li><code>half</code>：16 位半精度浮点数。</li><li><code>fixed</code>：11 位低精度浮点数。过时类型，仅 OpenGL ES 2.0 支持。</li></ul><p>在高端平台（如 PC）的 GPU 中始终使用高精度，仅当面向移动 GPU 时精度选择才会起效。</p><p>更低精度的浮点数通常性能更高，虽然随着硬件发展，性能优势可能逐步减弱，但依然会更加节省功耗。所以只要精度够用应优先使用低精度，然后按需提高。</p><h4 id="浮点数后缀"><a href="#浮点数后缀" class="headerlink" title="浮点数后缀"></a>浮点数后缀</h4><p>HLSL 原生语法中支持浮点数后缀，但<strong>Unity 不支持</strong>，所有带后缀的浮点数都将被识别为 float 类型，这可能导致计算精度提高而<strong>造成负面的性能影响</strong>。</p><h4 id="特殊浮点数"><a href="#特殊浮点数" class="headerlink" title="特殊浮点数"></a>特殊浮点数</h4><p>对于如无穷大、非数值等特殊浮点数，不同 GPU 间处理方式可能不同。</p><p>所有支持 Direct3D10 的电脑 GPU 都支持 IEEE754 浮点标准，所以处理浮点数的行为和常规 CPU 编程语言一致。</p><p>移动 GPU 的支持级别则可能不同，所以<strong>必须确保在目标设备上测试着色器以检查支持情况</strong>。</p><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ul><li><code>int</code></li></ul><p>在一些老式平台上（如 OpenGL ES 2.0）不支持，甚至需要用复杂的浮点运算去模拟一些位、逻辑运算。</p><h3 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hlsl">&lt;type&gt;&lt;number&gt;<br></code></pre></td></tr></table></figure><ul><li>type：任意整数或浮点数类型。</li><li>number：任意整数。</li></ul><p>如 <code>float2</code>、<code>int3</code>。</p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hlsl">&lt;type&gt;&lt;number&gt;x&lt;number&gt;<br></code></pre></td></tr></table></figure><ul><li>type：任意整数或浮点数类型。</li><li>number：任意整数。</li></ul><p>如 <code>int2x3</code>、<code>float4x4</code>。</p><p>在一些老式平台（如 OpenGL ES 2.0）仅支持方形矩阵。</p><h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hlsl">sampler&lt;type&gt;[_&lt;precision&gt;]<br></code></pre></td></tr></table></figure><ul><li><p>type：任意纹理类型</p><ul><li>2D：常用的平面纹理。</li><li>3D</li><li>CUBE</li></ul></li><li><p>precision：任意精度类型</p><ul><li>half</li><li>float</li></ul></li></ul><p>如 <code>sampler2D</code>、<code>samplerCUBE_float</code>。</p><h4 id="精度后缀"><a href="#精度后缀" class="headerlink" title="精度后缀"></a>精度后缀</h4><p>纹理支持可选的后缀来描述精度，但实际上如果不写明后缀，最终也会由 Unity 根据“着色器精度”设置自动添加后缀。</p><p>在移动平台，纹理精度后缀默认为 <code>half</code>。</p><h4 id="采样器状态"><a href="#采样器状态" class="headerlink" title="采样器状态"></a>采样器状态</h4><p><a href="https://docs.unity.cn/cn/2022.3/Manual/SL-SamplerStates.html">https://docs.unity.cn/cn/2022.3/Manual/SL-SamplerStates.html</a></p><p>在许多较新的 API 中，采样器和纹理可以分开定义，并支持在着色器中直接声明采样模式。</p>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
      <category>着色器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】着色器变体笔记</title>
    <link href="/posts/3863423297.html"/>
    <url>/posts/3863423297.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】着色器变体笔记"><a href="#【Unity】着色器变体笔记" class="headerlink" title="【Unity】着色器变体笔记"></a>【Unity】着色器变体笔记</h1><p><a href="https://docs.unity.cn/2022.3/Documentation/Manual/shader-variants-and-keywords.html">https://docs.unity.cn/2022.3/Documentation/Manual/shader-variants-and-keywords.html</a></p><p>着色器变体可以看成是一种增强版的静态分支功能，同时具备了静态、动态两种分支的优点，是一种非常实用的实现着色器分支的方式。</p><p>具有大量着色器变体的着色器被称作“超级着色器”，Unity 的标准着色器就是其中之一。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>优点：允许和动态分支一样运行时切换分支，且和静态分支一样不会影响 GPU 性能。</li><li>缺点：大量变体可能导致生成时间、文件大小、内存使用和加载时间增加，预热着色器也更复杂。</li></ul><p>总结而言即“空间换时间”。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="基本使用流程"><a href="#基本使用流程" class="headerlink" title="基本使用流程"></a>基本使用流程</h3><ol><li>首先利用变体的宏指令定义一些着色器关键字，可将其作为正常的静态分支条件使用。</li><li>Unity 会识别这些关键字，并以此的各种组合情况编译成多个小型专用着色器程序。</li><li>在运行期间可以开关这些着色器关键词，Unity 将使用与其条件匹配的着色器程序。</li></ol><h3 id="变体编译流程"><a href="#变体编译流程" class="headerlink" title="变体编译流程"></a>变体编译流程</h3><p>可以通过以下方式确定会产生的变体数量。</p><ol><li>确定图形 API 数量：每一个图形 API 都需要单独编译所有的着色器。</li><li>确定着色器程序数量：每一个着色器阶段，如一个顶点阶段或片段阶段，都要单独编译变体。</li><li>影响着色器程序的关键字：当前使用的关键字组合，每一种组合都将产生一个变体，即使着色器代码中未使用。</li><li>重复数据删除：变体编译完成后，Unity 会识别相同的变体，并使它们共用字节码。</li></ol><h4 id="关于重复数据删除"><a href="#关于重复数据删除" class="headerlink" title="关于重复数据删除"></a>关于重复数据删除</h4><p>如定义了一组关键字，虽然仅在顶点阶段使用，但默认情况下片段阶段依旧会因此编译出多个变体。但由于片段阶段实际没有使用这些变体，所以实际是相同的字节码，于是 Unity 就会对其合并。</p><p>重复数据删除可减少文件大小，但依旧没法避免编译时间和运行时内存使用、加载时间的浪费。所以有条件还是要尽可能去掉不必要的变体，比如通过显式声明相关关键字仅指定着色器阶段编译。</p><h3 id="变体匹配流程"><a href="#变体匹配流程" class="headerlink" title="变体匹配流程"></a>变体匹配流程</h3><ol><li>优先提供与关键字组合完全匹配的变体。</li><li>其次提供与关键字组合中交集关键字最多的变体。</li><li>若交集数量一样则提供关键字组合列表中最前面的变体。</li><li>如果完全不匹配则提供每个关键字声明中首个关键字的组合对应的变体。</li></ol><h2 id="变体关键字"><a href="#变体关键字" class="headerlink" title="变体关键字"></a>变体关键字</h2><h3 id="声明关键字"><a href="#声明关键字" class="headerlink" title="声明关键字"></a>声明关键字</h3><p><a href="https://docs.unity.cn/2022.3/Documentation/Manual/SL-MultipleProgramVariants.html">https://docs.unity.cn/2022.3/Documentation/Manual/SL-MultipleProgramVariants.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">pragma &lt;编译方式&gt;[_local][着色器阶段] [_] &lt;关键字&gt; ...<br></code></pre></td></tr></table></figure><p>如：<code>#pragma shader_feature_local_vertex A B C</code>（一个仅材质球范围且开发期间可确定的顶点阶段变体 A、B、C）</p><ol><li><p>确定编译方式</p><ul><li><code>multi_compile</code>：永远编译所有关键字的着色器变体。</li><li><code>shader_feature</code>：仅编译正在使用的关键字（一起构建的材料中启用了该关键字）的变体。</li><li><code>dynamic_branch</code>：使用动态分支而非变体，关键字将被替换为统一的布尔值。</li></ul><p>如果启用的关键字在项目开发期间就可确定，且不会在运行时修改，则应使用<code>shader_feature</code>来减少变体数量。否则应使用<code>multi_compile</code>来避免变体被错误剥离。</p></li><li><p>确定使用范围</p><ul><li><code>_local</code>：表明相关关键字为本地关键字。</li></ul><p>默认情况下，关键字是全局的。全局意味相关关键字的开关都统一受一个全局静态开关影响。如果希望能单独给每个材质设置不同的关键字开关，那这些关键字应声明为本地。</p></li><li><p>限制着色器阶段</p><ul><li><code>_vertex</code>：顶点着色器阶段。</li><li><code>_fragment</code>：片段着色器阶段。</li><li><code>_hull</code>：壳着色器阶段。</li><li><code>_domain</code>：域着色器阶段。</li><li><code>_geometry</code>：几何着色器阶段。</li><li><code>_raytracing</code>：光线追踪着色器阶段。</li></ul><p>Unity 默认对所有阶段都进行相关关键字的变体编译，但如果某些阶段实际没有使用该关键字就会导致 Unity 编译多余的无效变体。而显式声明着色器阶段可以避免这一点，从而帮助 Unity 优化编译时间和剥离无效变体。</p></li><li><p>限制着色器模型和 GPU 功能</p><p><a href="https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderCompileTargets.html">https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderCompileTargets.html</a></p><p>除了直接使用<code>#pragma</code>，还可以使用<code>#pragma require</code>和<code>#pragma target</code>声明关键字，从而限制仅在部分着色器模型或 GPU 功能下编译相关关键字，从而起到类似限制着色器阶段一样的优化效果。</p></li><li><p>创建支持禁用关键字的变体</p><ul><li><code>_</code>：下划线是一种特殊的变体名称，用于表示不启用关键字状态。</li></ul><p>若相关关键字支持全部不启用的情况，那应当通过声明<code>_</code>关键字表明这一点，这样 Unity 才会编译不包含相关关键字情况的变体。如果是创建单个关键字时，Unity 还会隐含自动添加<code>_</code>关键字。</p></li></ol><p>其他一些关键字声明指令：</p><ol><li><p>使用快捷方式创建关键字</p><p>Unity 内置一组宏参数可以方便快速创建 Unity 内置的关键字，具体见文档。</p></li><li><p>删除关键字声明。</p><p>利用<code>#pragma skip_variants &lt;关键字&gt; ...</code>宏指令可以移除指定的关键字声明。</p></li></ol><h3 id="声明关键字分支"><a href="#声明关键字分支" class="headerlink" title="声明关键字分支"></a>声明关键字分支</h3><p>将关键字用于实际的代码中构建分支有两种方式：</p><ul><li><del><code>if(&lt;关键字&gt;)</code>：使用运行时 if 函数创建分支。</del>（实测无法使用）</li><li><code>#if &lt;关键字&gt;</code>：使用宏函数 if 创建分支。</li></ul><h3 id="启用或禁用关键字"><a href="#启用或禁用关键字" class="headerlink" title="启用或禁用关键字"></a>启用或禁用关键字</h3><h4 id="通过脚本控制"><a href="#通过脚本控制" class="headerlink" title="通过脚本控制"></a>通过脚本控制</h4><ul><li>全局关键字通过“静态函数”或”命令缓冲区对象函数”控制：<ul><li><code>Shader.EnableKeyword</code>：启用关键字。</li><li><code>Shader.DisableKeyword</code>：禁用关键字。</li></ul></li><li>本地关键字通过“材质对象函数”或“计算着色器对象函数”控制：<ul><li><code>Material.EnableKeyword</code>：启用关键字。</li><li><code>Material.DisableKeyword</code>：禁用关键字。</li></ul></li></ul><p>从 Unity2021 开始，还新增了<code>Shader.keywordSpace</code>等更高级的关键字 API，具体见文档。</p><p><a href="https://docs.unity.cn/2021.3/Documentation/Manual/shader-keywords-scripts.html">https://docs.unity.cn/2021.3/Documentation/Manual/shader-keywords-scripts.html</a></p><h4 id="通过检视面板控制"><a href="#通过检视面板控制" class="headerlink" title="通过检视面板控制"></a>通过检视面板控制</h4><p>通过检视面板只能控制材质中的本地关键字，具体有两种方法：</p><ol><li>通过 Debug 模式直接查看或编辑材质上的 Shader Keywords 属性。</li><li>通过自定义 GUI 或内置标签（如<code>[Toggle]</code>）从而自动根据属性值设置关键字。</li></ol><h3 id="关键字限制"><a href="#关键字限制" class="headerlink" title="关键字限制"></a>关键字限制</h3><p>所有着色器最多可以使用 4,294,967,294 个全局关键字。每个着色器最多可以使用 65,534 个本地关键字。</p><p>此外当着色器总共使用了 128 个以上的关键字时，会产生少量的运行时性能损失，所以要尽可能将关键字数量保持在低水平。</p><h2 id="变体剥离与包含"><a href="#变体剥离与包含" class="headerlink" title="变体剥离与包含"></a>变体剥离与包含</h2><h3 id="减少变体数量"><a href="#减少变体数量" class="headerlink" title="减少变体数量"></a>减少变体数量</h3><p>由于关键词采用组合的方式定义变体，所以变体数量会随着关键词数量急剧上升，导致大幅增加文件大小、构建时间、加载时间、内存占用等性能问题。因此减少变体，确保剥离不需要的变体是非常重要的。</p><h4 id="在关键字声明阶段剥离变体"><a href="#在关键字声明阶段剥离变体" class="headerlink" title="在关键字声明阶段剥离变体"></a>在关键字声明阶段剥离变体</h4><ul><li>尽可能使用<code>shader_feature</code>而不是<code>multi_compile</code>声明变体。</li><li>确保没有用<code>multi_compile</code>定义未使用的着色器关键字。</li><li>显式指定关键字适用的着色器阶段或着色器模型、功能。</li></ul><h4 id="使用预处理宏按平台剥离变体"><a href="#使用预处理宏按平台剥离变体" class="headerlink" title="使用预处理宏按平台剥离变体"></a>使用预处理宏按平台剥离变体</h4><p>不同的平台所需的着色器变体可能不同，可借此去除那些在部分平台用不到的变体。</p><p><a href="https://docs.unity.cn/2022.3/Documentation/Manual/SL-BuiltinMacros.html">https://docs.unity.cn/2022.3/Documentation/Manual/SL-BuiltinMacros.html</a></p><h4 id="通过控制用户的质量设置剥离变体"><a href="#通过控制用户的质量设置剥离变体" class="headerlink" title="通过控制用户的质量设置剥离变体"></a>通过控制用户的质量设置剥离变体</h4><p>不同平台的用户可调节的质量设置可能不同，可借此简化一些平台的关键字声明。</p><h4 id="通过编辑器设置剥离变体"><a href="#通过编辑器设置剥离变体" class="headerlink" title="通过编辑器设置剥离变体"></a>通过编辑器设置剥离变体</h4><ul><li>通过 Graphics 项目设置的 Shader Stripping 选项剥离不必要的内置变体。</li><li>确保没有将无需要的 Shader 放入 Always-included shaders 选项中（这里的 Shader 将永远编译所有变体）。</li><li>如果部分渲染管线功能并未使用，应将其关闭，以便 Unity 剥离相关变体。</li></ul><h4 id="通过编辑器脚本剥离变体"><a href="#通过编辑器脚本剥离变体" class="headerlink" title="通过编辑器脚本剥离变体"></a>通过编辑器脚本剥离变体</h4><p>可用通过自定义着色器处理回调<code>IPreprocessShaders.OnProcessShader</code>等，在程序中人为控制变体剥离。</p><h3 id="避免变体剥离"><a href="#避免变体剥离" class="headerlink" title="避免变体剥离"></a>避免变体剥离</h3><p>虽然剥离变体有助于优化游戏，但若错误剥离了需要的变体就会导致显示异常，所以有时也需要想办法保护变体不被剥离。</p><ul><li>使用<code>multi_compile</code>而不是<code>shader_feature</code>，从而保证相关变体在运行时也始终存在。</li><li>使用<code>shader_feature</code>创建变体应确保 Shader 和“材质”或“变体集合”一起打包，从而使 Unity 能正确判断变体使用状况。</li><li>将 Shader 放入到“Always-included shaders”设置中，从而使 Unity 永远编译该 Shader 的所有变体。</li></ul>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
      <category>着色器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】着色器核心概念笔记</title>
    <link href="/posts/2077063050.html"/>
    <url>/posts/2077063050.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】着色器核心概念笔记"><a href="#【Unity】着色器核心概念笔记" class="headerlink" title="【Unity】着色器核心概念笔记"></a>【Unity】着色器核心概念笔记</h1><p><a href="https://docs.unity.cn/2022.3/Documentation/Manual/ShadersOverview.html">https://docs.unity.cn/2022.3/Documentation/Manual/ShadersOverview.html</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>着色器就是 GPU 上运行的程序。</p><h3 id="着色器类型"><a href="#着色器类型" class="headerlink" title="着色器类型"></a>着色器类型</h3><p>Unity 支持三种着色器。</p><ul><li>渲染管线着色器（主要着色器）</li><li>计算着色器</li><li>光线追踪着色器</li></ul><h3 id="着色器组成"><a href="#着色器组成" class="headerlink" title="着色器组成"></a>着色器组成</h3><ul><li>着色器信息：如着色器名称、回退着色器等着色器自身的信息。</li><li>子着色器：子着色器用于将着色器对象分成多个部分，以分别兼容不同的硬件、渲染管线和运行时设置。<ul><li>兼容性说明：指明运行该子着色器所需的硬件、渲染管线和运行时设置，例如 LOD。</li><li>子着色器标签：提供子着色器相关信息的键值对。</li><li>通道：一个通道对应一次实际的 GPU 渲染。<ul><li>通道标签：提供通道相关信息的键值对。</li><li>渲染状态说明：指明执行该通道依赖的渲染状态设置。</li><li>着色器程序：实际的着色器代码，每一个着色器阶段代表一个着色器程序。<ul><li>着色器变体：一个着色器程序可能有一个或多个变体版本。</li></ul></li></ul></li></ul></li></ul><h3 id="着色器模型"><a href="#着色器模型" class="headerlink" title="着色器模型"></a>着色器模型</h3><p>因为着色器也是慢慢发展过来的，所以也有新旧版本之分，而着色器模型其实就是着色器版本的花俏说法。</p><p>一些新模型支持的功能在旧模型中可能不支持，所以开发时要考虑好着色器模型的兼容性，默认情况下 Unity 使用着色器模型 2.5。</p><p><a href="https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderCompileTargets.html">https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderCompileTargets.html</a></p><h3 id="着色器平台"><a href="#着色器平台" class="headerlink" title="着色器平台"></a>着色器平台</h3><p>着色器平台一般指的就是 GPU 驱动。不同操作系统平台通常采用不同的 GPU 驱动，而不同 GPU 驱动间所需的着色器字节码是不一样的，所以每个平台都要单独编译着色器。</p><p>此外不同平台支持的功能、功能实现细节都可能有所区别，因此开发时必须要考虑好平台兼容性。</p><p><a href="https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderCompilationAPIs.html">https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderCompilationAPIs.html</a></p><h2 id="着色器编译"><a href="#着色器编译" class="headerlink" title="着色器编译"></a>着色器编译</h2><p>基本流程：</p><ol><li>对着色器源代码进行预处理，如生成代码，处理宏指令等。</li><li>使用 Microsoft 的 FXC HLSL 编译器将代码编译为 HLSL 字节码。</li><li>按需使用 HLSLcc 将 HLSL 字节码转换成其他平台的字节码。</li></ol><h3 id="编辑器编译策略"><a href="#编辑器编译策略" class="headerlink" title="编辑器编译策略"></a>编辑器编译策略</h3><ol><li>检查当前需要的着色器变体是否存在缓存中。（存储位置：Library&#x2F;ShaderCache）</li><li>找到则直接显示，否则编译该变体并保存到缓存中。</li></ol><p>如果启用了异步着色器编译则编译时会临时显示占位符着色器（显示为纯青色）。</p><h3 id="构建时编译策略"><a href="#构建时编译策略" class="headerlink" title="构建时编译策略"></a>构建时编译策略</h3><ol><li>给每个所需的图形 API 编译所有的着色器变体，即使编辑器中并未使用。</li><li>尝试检测游戏中尚未使用（需要显式声明）或重复的着色器变体，并将其从构建数据中剥离或合并。</li></ol><h2 id="着色器加载"><a href="#着色器加载" class="headerlink" title="着色器加载"></a>着色器加载</h2><h3 id="着色器加载流程"><a href="#着色器加载流程" class="headerlink" title="着色器加载流程"></a>着色器加载流程</h3><h4 id="如何加载着色器？"><a href="#如何加载着色器？" class="headerlink" title="如何加载着色器？"></a>如何加载着色器？</h4><ol><li>在构建的软件中，着色器变体被压缩成多个块存放在磁盘中。</li><li>当加载场景或资源时，Unity 会加载并解压相关的所有变体块到内存中。</li><li>当首次需要变体来渲染几何体时，Unity 会选取一个合适的变体并将其传递给图形驱动。</li><li>图形驱动会创建该变体的 GPU 版本，并上传到 GPU。</li></ol><h4 id="如何处理着色器内存？"><a href="#如何处理着色器内存？" class="headerlink" title="如何处理着色器内存？"></a>如何处理着色器内存？</h4><ol><li>Unity 提前将着色器加载到内存确保了不会在即将渲染时处理而导致的停顿。</li><li>默认情况下仅在要渲染时才创建 GPU 版本，但这可能会导致稍微的停顿（可通过预热解决）。</li><li>Unity 将缓存 GPU 版本的变体，确保再次需要时不会造成滞后。</li><li>当不再有任何对象引用该变体时，Unity 将会从 CPU 和 GPU 中都完全删除该变体。</li></ol><h4 id="如何选取子着色器？"><a href="#如何选取子着色器？" class="headerlink" title="如何选取子着色器？"></a>如何选取子着色器？</h4><ol><li>在使用 Shader 对象前，Unity 会创建一个子着色器列表，并按顺序添加 Shader 中定义的所有子着色器及其回退着色器。</li><li>当 Unity 首次使用 Shader 对象渲染几何体时，或者当着色器 LOD 值或活动渲染管道更改时，Unity 会决定活动子着色器。</li><li>Unity 遍历子着色器列表，并确定它们是否与满足硬件、渲染管线、LOD 的需求。</li><li>如果包含一个或多个满足要求的子着色器，Unity 会选择第一个子着色器作为活动子着色器。</li><li>如果不包含任何满足所有要求的子着色器：<ol><li>尝试选择首个不满足 LOD 或渲染管线要求，但满足硬件要求的子着色器。</li><li>如果任何子着色器连硬件要求都无法满足，则按顺序尝试使用回退着色器。</li><li>若回退着色器也不兼容，则显示 Unity 内置的错误着色器。</li></ol></li></ol><h4 id="如何挑选合适的变体？"><a href="#如何挑选合适的变体？" class="headerlink" title="如何挑选合适的变体？"></a>如何挑选合适的变体？</h4><ol><li>仅加载与平台的图形 API、硬件和图形层兼容的已编译着色器。</li><li>加载所需着色器变体。</li><li>没有所需变体，则以一套规则加载类似的变体。（详见变体笔记）</li><li>类似变体也没有，则显示错误着色器。</li></ol><p>从 2022.2 开始播放器面板新增严格变体匹配设置，启用后可以阻止 Unity 选取类似变体，而直接显示错误着色器。</p><h3 id="处理着色器加载"><a href="#处理着色器加载" class="headerlink" title="处理着色器加载"></a>处理着色器加载</h3><h4 id="预热着色器"><a href="#预热着色器" class="headerlink" title="预热着色器"></a>预热着色器</h4><p>Unity 默认在需要渲染时才创建变体的 GPU 版本，这在一些性能密集型的软件中可能导致卡顿，所以有时需要对变体的 GPU 版本进行提前加载，而这一过程就叫预热。</p><p>可以通过以下方式预热：</p><ul><li><a href="https://docs.unity.cn/2022.3/Documentation/ScriptReference/Experimental.Rendering.ShaderWarmup.html">Experimental.Rendering.ShaderWarmup</a>：预热 Shader 对象或着色器变体集合</li><li><a href="https://docs.unity.cn/2022.3/Documentation/ScriptReference/ShaderVariantCollection.WarmUp.html">ShaderVariantCollection.WarmUp</a>：预热着色器变体集合</li><li><a href="https://docs.unity.cn/2022.3/Documentation/ScriptReference/Shader.WarmupAllShaders.html">Shader.WarmupAllShaders</a>：预热内存中的所有着色器变体</li><li>将着色器变体集合添加到图形设置中的“预加载着色器”，Unity 将自动在启动时使用<code>ShaderVariantCollection.WarmUp</code>预热。</li></ul><h5 id="部分特殊图形驱动的预热"><a href="#部分特殊图形驱动的预热" class="headerlink" title="部分特殊图形驱动的预热"></a>部分特殊图形驱动的预热</h5><p>DirectX 12、Metal、Vulkan 驱动程序需要在确切知道顶点数据布局和呈现状态的情况下才能创建变体的准确 GPU 表示，因此如果直接通过部分 API 预热可能会不准确而导致失败。</p><p>如果要在这些平台进行预热有如下方式：</p><ul><li>故意在屏幕外渲染材质来主动触发变体的 GPU 版本创建。</li><li>调用<code>Experimental.Rendering.ShaderWarmup</code>并提供顶点数据布局且准确设置渲染状态。</li><li>其他预热方式均有可能失败。</li></ul><h4 id="着色器加载探测"><a href="#着色器加载探测" class="headerlink" title="着色器加载探测"></a>着色器加载探测</h4><p>可以通过探测器窗口的一些事件标记查看着色器加载情况。</p><ul><li><code>Shader.ParseThreaded</code>、<code>Shader.ParseMainThread</code>：表示用于从序列化数据加载着色器对象的事件。</li><li><code>Shader.CreateGPUProgram</code>：表示创建着色器变体 GPU 版本的事件。</li></ul><h4 id="控制着色器内存"><a href="#控制着色器内存" class="headerlink" title="控制着色器内存"></a>控制着色器内存</h4><p>Unity 允许通过设置来控制加载块的大小以及加载进内存的数量，以控制在部分平台的内存占用：<br><a href="https://docs.unity.cn/2022.3/Documentation/Manual/shader-loading.html#dynamicloading">https://docs.unity.cn/2022.3/Documentation/Manual/shader-loading.html#dynamicloading</a></p><h2 id="着色器渲染"><a href="#着色器渲染" class="headerlink" title="着色器渲染"></a>着色器渲染</h2><p>Unity 将使用相同着色器变体的几何体成批渲染，每帧一次，对于每批几何体：</p><ol><li>确定它们需要渲染活动子着色器中的哪些通道，以及帧中的哪些点。</li><li>渲染需要的每一个通道：<ol><li>如果当前渲染状态与通道定义不同，Unity 会根据通道定义重新设置渲染状态。</li><li>调用 GPU 使用相关的着色器变体渲染几何体。</li></ol></li></ol><h2 id="着色器分支"><a href="#着色器分支" class="headerlink" title="着色器分支"></a>着色器分支</h2><p>分支用于实现同一个着色器但不同情况下执行一些差异化代码，从而显示不同的效果。</p><h3 id="分支的种类"><a href="#分支的种类" class="headerlink" title="分支的种类"></a>分支的种类</h3><p>目前有以下几种方式实现分支需求。</p><h4 id="静态分支"><a href="#静态分支" class="headerlink" title="静态分支"></a>静态分支</h4><p>着色器编译器在编译时评估条件代码。</p><ul><li>优点：易于编写和维护，不会对生成时间、文件大小或运行时性能产生负面影响。</li><li>缺点：但不能在运行时切换执行的分支。</li></ul><p>实现方式：</p><ul><li>使用<code>#define</code>、<code>#if</code>等宏指令。</li><li>使用基于编译时常量做条件的<code>if()</code>语句。</li></ul><h4 id="动态分支"><a href="#动态分支" class="headerlink" title="动态分支"></a>动态分支</h4><p>GPU 在运行时评估条件代码。</p><ul><li>优点：支持运行时切换分支且不会增加着色器变体数量（即节省文件内存大小）。</li><li>缺点：会产生一定的 GPU 性能损耗。</li></ul><p>实现方式：</p><ul><li>使用任何运行时状态的<code>if()</code>语句。</li><li>使用动态分支的着色器关键字。</li><li>使用计算着色器关键字。</li></ul><p>底层原理与注意点：</p><p>动态分支会破坏程序的并行性，因此 GPU 必须选择执行不同操作，又或者选择同时执行两个分支然后丢弃一个的方式保持并行。这两种方式都会导致 GPU 性能损耗。</p><p>同时，无论什么时候，GPU 都必须为最坏的情况分配寄存器，所以 GPU 处理分支的开销基本是恒定的。如果一个分支比另一个分支复杂的多，那运行成本也将完全按最坏的情况来。</p><p>所以<strong>确保分支的工作负载均衡</strong>是非常重要的。此外 GPU 在处理<strong>基于统一值的分支</strong>（分支条件都使用同一个变量）上效率是比较高的，所以确保分支条件的简单也很重要。</p><h4 id="使用运算代替分支"><a href="#使用运算代替分支" class="headerlink" title="使用运算代替分支"></a>使用运算代替分支</h4><p>对动态分支的一种改进，利用如 Step 之类的返回 0 或 1 的数学运算来变相执行条件代码。</p><ul><li>优点：不产生分支所以不会破坏程序并行性。</li><li>缺点：可能导致产生难以维护的复杂代码。</li></ul><p>根据具体情况，与动态分支相比，它可能只带来非常小的性能改进或根本没有优势，具体还是要在真机上进行测试。</p><h4 id="着色器变体"><a href="#着色器变体" class="headerlink" title="着色器变体"></a>着色器变体</h4><p>根据静态分支将着色器编译成多个变体版本，这不会对 GPU 性能产生影响。但过多的变体可能导致构建时间、文件大小、运行时内容占用和加载时间的增加。同时在手动预加载着色器功能中着色器变体也会引入额外的代码复杂性。</p><p>着色器变体是 Unity 的一个<strong>核心功能</strong>，是一种高性能的分支实现方案，具体见着色器变体笔记。</p><h3 id="分支的选用"><a href="#分支的选用" class="headerlink" title="分支的选用"></a>分支的选用</h3><p>使用时应分析应用程序性能，根据实际情况进行决定。</p><p>例如，如果能接受一定的 GPU 性能损耗，那最好选择动态分支功能以降低多变体功能带来的风险；</p><p>反之，如果对 GPU 性能要求非常高且考虑了使用变体的成本，那可以选择使用变体功能。</p><h2 id="其他着色器功能"><a href="#其他着色器功能" class="headerlink" title="其他着色器功能"></a>其他着色器功能</h2><h3 id="替换着色器"><a href="#替换着色器" class="headerlink" title="替换着色器"></a>替换着色器</h3><p>利用该功能可以一次性匹配替换场景上的某些着色器，从而实现类似夜视之类的特效。但该功能仅内置渲染管线可用，其他管线需采用其他办法。<br><a href="https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderReplacement.html">https://docs.unity.cn/2022.3/Documentation/Manual/SL-ShaderReplacement.html</a></p><h3 id="计算着色器"><a href="#计算着色器" class="headerlink" title="计算着色器"></a>计算着色器</h3><p>借助这一特殊的着色器可以使 GPU 不仅用于渲染，还能将其卓越的运算性能发挥在其他地方。<br><a href="https://docs.unity.cn/2022.3/Documentation/Manual/class-ComputeShader.html">https://docs.unity.cn/2022.3/Documentation/Manual/class-ComputeShader.html</a></p><h3 id="退守着色器"><a href="#退守着色器" class="headerlink" title="退守着色器"></a>退守着色器</h3><p>Unity 的着色器采用退守机制（fallback），即确保永远都是可渲染的，而不是引起程序异常。为此内置了一些着色器用于实现该机制。</p><h4 id="错误着色器"><a href="#错误着色器" class="headerlink" title="错误着色器"></a>错误着色器</h4><p>当用户提供的着色器无法使用时，改为显示错误着色器。表现效果为洋红色。</p><p>注意当使用<code>BatchRendererGroup</code>API 时默认不会显示错误着色器，需要调用<code>BatchRendererGroup.SetErrorMaterial</code>手动设置。</p><h4 id="加载着色器"><a href="#加载着色器" class="headerlink" title="加载着色器"></a>加载着色器</h4><p>若启用了异步编译，当对象需要渲染但着色器尚未编译完成时，将使用加载着色器代替渲染。表现效果为青色。</p><h4 id="虚拟纹理错误材料"><a href="#虚拟纹理错误材料" class="headerlink" title="虚拟纹理错误材料"></a>虚拟纹理错误材料</h4><p>当项目使用流式虚拟纹理（SVT），则 Unity 会使用特殊材质来指示 SVT 设置中的问题。<br><a href="https://docs.unity.cn/2022.3/Documentation/Manual/svt-error-material.html">https://docs.unity.cn/2022.3/Documentation/Manual/svt-error-material.html</a></p><h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><h3 id="重复编译着色器、绘制调用批处理被中断？"><a href="#重复编译着色器、绘制调用批处理被中断？" class="headerlink" title="重复编译着色器、绘制调用批处理被中断？"></a>重复编译着色器、绘制调用批处理被中断？</h3><p>因为材质球实际没有被共用。通常以下情况会出现该问题：</p><ul><li>资源包与非资源包场景引用了相同的着色器</li><li>多个资源包引用了未加入资源包的材质球</li></ul><h3 id="材质中使用了-shader-feature-关键字，但变体依旧被剥离？"><a href="#材质中使用了-shader-feature-关键字，但变体依旧被剥离？" class="headerlink" title="材质中使用了 shader_feature 关键字，但变体依旧被剥离？"></a>材质中使用了 shader_feature 关键字，但变体依旧被剥离？</h3><p>判断 shader_feature 关键字是否被使用是通过检查当前一起构建的材质中是否使用来得知的。</p><p>若材质和着色器分别打包，则着色器无法得知当前使用的材质球，因而无法判断 shader_feature 使用情况。</p><p>所以解决方法有两种：</p><ol><li>改用<code>multi_compile</code>声明关键字，保证 Unity 永远编译相关变体。</li><li>利用“变体集合”代替材质球与着色器一起打包，相当于显式收集相关变体。</li></ol><h3 id="着色器打包后丢失？"><a href="#着色器打包后丢失？" class="headerlink" title="着色器打包后丢失？"></a>着色器打包后丢失？</h3><p>若该着色器是仅在代码中通过<code>Shader.Find()</code>等形式获取，且没有任何材质或其他物体引用，则可能被 Unity 误判为未被使用的资源而在打包时剥离。</p><p>所以解决方法有两种：</p><ol><li>改用物体引用的方式获取，让 Unity 能自动识别到该着色器。</li><li>将该着色器放入到“Always Included Shaders”中，显式永远打包。</li><li>将该着色器放入到 Resources 文件夹，改用 Resources.Load 加载着色器。</li></ol>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
      <category>着色器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【英语语法笔记】介词</title>
    <link href="/posts/3481354081.html"/>
    <url>/posts/3481354081.html</url>
    
    <content type="html"><![CDATA[<h1 id="【英语语法笔记】介词"><a href="#【英语语法笔记】介词" class="headerlink" title="【英语语法笔记】介词"></a>【英语语法笔记】介词</h1><p>介词用于表示事物之间的关系，通常有如下用法，使用时应放在作用对象之间。</p><h2 id="表示时间关系"><a href="#表示时间关系" class="headerlink" title="表示时间关系"></a>表示时间关系</h2><p>表示 a 在 某个时间点。</p><h3 id="在某时间中"><a href="#在某时间中" class="headerlink" title="在某时间中"></a>在某时间中</h3><ul><li><p><code>on</code>：表示在某一天。</p><ul><li>on Monday：在星期一。</li><li>on January fifth：在一月一日。</li><li>on Christmas Day：在圣诞节那天。</li></ul></li><li><p><code>at</code>：表示在某段较具体或有一定意义的时间。</p><ul><li>at 4:30：在 4 点 30 分。</li><li>at sixteen：在 16 岁的时候。</li></ul></li><li><p><code>in</code>：表示在一段较长不具体的时间内。</p><ul><li>in the morning：在早上。</li><li>in January：在一月。</li><li>in Spring：在春季。</li><li>in 2024：在 2024 年。</li></ul></li><li><p>其他表示在一段时间内</p><ul><li><code>during</code>：用于在具体有一定意义的时间。</li><li><code>for</code>：用于无特殊含义的一般的时间。</li><li><code>throughout</code>：从始至终。</li><li><code>from..to..</code>：从..到..时间。</li><li><code>within</code></li><li><code>between</code></li></ul></li></ul><h3 id="在某时间前"><a href="#在某时间前" class="headerlink" title="在某时间前"></a>在某时间前</h3><ul><li>before：之前</li><li>until、till：直到</li><li>up to：最多到</li></ul><h3 id="在某时间后"><a href="#在某时间后" class="headerlink" title="在某时间后"></a>在某时间后</h3><ul><li>after：之后</li><li>since：自从</li></ul><h2 id="表示位置关系"><a href="#表示位置关系" class="headerlink" title="表示位置关系"></a>表示位置关系</h2><p>表示 a 在 b 的某个位置。</p><h3 id="在某物上下"><a href="#在某物上下" class="headerlink" title="在某物上下"></a>在某物上下</h3><ul><li>on：在上面、接壤</li><li>above：在上面</li><li>below：在下面</li><li>over：正上方</li><li>under：正下方</li></ul><h3 id="在某物前后"><a href="#在某物前后" class="headerlink" title="在某物前后"></a>在某物前后</h3><ul><li>in front of：在前面</li><li>behind：在后面</li></ul><h3 id="在某物里外"><a href="#在某物里外" class="headerlink" title="在某物里外"></a>在某物里外</h3><ul><li>in：在里面、在大地方</li><li>at：在附近、在小地方</li><li>to：在附近</li><li>by：在附近</li><li>beside：在旁边</li></ul><h2 id="表示因果关系"><a href="#表示因果关系" class="headerlink" title="表示因果关系"></a>表示因果关系</h2><p>表示 a 是引发 b 的原因。</p><ul><li>for：为了</li></ul><h2 id="表示方式关系"><a href="#表示方式关系" class="headerlink" title="表示方式关系"></a>表示方式关系</h2><p>表示 a 是实现 b 的手段。</p><ul><li>by：通过</li></ul><h2 id="表示属性关系"><a href="#表示属性关系" class="headerlink" title="表示属性关系"></a>表示属性关系</h2><p>表示 a 是 b 的属性或从属关系。</p><ul><li>of：什么的什么</li></ul><h2 id="表示正在进行"><a href="#表示正在进行" class="headerlink" title="表示正在进行"></a>表示正在进行</h2><p>在表语前接介词可表示正在进行，但不用触发进行时语法（此时可将动词看成形容词，用介词表示在该状态中）。</p><ul><li>He is at work（他正在工作）</li><li>The house is on fire（房子着火了）</li><li>The road is under construction（这条路正在建设中）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/74325865">英语介词用法总结</a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>英语</category>
      
      <category>英语语法笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【英语语法笔记】表示时间</title>
    <link href="/posts/2556572278.html"/>
    <url>/posts/2556572278.html</url>
    
    <content type="html"><![CDATA[<h1 id="【英语语法笔记】表示时间"><a href="#【英语语法笔记】表示时间" class="headerlink" title="【英语语法笔记】表示时间"></a>【英语语法笔记】表示时间</h1><h2 id="表示时间"><a href="#表示时间" class="headerlink" title="表示时间"></a>表示时间</h2><h3 id="直接表示"><a href="#直接表示" class="headerlink" title="直接表示"></a>直接表示</h3><ul><li><p><code>&lt;小时&gt; &lt;分钟&gt;</code>：几点几分。</p><p>如：six ten（6:10）</p></li></ul><h3 id="通过时间差表示"><a href="#通过时间差表示" class="headerlink" title="通过时间差表示"></a>通过时间差表示</h3><ul><li><p><code>&lt;分钟&gt; past &lt;小时&gt;</code>：某小时过了几分钟</p><p>如：ten past six（6:10）</p></li><li><p><code>&lt;分钟&gt; to &lt;小时&gt;</code>：差几分钟到某小时</p><p>如：ten to six（5:50）</p></li></ul><h3 id="通过-12-进制时间表示"><a href="#通过-12-进制时间表示" class="headerlink" title="通过 12 进制时间表示"></a>通过 12 进制时间表示</h3><ul><li><p><code>&lt;时间&gt; a.m.</code>：表示是上午时间，是 ante meridiem 的缩写。</p><p>如：six a.m.（6:00）</p></li><li><p><code>&lt;时间&gt; p.m.</code>：表示是下午时间，是 post meridiem 的缩写。</p><p>如：six p.m.（18:00）</p></li></ul><h3 id="表示特殊时间"><a href="#表示特殊时间" class="headerlink" title="表示特殊时间"></a>表示特殊时间</h3><ul><li><p><code>half</code>：半小时，需配合时间差表示法。</p><p>如：half past six、half to seven（6:30）</p></li><li><p><code>a quarter</code>：一刻钟，需配合时间差表示法。</p><p>如：a quarter past six（6:15）、a quarter to seven（6:45）</p></li><li><p><code>o&#39;clock</code>：整点，是 of the clock 的缩写。</p><p>如：six o’clock（6:00）</p></li><li><p><code>noon</code>：中午十二点</p></li><li><p><code>midnight</code>：夜间十二点</p></li></ul><h2 id="表示星期"><a href="#表示星期" class="headerlink" title="表示星期"></a>表示星期</h2><ul><li><code>Monday</code>、<code>Mon.</code>：周一</li><li><code>Tuesday</code>、<code>Tues.</code>：周二</li><li><code>Wednesday</code>、<code>Wed.</code>：周三</li><li><code>Thursday</code>、<code>Thur.</code>：周四</li><li><code>Friday</code>、<code>Fri.</code>：周五</li><li><code>Saturday</code>、<code>Sat.</code>：周六</li><li><code>Sunday</code>、<code>Sun.</code>：周日</li></ul><h2 id="表示年月日"><a href="#表示年月日" class="headerlink" title="表示年月日"></a>表示年月日</h2><h3 id="表示年份"><a href="#表示年份" class="headerlink" title="表示年份"></a>表示年份</h3><h4 id="正式场合"><a href="#正式场合" class="headerlink" title="正式场合"></a>正式场合</h4><ul><li><p>直接当成正常的基数读即可，但除非百位为 0，否则优先以百位最高。</p><p>如：nineteen hundred and forty-nine（1949）、two thousand and two（2002）</p></li></ul><h4 id="口语场合"><a href="#口语场合" class="headerlink" title="口语场合"></a>口语场合</h4><p>通常将年份数字两两拆分来读。</p><ul><li><p>四位数，对半分。</p><p>如：nineteen forty-nine（1949）</p></li><li><p>三位数，前一后二。</p><p>如：two fifty-three（253）</p></li><li><p>末尾全为零，全归前面。</p><p>如： nineteen hundred（1900）、two thousand（2000）</p></li><li><p>高位带零，零读 o。</p><p>如：twenty o one（2001）</p></li></ul><h3 id="表示月份"><a href="#表示月份" class="headerlink" title="表示月份"></a>表示月份</h3><ul><li><code>January</code>、<code>jan.</code>：一月</li><li><code>February</code>、<code>Feb.</code>：二月</li><li><code>March</code>、<code>Mar.</code>：三月</li><li><code>April</code>、<code>Apr.</code>：四月</li><li><code>May</code>：五月</li><li><code>June</code>、<code>Jun.</code>：六月</li><li><code>July</code>、<code>Jul.</code>：七月</li><li><code>August</code>、<code>Aug.</code>：八月</li><li><code>September</code>、<code>Sep.</code>：九月</li><li><code>October</code>、<code>Oct.</code>：十月</li><li><code>November</code>、<code>Nov.</code>：十一月</li><li><code>December</code>、<code>Dec.</code>：十二月</li></ul><h3 id="表示日期"><a href="#表示日期" class="headerlink" title="表示日期"></a>表示日期</h3><ul><li><p><code>the &lt;日期序数&gt; [day]</code>：上下文无法体现数字是日期时要加 day。</p><p>如：the second day（第二天）</p></li></ul><h3 id="表示年月日-1"><a href="#表示年月日-1" class="headerlink" title="表示年月日"></a>表示年月日</h3><ul><li><p><code>&lt;月&gt; &lt;日&gt;,&lt;年&gt;</code>：简单的同时表示年月日。</p><p>如：January the seventeen,two thousand and two（2002 年 1 月 17 日）</p></li><li><p><code>&lt;日&gt; of &lt;月&gt;,&lt;年&gt;</code>：使用 of 连接表示。</p><p>如：the seventeen of January,two thousand and two（2002 年 1 月 17 日）</p></li></ul><h2 id="表示世纪年代"><a href="#表示世纪年代" class="headerlink" title="表示世纪年代"></a>表示世纪年代</h2><h3 id="表示世纪"><a href="#表示世纪" class="headerlink" title="表示世纪"></a>表示世纪</h3><ul><li><p><code>the &lt;世纪序数&gt; century</code>：第几世纪。</p><p>如：the twenty-first century（21 世纪）</p></li></ul><h3 id="表示年代"><a href="#表示年代" class="headerlink" title="表示年代"></a>表示年代</h3><p>年代是在对应基数的基础上进行 s 变形表示的。</p><ul><li><p><code>the &lt;年代基数的s变形&gt;</code>：第几年代。</p><p>如：the thirties（30 年代）</p></li></ul><h3 id="表示世纪年代-1"><a href="#表示世纪年代-1" class="headerlink" title="表示世纪年代"></a>表示世纪年代</h3><ul><li><p><code>the &lt;世纪基数减一&gt; &lt;年代&gt;</code>：简单的同时表示世纪和年代。</p><p>如：the nineteen thirties（20 世纪 30 年代）</p></li><li><p><code>the &lt;年代&gt; of &lt;世纪&gt;</code>：使用 of 连接表示。</p><p>如：the thirties of the twentieth century（20 世纪 30 年代）</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/38401660">关于时间的英文表达，这里全啦！</a></li><li><a href="https://zhuanlan.zhihu.com/p/146571440">周一至周日正确英文缩写，看一遍就懂了</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>英语</category>
      
      <category>英语语法笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【英语语法笔记】表示数字</title>
    <link href="/posts/1226664103.html"/>
    <url>/posts/1226664103.html</url>
    
    <content type="html"><![CDATA[<h1 id="【英语语法笔记】表示数字"><a href="#【英语语法笔记】表示数字" class="headerlink" title="【英语语法笔记】表示数字"></a>【英语语法笔记】表示数字</h1><h2 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h2><h3 id="1-到-12"><a href="#1-到-12" class="headerlink" title="1 到 12"></a>1 到 12</h3><ul><li>one：1</li><li>two：2</li><li>three：3</li><li>four：4</li><li>five：5</li><li>six：6</li><li>seven：7</li><li>eight：8</li><li>nine：9</li><li>ten：10</li><li>eleven：11</li><li>twelve：12</li></ul><h3 id="13-到-19"><a href="#13-到-19" class="headerlink" title="13 到 19"></a>13 到 19</h3><p>在个位数单词基础上添加后缀 teen（十几岁的）。</p><p>部分会对个位数单词进行特殊变形：</p><ul><li>thirteen：13</li><li>fifteen：15</li><li>eighteen：18</li></ul><h3 id="20-到-99"><a href="#20-到-99" class="headerlink" title="20 到 99"></a>20 到 99</h3><h4 id="个位为-0"><a href="#个位为-0" class="headerlink" title="个位为 0"></a>个位为 0</h4><p>在十位数单词基础上添加后缀 ty。</p><p>部分会对十位数单词进行特殊变形：</p><ul><li>twenty：20</li><li>thirty：30</li><li>forty：40</li><li>fifty：50</li><li>eighty：80</li></ul><h4 id="个位不为-0"><a href="#个位不为-0" class="headerlink" title="个位不为 0"></a>个位不为 0</h4><p>分别表示十位数和个位数，然后用连字符相连。</p><p>如：twenty-one（21）、thirty-two（32），forty-three（43）</p><h3 id="100-到-999"><a href="#100-到-999" class="headerlink" title="100 到 999"></a>100 到 999</h3><p>单独描述百位数的数量和十位个位数单词，然后用 and 将其拼接。</p><ul><li>hundred：百、100</li></ul><p>如：one hundred and twenty-three（123）</p><h3 id="大于等于-1000"><a href="#大于等于-1000" class="headerlink" title="大于等于 1000"></a>大于等于 1000</h3><p>英语采用千分位制，以此将数值分为多段分别描述，然后从高到低排列。</p><ul><li>thousand：千、1,000</li><li>million：百万、1,000,000</li><li>billion：十亿、1,000,000,000</li></ul><p>如：one billion two hundred and thirty-four million five hundred and sixty-seven thousand eight hundred and nicety（1,234,567,890）</p><h2 id="序数"><a href="#序数" class="headerlink" title="序数"></a>序数</h2><h3 id="1-到-3"><a href="#1-到-3" class="headerlink" title="1 到 3"></a>1 到 3</h3><ul><li>first：第一</li><li>second：第二</li><li>third：第三</li></ul><h3 id="大于-3"><a href="#大于-3" class="headerlink" title="大于 3"></a>大于 3</h3><p>直接在对应基数词的末尾添加 th 后缀。</p><p>部分有特殊变形，规律如下：</p><ul><li>以 y 结尾，y 要变 ie。</li><li>以 ve 结尾，ve 要变 f。</li><li>以 t 结尾， t 要去除。</li><li>以 e 结尾，e 要去除。</li></ul><h2 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h2><p>和中文一样，小数点前按正常的自然数读，小数点后一位一位读，小数点读 point。</p><p>如：one hundred and twenty-three point four five（123.45）</p><h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><p>分子在前，用基数词表示；分母在后，用序数词表示。</p><p>如：twenty-one third（21&#x2F;3）</p><h2 id="百分数"><a href="#百分数" class="headerlink" title="百分数"></a>百分数</h2><p>在正常数字读法的基础上，前面加一个 percent（%）即可。</p><p>如：percent twelve point three（12.3%）</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/113672607">一篇文章搞定英语中的数词</a></li><li><a href="https://zhuanlan.zhihu.com/p/136783132">整数、分数及小数的英文读法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>英语</category>
      
      <category>英语语法笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【英语】常用代词笔记</title>
    <link href="/posts/1864774520.html"/>
    <url>/posts/1864774520.html</url>
    
    <content type="html"><![CDATA[<h1 id="【英语】常用代词笔记"><a href="#【英语】常用代词笔记" class="headerlink" title="【英语】常用代词笔记"></a>【英语】常用代词笔记</h1><p>英文 pronoun，简称 pron.</p><p>用于指代东西，可作为主语宾语，根据上下文代替名词使用。</p><p>名称或代词根据其在句子中起到的语法功能会处于不同的格状态，这可能导致单词形态的变化。</p><ul><li>主格：表示主语</li><li>宾格：表示宾语</li><li>所有格（属格）：表示所属关系</li></ul><hr><h2 id="人称代词"><a href="#人称代词" class="headerlink" title="人称代词"></a>人称代词</h2><p>用于表示明确的某个或某些人或物。</p><table><thead><tr><th>含义</th><th>主格形态</th><th>宾格形态</th></tr></thead><tbody><tr><td>我</td><td>i</td><td>me</td></tr><tr><td>他</td><td>he</td><td>him</td></tr><tr><td>她</td><td>she</td><td>her</td></tr><tr><td>它</td><td>it</td><td>it</td></tr><tr><td>你、你们</td><td>you</td><td>you</td></tr><tr><td>我们</td><td>we</td><td>us</td></tr><tr><td>他们</td><td>they</td><td>them</td></tr></tbody></table><h2 id="物主代词（人称代词所有格）"><a href="#物主代词（人称代词所有格）" class="headerlink" title="物主代词（人称代词所有格）"></a>物主代词（人称代词所有格）</h2><p>用于表示明确的某个或某些人或物的东西。</p><p>根据使用方式可分两种：</p><ul><li>形容词性物主代词：做为形容词使用，后面要加具体的名词。</li><li>名词性物主代词：直接作为名词使用，通过上下文省略具体名词。</li></ul><table><thead><tr><th>含义</th><th>形容词性</th><th>名词性</th></tr></thead><tbody><tr><td>我的</td><td>my</td><td>mine</td></tr><tr><td>他的</td><td>his</td><td>his</td></tr><tr><td>她的</td><td>her</td><td>hers</td></tr><tr><td>它的</td><td>its</td><td>its</td></tr><tr><td>我们的</td><td>our</td><td>ours</td></tr><tr><td>你的、你们的</td><td>your</td><td>yours</td></tr><tr><td>他们的</td><td>their</td><td>theirs</td></tr></tbody></table><h2 id="反身代词"><a href="#反身代词" class="headerlink" title="反身代词"></a>反身代词</h2><p>表示某个或某些人或物自身。</p><ul><li>self：自己</li><li>selves：自己（复数）</li></ul><table><thead><tr><th>含义</th><th></th></tr></thead><tbody><tr><td>我自己</td><td>myself</td></tr><tr><td>你自己</td><td>yourself</td></tr><tr><td>他自己</td><td>himself</td></tr><tr><td>她自己</td><td>herself</td></tr><tr><td>它自己</td><td>itself</td></tr><tr><td>我们自己</td><td>ourselves</td></tr><tr><td>你们自己</td><td>yourselves</td></tr><tr><td>他们自己</td><td>themselves</td></tr></tbody></table><h2 id="相互代词"><a href="#相互代词" class="headerlink" title="相互代词"></a>相互代词</h2><p>代表前述名词的相互关系。</p><ul><li>each other</li><li>one another</li></ul><p>如：They love each other</p><h2 id="指示代词"><a href="#指示代词" class="headerlink" title="指示代词"></a>指示代词</h2><table><thead><tr><th>含义</th><th></th></tr></thead><tbody><tr><td>这个</td><td>this</td></tr><tr><td>那个</td><td>that</td></tr><tr><td>这些</td><td>these</td></tr><tr><td>那些</td><td>those</td></tr></tbody></table><h2 id="不定代词"><a href="#不定代词" class="headerlink" title="不定代词"></a>不定代词</h2><p>除了上述代替特定某物的代词之外的所有代词。</p><h2 id="关系代词"><a href="#关系代词" class="headerlink" title="关系代词"></a>关系代词</h2><p>在从句中做主宾等，指代主句中被修饰的名词。</p><h2 id="连接代词"><a href="#连接代词" class="headerlink" title="连接代词"></a>连接代词</h2><p>在主句中做主宾等，并引导修饰其的从句。</p><table><thead><tr><th>含义</th><th>主格</th><th>宾格</th></tr></thead><tbody><tr><td>无论谁</td><td>whoever</td><td>whomever</td></tr><tr><td>无论什么东西</td><td>whatever</td><td></td></tr><tr><td>无论哪个或哪些</td><td>whichever</td><td></td></tr><tr><td>…</td><td></td><td></td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://baike.baidu.com/item/%E4%BB%A3%E8%AF%8D/19411168">百科-代词</a></li><li><a href="https://zhuanlan.zhihu.com/p/186156161">什么是物主代词？</a></li><li><a href="https://baijiahao.baidu.com/s?id=1737526273171278862">代词分类之连接代词和关系代词</a></li><li><a href="https://zhuanlan.zhihu.com/p/41794893">这一篇让你明白什么是语法里的“格”</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>英语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【英语】常用疑问词笔记</title>
    <link href="/posts/1922779167.html"/>
    <url>/posts/1922779167.html</url>
    
    <content type="html"><![CDATA[<h1 id="【英语】常用疑问词笔记"><a href="#【英语】常用疑问词笔记" class="headerlink" title="【英语】常用疑问词笔记"></a>【英语】常用疑问词笔记</h1><p>疑问词并不是只用来构建疑问句，实际作用更接近用于指代某种未知或已知事物，即要询问的内容或上下文提过的东西。</p><p>因为这种事物可能是任何一种词类，所以疑问词也可以代替名词、形容词、副词等多种词类。</p><h2 id="疑问代词"><a href="#疑问代词" class="headerlink" title="疑问代词"></a>疑问代词</h2><ul><li>what：问什么</li><li>who &#x2F; whom（宾格）：问什么人</li><li>which：问哪个东西</li><li>whose：问什么人的</li></ul><h2 id="疑问形容词"><a href="#疑问形容词" class="headerlink" title="疑问形容词"></a>疑问形容词</h2><ul><li>what：什么的</li><li>whose：什么人的</li><li>which：哪一个的</li></ul><h2 id="疑问副词"><a href="#疑问副词" class="headerlink" title="疑问副词"></a>疑问副词</h2><ul><li>when：问时间</li><li>where：问地点</li><li>why：问原因</li><li>how：问怎么</li></ul><h2 id="疑问短语"><a href="#疑问短语" class="headerlink" title="疑问短语"></a>疑问短语</h2><ul><li>what for：为什么</li><li>what about：怎么样</li><li>what time：什么时间</li><li>what day：什么星期</li><li>what date：什么日期</li><li>how old：多少岁</li><li>how many：多少数量</li><li>how much：多少钱</li><li>how come：怎么回事</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/336574537">英语中的疑问词</a></li><li><a href="https://zhuanlan.zhihu.com/p/352857761">how many 与 how much 的用法及区别</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>英语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【英语语法笔记】单词</title>
    <link href="/posts/4121327623.html"/>
    <url>/posts/4121327623.html</url>
    
    <content type="html"><![CDATA[<h1 id="【英语语法笔记】单词"><a href="#【英语语法笔记】单词" class="headerlink" title="【英语语法笔记】单词"></a>【英语语法笔记】单词</h1><p>单词是构成英语句子的基本单位。</p><h2 id="单词的组成"><a href="#单词的组成" class="headerlink" title="单词的组成"></a>单词的组成</h2><p>单词并不是用字母随机创建的，其也存在类似汉语中的偏旁，是一点一点演变过来的。</p><p>组成形式：<code>前缀 + 词根 + 后缀</code></p><ul><li>词根：决定了单词最原初的含义</li><li>前缀：在词根基础上改变其词义</li><li>后缀：决定单词词性并因此再次微调含义</li></ul><p>学会词根和词缀可以大幅提高背单词的能力。虽然因为时代变迁的缘故，部分词根和词缀与单词现今的含义有些不同，但绝大部分都是大差不差的。</p><h2 id="单词的分类"><a href="#单词的分类" class="headerlink" title="单词的分类"></a>单词的分类</h2><h3 id="按音节数分类"><a href="#按音节数分类" class="headerlink" title="按音节数分类"></a>按音节数分类</h3><p>音节数不同的单词通常读音长度也不同，部分单词语法变化会受此影响。</p><ul><li>单音节：单词只有一个音节。</li><li>双音节：单词只有两个音节。</li><li>多音节：单词由至少三个音节构成。</li></ul><h3 id="按词性（词类）分类"><a href="#按词性（词类）分类" class="headerlink" title="按词性（词类）分类"></a>按词性（词类）分类</h3><p>根据单词可担任的句子成分，可以将其按词性划分。一个单词通常支持多个词性，也即可以担任多种句子成分。只要掌握了词类我们就知道当前的句子成分可以填写哪些单词。</p><h4 id="构成主宾"><a href="#构成主宾" class="headerlink" title="构成主宾"></a>构成主宾</h4><ul><li>名词（n.）：表示人或事物名称。</li><li>冠词（art.）：用在名词前帮助说明其词义。</li><li>代词（pron.）：用来代替名词或数词等。</li></ul><h4 id="构成谓语"><a href="#构成谓语" class="headerlink" title="构成谓语"></a>构成谓语</h4><ul><li>动词（v.）：表示动作或状态。</li></ul><h4 id="构成定语"><a href="#构成定语" class="headerlink" title="构成定语"></a>构成定语</h4><ul><li>形容词（a.&#x2F;adj.）：用来修饰名词或代词。</li><li>介词（prep.）：用在名词、代词等前面，表示与别的词的关系。</li><li>数词（num.）：用来表示数量或顺序。</li><li>量词（quant.）：通常用来表示人、事物或动作的数量单位。</li></ul><h4 id="构成状语"><a href="#构成状语" class="headerlink" title="构成状语"></a>构成状语</h4><ul><li>副词（ad.&#x2F;adv.）：用来修饰动词、形容词或副词。</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>连词（conj.）：用来连接词与词或句与句。</li><li>疑问词（int.）：用于构成特殊疑问句和感叹句。</li><li>感叹词（interj.）：表示说话时的感情或口气。</li></ul><h2 id="词性转换"><a href="#词性转换" class="headerlink" title="词性转换"></a>词性转换</h2><p>为了减少单词数量，不同词性间的单词往往采用同样的词根但不同词缀的方式表示。因此很多不同词类的单词实际可以相互转换，只要记住这些规律就能大幅增加词汇量。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/98668292">单词的构成——单词，词根和词缀</a></li><li><a href="https://baike.baidu.com/item/%E8%AF%8D%E7%B1%BB/5310343#2">百科-英语词类</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>英语</category>
      
      <category>英语语法笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【英语语法笔记】动词</title>
    <link href="/posts/1170703467.html"/>
    <url>/posts/1170703467.html</url>
    
    <content type="html"><![CDATA[<h1 id="【英语语法笔记】动词"><a href="#【英语语法笔记】动词" class="headerlink" title="【英语语法笔记】动词"></a>【英语语法笔记】动词</h1><p>动词的英文为 Verb，简称 v.，通常做谓语或主语、宾语使用。</p><h2 id="动词分类"><a href="#动词分类" class="headerlink" title="动词分类"></a>动词分类</h2><h3 id="按在句中的功能分"><a href="#按在句中的功能分" class="headerlink" title="按在句中的功能分"></a>按在句中的功能分</h3><ul><li>主动词（实义动词）：具有实际意义的动词也是最常见的动词。</li><li>助动词：辅助主动词满足语法目的或附加额外信息的动词。<ul><li>基本助动词：没有词义，仅为了满足语法而是使用。</li><li>情态助动词：有词义但必须依赖主动词，通常修饰动作发起的情绪态度。</li></ul></li><li>系动词：起特殊连接作用的动词，主要用于实现被动语态。</li></ul><p>一个动词往往支持多种功能用法，所以两者没有绝对绑定关系，具体要根据句子分析。</p><h3 id="按是否需要宾语分"><a href="#按是否需要宾语分" class="headerlink" title="按是否需要宾语分"></a>按是否需要宾语分</h3><ul><li>及物动词：需要注明宾语才能构成完整意思。</li><li>不及物动词：上下文包含了物体信息，所以不需要显式注明宾语；或者宾语就是主语本身。</li></ul><p>很多动词是两种类型兼具的，具体可根据动词含义在上下文中是否通顺来进行分析。</p><h3 id="按是否做谓语分"><a href="#按是否做谓语分" class="headerlink" title="按是否做谓语分"></a>按是否做谓语分</h3><ul><li>谓语动词：担任最重要的谓语功能，需承载时态表示的重任。</li><li>非谓语动词：不担任谓语位置，更类似主宾语的作用，没有太多的语法规则。</li></ul><h2 id="助动词"><a href="#助动词" class="headerlink" title="助动词"></a>助动词</h2><p>部分涉及到谓语的语法或想要修饰发起人与动作关系时，需要添加额外的助动词，形成助动词+主动词的结构。</p><p>当添加了助动词的动词需要再次叠加语法时，只需使用首个助动词承担即可。</p><h3 id="基本助动词"><a href="#基本助动词" class="headerlink" title="基本助动词"></a>基本助动词</h3><p>没有含义，为了满足语法功能而存在。</p><ul><li>do：动词的通用助动词。</li><li>be：用于构成进行时。</li><li>have：用于构成完成时。</li><li>will：用于构成将来时。</li></ul><h3 id="情态助动词"><a href="#情态助动词" class="headerlink" title="情态助动词"></a>情态助动词</h3><p>有含义但必须依赖“主动词”而存在的动词，通常表达发起者对动作的情绪态度。</p><p>要注意的是，情态助动词的核心特征是必须依赖“主动词”，而不是表达情绪态度。例如 want（想要）就不是，因为也可以用名称做参数，例如 I want a teddy bear（我想要一只玩具熊）；但如 can（能够），may（可能）就是情态助动词，因为你必须用动词做参数。</p><ul><li>can：能够</li><li>may：可能</li><li>must：必须</li><li>should：应该</li><li>need：需要</li><li>had better：最好</li><li>would rather：宁可</li><li>used to：过去一直</li></ul><h2 id="时态表示"><a href="#时态表示" class="headerlink" title="时态表示"></a>时态表示</h2><p>当动词做谓语时必须要负责描述句子中的时态、人称、人数等（统一简称时态）。</p><p>具体见额外的时态表示笔记。</p><h2 id="非谓语动词"><a href="#非谓语动词" class="headerlink" title="非谓语动词"></a>非谓语动词</h2><p>一个句子只能出现一个谓语，如果其他地方要用动词必须采用非谓语动词的形式。</p><p>非谓语动词由于不在担任谓语的作用，所以语法规则较少，因此又叫做动词不定式，指不需要再限定时态状态。其更多的起到类似宾语宾补的作用，用于作为谓语的参数使用。</p><p>表示一个动词是非谓语动词有两种方式。</p><ul><li>不定式</li><li>动名词</li></ul><h3 id="不定式"><a href="#不定式" class="headerlink" title="不定式"></a>不定式</h3><p>不定式方式使动词保留了原型状态，词性上给人感觉仍类似动词，因此为了和前面的谓语动词做区分，通常需要加连词 to。</p><ul><li><p>形式：<code>to + do</code></p><ul><li>举例：I wanted to go home.</li></ul></li></ul><p>当然，但若两种区别明显，也可不加。</p><ul><li><p>形式：<code>do</code></p><p>当谓语是使役动词时（很明显依赖不定式补足内容的谓语），或已有连词分割谓语和不定式时，可以去掉连词 to。</p><ul><li>举例：<ul><li>He did nothing but laugh.（已有连词 but）</li><li>He made me run away.（谓语为使役动词）</li></ul></li></ul></li></ul><p>表示否定时在不定式前面加 not，如<code>not to do</code>、<code>not do</code>。</p><h3 id="动名词"><a href="#动名词" class="headerlink" title="动名词"></a>动名词</h3><p>将动词转换为名词使用。</p><ul><li>形式：<code>doing</code>（同现在分词变形）</li><li>举例：I like shopping.</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://baike.baidu.com/item/%E5%8A%A9%E5%8A%A8%E8%AF%8D/1422500">百科-助动词</a></li><li><a href="https://zhuanlan.zhihu.com/p/195706370">【术语攻略】什么是情态助动词？</a></li><li><a href="https://www.zhihu.com/question/31379646">情态动词和情态助动词的区别？</a></li><li><a href="https://zhuanlan.zhihu.com/p/166264807">非谓语动词用法归纳</a></li><li><a href="https://www.zhihu.com/question/321401385">为什么英语中，to do 叫做不定式？</a></li><li><a href="https://zhuanlan.zhihu.com/p/225339975">关于不定式符号 to 的理解以及省略的原理</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>英语</category>
      
      <category>英语语法笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【英语语法笔记】句子</title>
    <link href="/posts/648367824.html"/>
    <url>/posts/648367824.html</url>
    
    <content type="html"><![CDATA[<h1 id="【英语语法笔记】句子"><a href="#【英语语法笔记】句子" class="headerlink" title="【英语语法笔记】句子"></a>【英语语法笔记】句子</h1><p>英语是一种语言，语言都是为了描述事物而存在，无论是汉语还是编程甚至数学都可以理解为一种语言，因此之间都存在共性。</p><p>学习英语语法的目的是为了能将英语单词（也可能是短语甚至句子）拼凑成一个完整的句子，所以要从句子的角度出发去，只要理解了句子的组成原理就等于掌握的语法。</p><p>句子由两部分构成。</p><ul><li>成分：每个单词在句子中担任的角色。</li><li>句型：决定了成分组合后的最终含义。</li></ul><h2 id="句子成分"><a href="#句子成分" class="headerlink" title="句子成分"></a>句子成分</h2><p>根据单词在句子中的角色，可以分为以下几种成分。</p><ul><li>谓语：主语的动作或状态。</li><li>主语：句子的描述对象。</li><li>宾语：谓语的承担者。</li><li>定语：修饰名词、代词。</li><li>状语：修饰动词、形容词。</li><li>补语：补足不完全的信息。</li></ul><h3 id="谓语"><a href="#谓语" class="headerlink" title="谓语"></a>谓语</h3><p>谓语代表一种动作，运动、定义、感受都是一种动作，这就类似于数学中的函数。</p><p>一个句子最重要也是必不可少的是谓语，因为生命在于运动，时间因动而能被观测，所以任何事情的描述都一定需要谓语存在。</p><h3 id="主语、宾语"><a href="#主语、宾语" class="headerlink" title="主语、宾语"></a>主语、宾语</h3><p>任何动作都不可能凭空发生，所以谓语一定有其发起人和接收人，这就对应了出了主语与宾语。</p><p>根据谓语的不同，对主语和宾语的需求也不一样，这就好像不同数学函数对参数需求也不一样，谓语同样如此。任何事物都可能成为主语或宾语，个人或物、动作或概念……这都有可能。</p><h3 id="定语、状语"><a href="#定语、状语" class="headerlink" title="定语、状语"></a>定语、状语</h3><p>主语、宾语的信息可以进一步完善，比如描述所属人，描述状态外观等，这些就需要用到定语。</p><p>谓语也是一样，可以描述动作的频率程度等，甚至进一步描述定语状语本身，这些就需要用到状语。</p><h3 id="补语"><a href="#补语" class="headerlink" title="补语"></a>补语</h3><p>有时光靠已有句子成分表示的内容并不不完整，为了额外补充一些信息可以借助补语实现。</p><h2 id="句子形态"><a href="#句子形态" class="headerlink" title="句子形态"></a>句子形态</h2><p>句子形态决定了句子成分组合后的最终含义，具体而言可以分以下几种。</p><h3 id="决定语态"><a href="#决定语态" class="headerlink" title="决定语态"></a>决定语态</h3><p>不同的语态决定了谓语与主语宾语的关系。</p><ul><li>主动语态</li><li>被动语态</li></ul><h4 id="主动语态"><a href="#主动语态" class="headerlink" title="主动语态"></a>主动语态</h4><p>主语做动作发起者，谓语做动作，宾语做承担者，表示..把..怎么了。</p><ul><li><p><code>主语 + 谓语 + 宾语</code></p><p>最基本的主动语态，如：“He + enjoys + reading”。</p></li><li><p><code>主语 + 谓语 + 间接宾语 + 直接宾语</code></p><p>部分谓语需要两个宾语，如：“You + give + me + a book”。</p></li><li><p><code>主语 + 谓语 + 宾语 + 宾语补语</code></p><p>仅靠宾语无法表达完整内容，如：“You + make + me + happy”。</p></li></ul><h4 id="被动语态"><a href="#被动语态" class="headerlink" title="被动语态"></a>被动语态</h4><p>主语做动作承担者，定语（此处一般叫表语）表明承担的动作，表示自身“被怎么了”或“怎么了”。</p><ul><li><p><code>主语 + 谓语</code></p><p>配合不及物动词实现宾语的省略，如：“The sun + rises”。</p></li><li><p><code>主语 + 谓语（系动词） + 定语</code></p><p>最基本的被动语态，如：“He + was + heard”（他被听到了）。注意当此处用动词做定语时要变成过去式。</p></li></ul><p>此外可利用句尾加 <code>by + ...</code> 来额外描述动作或状态的发起者。</p><h3 id="决定语气"><a href="#决定语气" class="headerlink" title="决定语气"></a>决定语气</h3><p>不同的语气决定了同一件事但不同的视角。</p><ul><li>陈述句</li><li>否定句</li><li>祈使句</li><li>感叹句</li><li>疑问句</li></ul><h4 id="陈述句"><a href="#陈述句" class="headerlink" title="陈述句"></a>陈述句</h4><p>默认的句子类型。</p><ol><li>参考基本语态句型实现即可。</li></ol><h4 id="否定句"><a href="#否定句" class="headerlink" title="否定句"></a>否定句</h4><p>一种表示否定的陈述句。</p><ol><li>先写出陈述句。</li><li>然后在助动词后加 not。（如果没有助动词则按目标类型添加相应的助动词）</li></ol><h4 id="祈使句"><a href="#祈使句" class="headerlink" title="祈使句"></a>祈使句</h4><p>表达命令、劝告等，语气强烈的句子。</p><ol><li>省略主语，使谓语做句首。</li><li>可在开头或结尾加上 please，使语气客气。</li></ol><h4 id="感叹句"><a href="#感叹句" class="headerlink" title="感叹句"></a>感叹句</h4><p>一种感情更强烈的陈述句。</p><ol><li>将疑问词做代词放在句首。</li><li>然后在后面用从句解释它。</li></ol><h4 id="疑问句"><a href="#疑问句" class="headerlink" title="疑问句"></a>疑问句</h4><h5 id="一般疑问句"><a href="#一般疑问句" class="headerlink" title="一般疑问句"></a>一般疑问句</h5><p>用于询问一些简单的，针对已知事实的问题，回答一般是“是、否”之类。</p><ol><li>先写出陈述句。</li><li>然后添加或移动助动词到句首。</li></ol><h5 id="特殊疑问句"><a href="#特殊疑问句" class="headerlink" title="特殊疑问句"></a>特殊疑问句</h5><p>配合疑问词，询问一些更复杂的，针对未知事实的问题。</p><ol><li>先构成类似一般疑问句的句型。</li><li>在句首添加疑问词指明询问内容。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/111590211">英语中的五大基本句型</a></li><li><a href="https://www.zhihu.com/tardis/zm/art/336913504">英语语法：十大词类、八种句子成分、五种基本句型</a></li><li><a href="https://zhuanlan.zhihu.com/p/643919605">英语句子分类 1：按句子的功能分类：陈述句、祈使句、一般&#x2F;特殊疑问句、感叹句</a></li><li><a href="https://www.cpsenglish.com/article/341">英语基础语法快速入门——被动语态</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>英语</category>
      
      <category>英语语法笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【英语语法笔记】名词</title>
    <link href="/posts/4168832070.html"/>
    <url>/posts/4168832070.html</url>
    
    <content type="html"><![CDATA[<h1 id="【英语语法笔记】名词"><a href="#【英语语法笔记】名词" class="headerlink" title="【英语语法笔记】名词"></a>【英语语法笔记】名词</h1><p>英文名为 noun，简称 n.，用于表示人、事物和抽象概念等的词。</p><h2 id="名词分类"><a href="#名词分类" class="headerlink" title="名词分类"></a>名词分类</h2><h3 id="按意义分类"><a href="#按意义分类" class="headerlink" title="按意义分类"></a>按意义分类</h3><ul><li>专有名词：具体的人，事物，地点，团体或机构的专有名称。</li><li>普通名词：某些人，某类事物，某种物质或抽象概念的名称。<ul><li>个体名词：单个的人和事物。</li><li>集体名词：一群人或一些事物的名称。</li><li>复合名词：两个或两个以上名词连在一起构成的名词。</li><li>物质名词：物质或不具备确定形状和大小的个体的物质。</li><li>抽象名词：动作，状态，品质或其他抽象概念。</li></ul></li></ul><h3 id="按可数分类"><a href="#按可数分类" class="headerlink" title="按可数分类"></a>按可数分类</h3><ul><li>可数名词：有数量意义；结构清晰可辨，拆分后不同源。</li><li>不可数名词：在概念上无数量意义，如家具、生命；将其拆分后和原本依旧是同一种物质结构，如水、沙子。</li></ul><p>在不同句子的同一个名词可能既可数也不可数，所以具体能不能数，要看其在身处的上下文环境。</p><h2 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h2><p>当名词表示的是具体的特定事物时，必须遵照以下语法以表明是专有名词。</p><ul><li>所有单词首字母必须大写。如 China</li><li>名词为短语时需要加定冠词 the。如 the Great Wall</li></ul><h2 id="不可数名词"><a href="#不可数名词" class="headerlink" title="不可数名词"></a>不可数名词</h2><p>不可数名词无法表示具体的数量，因此需要遵照一些特定的语法规则。</p><ul><li>可以表示复数，但不需要复数变形，所以只存在单数形式（原型）。</li><li>前面不可添加明确数量的冠词或量词，如 a&#x2F;an、one。</li></ul><h2 id="可数名词的复数变形"><a href="#可数名词的复数变形" class="headerlink" title="可数名词的复数变形"></a>可数名词的复数变形</h2><p>可数名词可以表示数量，且当数量不止一个时需要变形为复数形式。</p><ol><li>一般情况，直接加 s。</li><li>以 s,x,ch,sh,o（有生命的）结尾，直接加 es。</li><li>以辅音字母+y 结尾，变 y 为 i 再加 es。</li><li>以 f、fe 结尾，变 f、fe 为 v 再加 es。</li><li>少部分有特殊形式。</li></ol><h2 id="前缀冠词"><a href="#前缀冠词" class="headerlink" title="前缀冠词"></a>前缀冠词</h2><p>名词既可以表示概念也可以表示具体的事物，所以当没有其他修饰词可以区分这一点时需要用冠词确定。</p><p>例如“学校”既可以表示学校这一机构的概念，也可以表示具体的某个学校，通过是否添加冠词可以产生不同的意思：go to school（泛指上学动作）；go to the school（确实去某个学校）。</p><h3 id="定冠词"><a href="#定冠词" class="headerlink" title="定冠词"></a>定冠词</h3><p>名词表示特定时对象使用。that 或 those 的弱化版本，部分情况可以被类似的词替代。</p><ul><li>the + 专有名词：专有名词的语法要求。</li><li>the + 形容词：表示符合该形容词的一类人。如 the poor（穷人）</li><li>the + 姓氏复数形式：表示该姓氏一家人。如 the Greens（格林一家人）</li></ul><h3 id="不定冠词"><a href="#不定冠词" class="headerlink" title="不定冠词"></a>不定冠词</h3><p>名词为可数的普通名词时使用。one 的弱化版本，可以被其他量词替代。</p><ul><li>a：用于辅音音素开头的单词</li><li>an：用于元音音素开头的单词</li></ul><h2 id="表示单位"><a href="#表示单位" class="headerlink" title="表示单位"></a>表示单位</h2><p>用基于单位的方式描述名词数量。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">数量 + 容器 + of + 名词<br></code></pre></td></tr></table></figure><ul><li>不可数名词可借此表达数量意义。</li><li>作为单位的容器也要遵照名词语法。</li></ul><p>列如：two baskets of apples</p><h2 id="表示数量"><a href="#表示数量" class="headerlink" title="表示数量"></a>表示数量</h2><ul><li>some &#x2F; any（否定或疑问句）：一些</li><li>most：大多</li><li>every：每个</li><li>all：所有</li><li>both：两者都</li><li>either：两者之一</li><li>neither：两者都不</li><li>many（可数）&#x2F; much（不可数）&#x2F; a lot of：许多</li><li>a few（可数）：几个</li><li>a little（不可数）：一点</li><li>none &#x2F; no one：没有一个</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/21737918">【英语语法高手之路】进阶篇——第一章 冠词</a></li><li><a href="https://zhuanlan.zhihu.com/p/102306441">不定冠词(a,an)的用法</a></li><li><a href="https://zhuanlan.zhihu.com/p/413279743">英文中的十大词类 —— 名词</a></li><li><a href="https://www.zhihu.com/question/285662107">为什么 bread 是不可数名词？</a></li><li><a href="https://www.zhihu.com/question/52990584">冠词的存在有什么意义？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>英语</category>
      
      <category>英语语法笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【英语语法笔记】表示时态</title>
    <link href="/posts/3075658332.html"/>
    <url>/posts/3075658332.html</url>
    
    <content type="html"><![CDATA[<h1 id="【英语语法笔记】表示时态"><a href="#【英语语法笔记】表示时态" class="headerlink" title="【英语语法笔记】表示时态"></a>【英语语法笔记】表示时态</h1><p>当动词做谓语时必须要负责描述句子中的时态、人称、人数等（统一简称时态）。</p><p>时态的表示是通过对动词变形或添加助动词来实现的。</p><h2 id="表示内容"><a href="#表示内容" class="headerlink" title="表示内容"></a>表示内容</h2><ul><li>表明事件发生的时间<ul><li>现在：现在发生。</li><li>过去：过去发生。</li><li>将来：将来发生。</li><li>过去将来：在过去表明将来发生。</li></ul></li><li>表明当时执行的状况<ul><li>一般：不说明执行状况。</li><li>进行：正在进行。</li><li>完成：已经完成。</li><li>完成进行：一直或反复发生且不中断。</li></ul></li><li>表明主语的人称数量<ul><li>第一人称。</li><li>第二人称或第三人称复数。</li><li>第三人称单数。</li></ul></li></ul><h2 id="动词变形"><a href="#动词变形" class="headerlink" title="动词变形"></a>动词变形</h2><h3 id="原型（do）"><a href="#原型（do）" class="headerlink" title="原型（do）"></a>原型（do）</h3><p>动词的最原始状态。</p><h3 id="第三人称单数（does）"><a href="#第三人称单数（does）" class="headerlink" title="第三人称单数（does）"></a>第三人称单数（does）</h3><p>用于体现主语的人称人数。</p><ol><li>一般情况，直接加 s。</li><li>以 s,x,ch,sh,o（有生命）结尾，直接加 es。</li><li>以辅音字母+y 结尾，变 y 为 i 再加 es。</li><li>少部分有特殊形式。</li></ol><h3 id="现在分词（doing）"><a href="#现在分词（doing）" class="headerlink" title="现在分词（doing）"></a>现在分词（doing）</h3><p>用于表示动作正在进行。</p><ol><li>一般情况，直接加 ing。</li><li>以不发音的 e 结尾，去 e 加 ing。</li><li>以重读闭音节结尾，双写最后一个字母再加 ing。</li><li>少部分有特殊形式。</li></ol><h3 id="过去分词（done）"><a href="#过去分词（done）" class="headerlink" title="过去分词（done）"></a>过去分词（done）</h3><p>配合 have 表示动作已完成。</p><ol><li>一般情况，直接加 ed。</li><li>以不发音的 e 结尾，去 e 加 ed。</li><li>以辅音字母+y 结尾，变 y 为 i 再加 ed。</li><li>以重读闭音节结尾，双写最后一个字母再加 ed。</li><li>少部分有特殊形式。</li></ol><h3 id="过去式（did）"><a href="#过去式（did）" class="headerlink" title="过去式（did）"></a>过去式（did）</h3><p>表示动作发生在过去。</p><ol><li>一般情况，和过去分词变化一致。</li><li>少部分有特殊形式。</li></ol><h2 id="助动词变形"><a href="#助动词变形" class="headerlink" title="助动词变形"></a>助动词变形</h2><p>时态之类的信息允许叠加，因此表示时态用的助动词也会有要变形的时候。</p><ul><li><p>be（进行时助动词）：</p><ul><li>过去分词：been</li><li>过去式：was（第一人称&#x2F;三单），were（复数）</li><li>一般式：am（第一人称），is（三单），are（复数）</li></ul></li><li><p>have（完成时助动词）：</p><ul><li>过去式&#x2F;过去分词：had</li><li>一般式：has</li></ul></li><li><p>will（将来时助动词）：</p><ul><li>过去式&#x2F;过去分词：would</li></ul></li><li><p>do：</p><ul><li>过去分词：done</li><li>过去式：did</li></ul></li></ul><h2 id="表示时态"><a href="#表示时态" class="headerlink" title="表示时态"></a>表示时态</h2><p>表示时态需要通过以下语法规则实现。</p><ol><li><p>表明状态</p><ol><li>表明进行时：be + doing</li><li>表明完成时：have + done</li><li>表明一般时：do</li></ol></li><li><p>表明时间</p><ol><li>表明将来：will + do</li><li>表明过去：did</li><li>表明现在：do</li></ol></li><li><p>表明人称</p><p>当动词在当前时态形变的基础上还可以进行人称变化时需要进行人称变化。</p><p>受助动词影响，基本上只有以下时态需要考虑三单变化。</p><ul><li>现在时</li><li>过去进行时</li></ul></li></ol><p>时态之类的信息允许叠加，叠加时要遵循以下规则：</p><ul><li>按时态名称倒序累加时态形变，最后判断人称形变，也即上述的排列顺序。</li><li>对于由多个助动词和主动词组成的动词序列，只需变形首动词即可。</li></ul><h2 id="最终总览"><a href="#最终总览" class="headerlink" title="最终总览"></a>最终总览</h2><p>组合后的变形效果如下：</p><table><thead><tr><th>时态</th><th>一般时（do）</th><th>进行时（be + doing）</th><th>完成时（have + done）</th><th>完成进行时</th></tr></thead><tbody><tr><td>现在（do&#x2F;does）</td><td>一般现在时</br> do&#x2F;does</td><td>现在进行时</br> am&#x2F;is&#x2F;are doing</td><td>现在完成时</br> have&#x2F;has done</td><td>现在完成进行时</br> have&#x2F;has been doing</td></tr><tr><td>过去 (did)</td><td>一般过去时</br> did</td><td>过去进行时</br> was&#x2F;were doing</td><td>过去完成时</br> had done</td><td>过去完成进行时</br> had been doing</td></tr><tr><td>将来 (will do)</td><td>一般将来时</br> will do</td><td>将来进行时</br> will be doing</td><td>将来完成时</br> will have done</td><td>将来完成进行时</br> will have been doing</td></tr><tr><td>过去将来</td><td>过去将来时</br> would do</td><td>过去将来进行时</br> would be doing</td><td>过去将来完成时</br> would have done</td><td>过去将来完成进行时</br> would have been doing</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://baike.baidu.com/item/%E5%AE%8C%E6%88%90%E8%BF%9B%E8%A1%8C%E6%97%B6/2853937">百科-完成进行时</a></li><li><a href="https://baike.baidu.com/item/%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0%E5%8D%95%E6%95%B0/1586952">百科-第三人称单数</a></li><li><a href="https://baike.baidu.com/item/%E7%8E%B0%E5%9C%A8%E5%88%86%E8%AF%8D/4217655">百科-现在分词</a></li><li><a href="https://baike.baidu.com/item/%E8%BF%87%E5%8E%BB%E5%88%86%E8%AF%8D?fromModule=lemma_search-box">百科-过去分词</a></li><li><a href="https://zhuanlan.zhihu.com/p/137296107">过去将来时：英语里最分裂的时态就它 | 虫虫讲英语</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>英语</category>
      
      <category>英语语法笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【英语语法笔记】形容词</title>
    <link href="/posts/3611936726.html"/>
    <url>/posts/3611936726.html</url>
    
    <content type="html"><![CDATA[<h1 id="【英语语法笔记】形容词"><a href="#【英语语法笔记】形容词" class="headerlink" title="【英语语法笔记】形容词"></a>【英语语法笔记】形容词</h1><h2 id="比较级与最高级"><a href="#比较级与最高级" class="headerlink" title="比较级与最高级"></a>比较级与最高级</h2><p>在英语中表示“更怎么”、“最怎么”是通过对形容词变形实现的。</p><h3 id="比较级"><a href="#比较级" class="headerlink" title="比较级"></a>比较级</h3><h4 id="变形方式"><a href="#变形方式" class="headerlink" title="变形方式"></a>变形方式</h4><ol><li>一般情况，直接加 er。</li><li>以不发音的 e 结尾，去 e 加 er。</li><li>以辅音字母+y 结尾，变 y 为 i 再加 er。</li><li>以重读闭音节结尾，双写最后一个字母再加 er。</li><li>多音节和部分双音节，单词前加 more（肯定）&#x2F; less（否定）。</li><li>少部分有特殊形式。</li></ol><h4 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h4><ul><li>利用连词 than（比）连接前后比较对象。</li><li>比较 + and + 比较：表示事物越来越怎么。</li></ul><h3 id="最高级"><a href="#最高级" class="headerlink" title="最高级"></a>最高级</h3><h4 id="变形方式-1"><a href="#变形方式-1" class="headerlink" title="变形方式"></a>变形方式</h4><ol><li>一般情况，直接加 est。</li><li>以不发音的 e 结尾，去 e 加 est。</li><li>以辅音字母+y 结尾，变 y 为 i 再加 est。</li><li>以重读闭音节结尾，双写最后一个字母再加 est。</li><li>多音节和部分双音节，单词前加 most（肯定）&#x2F; least（否定）。</li><li>少部分有特殊形式。</li></ol><h4 id="使用例子-1"><a href="#使用例子-1" class="headerlink" title="使用例子"></a>使用例子</h4><ul><li>利用前面加 the 表示那个最怎么的事物。</li></ul><h2 id="形容词后置"><a href="#形容词后置" class="headerlink" title="形容词后置"></a>形容词后置</h2><p>一般情况下形容词放在被修饰名词的前面，但有时也会放在后面。</p><ul><li>形容词修饰不定代词时。</li><li>形容词修饰表示度量的名词。</li><li>以字母 a- 开头的表语形容词。</li><li>else 修饰疑问代词时，须后置。</li><li>当形容词前有 so, more, most 等词修饰时，常后置。</li><li>形容词短语通常后置，其功能相当于一个定语从句。</li><li>两个或两个以上的形容词用 and 或 or 连接作定语，表示强调意义时要后置。</li><li>形容词比较结构须后置定语。</li><li>有些形容词作前置定语时和后置定语时所表达的意义不同。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/364060441">形容词的比较级和最高级</a></li><li><a href="https://zhidao.baidu.com/question/109840484/answer/351021608.html">英语形容词修饰名词什么时候放在名词前，什么时候放在名词后？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>英语</category>
      
      <category>英语语法笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【英语语法笔记】音标</title>
    <link href="/posts/1271277138.html"/>
    <url>/posts/1271277138.html</url>
    
    <content type="html"><![CDATA[<h1 id="【英语语法笔记】音标"><a href="#【英语语法笔记】音标" class="headerlink" title="【英语语法笔记】音标"></a>【英语语法笔记】音标</h1><h2 id="音素"><a href="#音素" class="headerlink" title="音素"></a>音素</h2><p>音素是发音的最小单位，一个音素只代表一种发音，如[ɔi]就是由[ɔ]和[i]两个音素构成。所以说音标和音节都不是发音最小单位，音素才是。</p><h2 id="音标"><a href="#音标" class="headerlink" title="音标"></a>音标</h2><p>英标类似中文的汉语拼音，两者都是为了给单词&#x2F;字标注读法。且很多读音比较相似，因为两者都来自拉丁字母。所以下面用近似的汉语拼英或汉字标注音标的读音。</p><ul><li>音标没有音调，始终等于拼音或汉字第一声。</li><li>音标必须要快而短的发音，这和拼音不一样。</li></ul><p>共计 48 个音标，元音 20 个，辅音 28 个。</p><h3 id="元音"><a href="#元音" class="headerlink" title="元音"></a>元音</h3><p>用于构成各种发音的基本音，相当于火锅的锅底。</p><p>可以简单看成发 a,ae,e,i,o,u 及其混合音的音标。</p><h4 id="单元音"><a href="#单元音" class="headerlink" title="单元音"></a>单元音</h4><ul><li>短元音：快速短暂的发音。</li><li>长元音：对应短元音拖长就变成长元音。</li></ul><table><thead><tr><th>短元音</th><th>长元音</th><th>注音</th></tr></thead><tbody><tr><td>[i]</td><td>[i:]</td><td>i</td></tr><tr><td>[ə]</td><td>[ə:]</td><td>e</td></tr><tr><td>[ɒ]</td><td>[ɔ:]</td><td>o</td></tr><tr><td>[u]</td><td>[u:]</td><td>u</td></tr><tr><td>[Λ]</td><td>[ɑ:]</td><td>a</td></tr><tr><td>[æ]</td><td></td><td>ae</td></tr><tr><td>[e]</td><td></td><td>ae（更轻）</td></tr></tbody></table><ul><li>ae：a 和 e 的中间音，类似带口语的欸。</li></ul><h4 id="双元音"><a href="#双元音" class="headerlink" title="双元音"></a>双元音</h4><p>通过快速连读两个单元音来混合成新读音。</p><table><thead><tr><th>国际音标</th><th>注音</th></tr></thead><tbody><tr><td>[ai]</td><td>ai</td></tr><tr><td>[ei]</td><td>ei</td></tr><tr><td>[ɔi]</td><td>[ɒ],[i] 连读</td></tr><tr><td>[au]</td><td>ao</td></tr><tr><td>[əu]</td><td>ou</td></tr><tr><td>[iə]</td><td>[i],[ə] 连读</td></tr><tr><td>[eə]</td><td>[e],[ə] 连读</td></tr><tr><td>[uə]</td><td>[u],[ə] 连读</td></tr></tbody></table><h3 id="辅音"><a href="#辅音" class="headerlink" title="辅音"></a>辅音</h3><p>辅助元音微调其发音方式，从而发出更多各种各样的音，相当于火锅的配菜。</p><p>辅音通过发音方式分为清辅音和浊辅音，两者大多存在相对关系。</p><ul><li>清辅音：通过推动气流发音。</li><li>浊辅音：通过振动声带发音。</li></ul><h4 id="爆破音"><a href="#爆破音" class="headerlink" title="爆破音"></a>爆破音</h4><table><thead><tr><th>清辅音</th><th>注音</th><th>浊辅音</th><th>注音</th></tr></thead><tbody><tr><td>[p]</td><td>p</td><td>[b]</td><td>b</td></tr><tr><td>[t]</td><td>t</td><td>[d]</td><td>d</td></tr><tr><td>[k]</td><td>k</td><td>[g]</td><td>g</td></tr></tbody></table><h4 id="摩擦音"><a href="#摩擦音" class="headerlink" title="摩擦音"></a>摩擦音</h4><table><thead><tr><th>清辅音</th><th>注音</th><th>浊辅音</th><th>注音</th></tr></thead><tbody><tr><td>[f]</td><td>f</td><td>[v]</td><td>u</td></tr><tr><td>[s]</td><td>s</td><td>[z]</td><td>[dz] 去掉 d</td></tr><tr><td>[∫]</td><td>x</td><td>[ʒ]</td><td>x</td></tr><tr><td>[θ]</td><td>[s] 轻抵舌头</td><td>[ð]</td><td>[z] 轻抵舌头</td></tr><tr><td>[h]</td><td>h</td><td>[r]</td><td>ruo</td></tr></tbody></table><h4 id="破擦音"><a href="#破擦音" class="headerlink" title="破擦音"></a>破擦音</h4><table><thead><tr><th>清辅音</th><th>注音</th><th>浊辅音</th><th>注音</th></tr></thead><tbody><tr><td>[tr]</td><td>chuo</td><td>[dr]</td><td>zhuo</td></tr><tr><td>[ts]</td><td>c</td><td>[dz]</td><td>z</td></tr><tr><td>[t∫]</td><td>q</td><td>[dʒ]</td><td>j</td></tr></tbody></table><h4 id="鼻音"><a href="#鼻音" class="headerlink" title="鼻音"></a>鼻音</h4><table><thead><tr><th>浊辅音</th><th>注音（做响音）</th><th>注音（做辅音）</th></tr></thead><tbody><tr><td>[m]</td><td>m</td><td>ng（很重）</td></tr><tr><td>[n]</td><td>n</td><td>ng（重）</td></tr><tr><td>[ŋ]</td><td></td><td>ng（轻）</td></tr></tbody></table><ul><li>ng：拼音 ang 去掉 a，其中 ng 的读音。</li><li>做响音：这类特殊的辅音可以起到代替元音的作用。</li></ul><h4 id="舌则音"><a href="#舌则音" class="headerlink" title="舌则音"></a>舌则音</h4><table><thead><tr><th>浊辅音</th><th>注音（做响音）</th><th>注音（做辅音）</th></tr></thead><tbody><tr><td>[l]</td><td>l</td><td>o</td></tr></tbody></table><h4 id="半元音"><a href="#半元音" class="headerlink" title="半元音"></a>半元音</h4><table><thead><tr><th>浊辅音</th><th>注音</th></tr></thead><tbody><tr><td>[j]</td><td>y</td></tr><tr><td>[w]</td><td>u</td></tr></tbody></table><h3 id="元音字母与辅音字母"><a href="#元音字母与辅音字母" class="headerlink" title="元音字母与辅音字母"></a>元音字母与辅音字母</h3><p>字母虽然不是音标，但在单词中确实存在一些发音规律，一些英语语法需要这些作为判断条件。</p><ul><li>元音字母：常发元音的字母，共 5 个：a、e、i、o、u。</li><li>辅音字母：常发辅音的字母，元音字母之外的字母。</li></ul><h2 id="音节"><a href="#音节" class="headerlink" title="音节"></a>音节</h2><ul><li>音节将单词进行拆分，一个音节由若干音标字母构成。</li><li>音节是朗读单词的基本单位，音节内要快读，音节间要停顿。</li><li>一个单词由一个或多个音节构成。</li></ul><h3 id="音节的组成"><a href="#音节的组成" class="headerlink" title="音节的组成"></a>音节的组成</h3><ol><li>必须有一个发音元音或一个响音辅音。</li><li>辅助发音元音或响应辅音的若干辅音。</li></ol><h4 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h4><ul><li>发音元音：实际发出声音的元音。相对的也有部分时候不发音的元音，如 come 中的 e 不发音。</li><li>响音辅音：几个特殊的辅音（[m] 、[n]、[l]）。但虽然它们能构成音节，但一般放在词尾且不做为重读音节。</li></ul><h3 id="划分音节的方式"><a href="#划分音节的方式" class="headerlink" title="划分音节的方式"></a>划分音节的方式</h3><ol><li><p>找到发音元音或响音辅音，确定大致的音节位置。</p></li><li><p>根据周边字母进行判断：</p><ul><li><p>两个辅音字母之间只有若干元音字母，相关元音字母共同视作一个元音字母。</p><ul><li>如 beaut ：b 和 t 之间只有 eau 三个元音字母。</li></ul></li><li><p>不能拆分的字母组合将其视作单个字母进行音节划分。</p><ul><li>如 fa ther：a 和 e 之间有一个字母组合 th。</li></ul></li><li><p>两元音字母之间有一个辅音字母时，辅音字母归后一音节。</p><ul><li>如 la bour：b 跟随 o。</li></ul></li><li><p>两元音字母之间有两个辅音字母时，辅音字母平方给前后两个音节。</p><ul><li>如 win ter：n 跟随 i，t 跟随 e。</li></ul></li></ul></li><li><p>根据周边音标进行判断：</p><ul><li><p>辅音必须跟随元音或响音发音，优先跟随最近或后面的组成音节。</p><ul><li><p>如 stu dent：st 跟随 u，d 跟随 e，nt 跟随 e。</p></li><li><p>如 beau ty：y 发 [i]，t 跟随 y。</p></li></ul></li></ul></li></ol><h3 id="几种特殊的音节"><a href="#几种特殊的音节" class="headerlink" title="几种特殊的音节"></a>几种特殊的音节</h3><p>符合这些规律的音节将提供一些读法上的信息或起到一些语法上的限制。</p><h4 id="重读音节"><a href="#重读音节" class="headerlink" title="重读音节"></a>重读音节</h4><p>重读音节是单词发音中最重要的音节，必须要突出响亮的读出来。</p><p>每个单词中一定有一个重读音节：</p><ul><li>如果单词只有一个音节，则该音节就是重读音节。</li><li>如果单词有多个音节，则音标中会有重读符号“ &#96; ”标出该音节。</li></ul><h4 id="开音节"><a href="#开音节" class="headerlink" title="开音节"></a>开音节</h4><p>以元音<strong>音素</strong>结尾的音节。</p><p>开音节若重读，一般其中元音字母发其在字母表中的音。</p><ul><li>绝对开音节：一个元音字母位于<strong>单词末尾</strong>的音节。</li><li>相对开音节：一个元音字母加一个辅音字母（r 除外）加一个不发音的 e 字母结尾的音节。</li></ul><h4 id="闭音节"><a href="#闭音节" class="headerlink" title="闭音节"></a>闭音节</h4><p>以辅音<strong>音素</strong>结尾的音节。（以[r]结尾称为 r 音节，但在过去式、过去分词以及现在分词的双写规则中均与闭音节作相同处理。）</p><ul><li>重读闭音节：词尾的音节重读，且词尾的字母和音标都是辅元辅结构。</li></ul><h2 id="音变"><a href="#音变" class="headerlink" title="音变"></a>音变</h2><p>为了方便阅读，部分情况下音标的读音会发生变化。</p><ul><li><p>浊化</p><p>[s] 后面的清辅音要转成相对的浊辅音发音。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/136840124">48 个英语音标表：20 个元音+28 个辅音，学发音必备！</a></li><li><a href="https://www.jiwake.com/yinbiaofayin]">英语音标发音表</a></li><li><a href="https://zhidao.baidu.com/question/1640499438956595900.html">元音字母有哪些</a></li><li><a href="https://zhuanlan.zhihu.com/p/350948985">英语发音重读规则</a></li><li><a href="https://www.zhihu.com/question/369897144">英语开音节，闭音节，重读开音节，重读闭音节是什么？</a></li><li><a href="http://baike.baidu.com/l/mucSF68n">为什么 play 加 ing 不双写？到底什么是重读闭音节？</a></li><li><a href="https://zhuanlan.zhihu.com/p/25981346">英语的音变：明白了这个，或许能解答你一堆发音的疑惑</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>英语</category>
      
      <category>英语语法笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】图形管道笔记</title>
    <link href="/posts/330516235.html"/>
    <url>/posts/330516235.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】图形管道笔记"><a href="#【Unity】图形管道笔记" class="headerlink" title="【Unity】图形管道笔记"></a>【Unity】图形管道笔记</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul><li><p>域、基元、图面：</p><p>网格所用的多边形面，如三角面、四边面等。</p></li></ul><h2 id="参数语义"><a href="#参数语义" class="headerlink" title="参数语义"></a>参数语义</h2><p>语义是附加到着色器输入或输出参数的字符串，用于传达给系统有关参数的预期用途的信息。</p><h3 id="用户语义"><a href="#用户语义" class="headerlink" title="用户语义"></a>用户语义</h3><p>由用户在 IA 阶段定义的语义。用于描述传入的数据类型，以便系统在 VS 阶段分配输入参数；同时也用于在其他着色器中标记要在各阶段传递的数据，虽然此时数据类型已无作用，但语法上还是需要的。</p><h3 id="系统语义"><a href="#系统语义" class="headerlink" title="系统语义"></a>系统语义</h3><p>系统语义则是系统自带的语义，这些语义为了满足一些功能而存在，如向系统表明着色器输出参数，请求系统自动设置一些特殊值等，其都使用<code>SV_</code>作为前缀。</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics#system-value-semantics">https://learn.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics#system-value-semantics</a></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在各着色器间都存在输入输出参数，其中一些参数由系统语义明确定义，此外还可以由用户语义自定义一些额外参数。这些数据间通常还存在着共用的传递关系，根据使用情况可以分为以下几类。</p><h3 id="装配数据"><a href="#装配数据" class="headerlink" title="装配数据"></a>装配数据</h3><p>顶点着色器的输入数据，大多由用户语义定义，是来自 IA 阶段的原始网格数据。</p><ul><li>SV_VertexID：当前顶点在原始网格数据中的排序序号。</li><li>SV_InstanceID：当使用实例化渲染功能时额外传递的实例序号。</li></ul><h3 id="顶点数据"><a href="#顶点数据" class="headerlink" title="顶点数据"></a>顶点数据</h3><p>经过顶点着色器处理后的，系统所用的顶点数据，多个着色器阶段都会用到该数据。</p><ul><li>SV_Position：基元光栅化时所用的最终顶点位置。</li></ul><h3 id="外壳数据"><a href="#外壳数据" class="headerlink" title="外壳数据"></a>外壳数据</h3><p>在分割阶段中使用的数据，由外壳着色器创建。</p><ul><li>SV_TessFactor：基元的边缘分割次数。</li><li>SV_InsideTessFactor：基元的内部分割次数。</li></ul><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><ul><li>如果外壳着色器阶段将任何边缘细化因子设置为 &#x3D; 0 或 NaN，则将剔除补丁，从而不生成可见输出。</li></ul><h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/overviews-direct3d-11-graphics-pipeline">https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/overviews-direct3d-11-graphics-pipeline</a></p><h3 id="1-输入装配器阶段（IA）"><a href="#1-输入装配器阶段（IA）" class="headerlink" title="1. 输入装配器阶段（IA）"></a>1. 输入装配器阶段（IA）</h3><p>从用户填充的缓冲区中读取基元数据 (点、线和&#x2F;或三角形) ，并将数据组装成将由其他管道阶段使用的基元。</p><ol><li>创建输入缓冲区。</li><li>创建输入布局对象。</li><li>将对象绑定到输入。</li><li>指定基元类型。</li><li>调用绘制方法。</li></ol><h3 id="2-顶点着色器阶段（VS）"><a href="#2-顶点着色器阶段（VS）" class="headerlink" title="2. 顶点着色器阶段（VS）"></a>2. 顶点着色器阶段（VS）</h3><p>处理输入装配器提供的顶点，执行每个顶点运算，例如空间变换、外观变形和每顶点照明。</p><ul><li>输入：装配数据</li><li>输出：顶点数据</li></ul><h3 id="3-分割阶段"><a href="#3-分割阶段" class="headerlink" title="3. 分割阶段"></a>3. 分割阶段</h3><p>通过在硬件中实施分割，使图形管道可解算更低画质（多边形数量更少）模型但并以更高画质进行渲染。</p><ul><li><p>补丁：</p><p>多边形被分割后产生的新多边形。</p></li><li><p>控制点：</p><p>控制点一种顶点，其决定了多边形的形状。如三角形就是有三个控制点，在分割补丁时则是用于计算补丁顶点的参考点，补丁的实际顶点将通过多个控制点及其权重计算得出。</p></li><li><p>修补程序：</p><p>负责将原始域分割为补丁的程序。</p></li></ul><h4 id="3-1-外壳着色器阶段（HS）"><a href="#3-1-外壳着色器阶段（HS）" class="headerlink" title="3.1. 外壳着色器阶段（HS）"></a>3.1. 外壳着色器阶段（HS）</h4><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/direct3d-11-advanced-stages-hull-shader-design">https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/direct3d-11-advanced-stages-hull-shader-design</a></p><p>该阶段由两个函数构成。</p><h5 id="外壳着色器"><a href="#外壳着色器" class="headerlink" title="外壳着色器"></a>外壳着色器</h5><p>计算构成补丁的控制点的顶点数据。</p><ul><li>输入：原始基元控制点的顶点数据、SV_PrimitiveID、SV_OutputControlPointID</li><li>输出：补丁的其中一个控制点的顶点数据</li></ul><h5 id="修补程序常量函数"><a href="#修补程序常量函数" class="headerlink" title="修补程序常量函数"></a>修补程序常量函数</h5><p>为细分器阶段和域着色器阶段提供计算参数。</p><ul><li>输入：原始基元控制点的顶点数据、SV_PrimitiveID</li><li>输出：外壳数据</li></ul><h4 id="3-2-细分器阶段"><a href="#3-2-细分器阶段" class="headerlink" title="3.2. 细分器阶段"></a>3.2. 细分器阶段</h4><p>这是一个固定函数阶段，利用从外壳着色器阶段传入的细化因素和分区类型，将域（四边形、三角形或线）分割为很多较小对象（三角形、点或线）。</p><h4 id="3-3-域着色器阶段（DS）"><a href="#3-3-域着色器阶段（DS）" class="headerlink" title="3.3. 域着色器阶段（DS）"></a>3.3. 域着色器阶段（DS）</h4><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/direct3d-11-advanced-stages-domain-shader-design">https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/direct3d-11-advanced-stages-domain-shader-design</a></p><p>计算补丁程序生成的新基元的顶点数据。</p><ul><li>输入：外壳数据、补丁控制点的顶点数据、SV_DomainLocation</li><li>输出：补丁的其中一个顶点的顶点数据</li></ul><h3 id="4-几何着色器阶段（GS）"><a href="#4-几何着色器阶段（GS）" class="headerlink" title="4. 几何着色器阶段（GS）"></a>4. 几何着色器阶段（GS）</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/d3d10-graphics-programming-guide-output-stream-stage-getting-started">https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/d3d10-graphics-programming-guide-output-stream-stage-getting-started</a></p><p>将顶点作为输入，并能够在输出中生成新顶点，从而实时创造新的网格。</p><ul><li>输入：原始的顶点数据序列</li><li>输出：新增的顶点数据序列</li></ul><h3 id="5-光栅化阶段（RS）"><a href="#5-光栅化阶段（RS）" class="headerlink" title="5. 光栅化阶段（RS）"></a>5. 光栅化阶段（RS）</h3><p>将网格基元映射为屏幕上的“像素”（实际是由 2x2 像素区域构成的片元），并计算对应的顶点数据插值，以便为像素着色器提供输入数据。</p><h3 id="6-像素着色器阶段（PS）"><a href="#6-像素着色器阶段（PS）" class="headerlink" title="6. 像素着色器阶段（PS）"></a>6. 像素着色器阶段（PS）</h3><p>对像素实现丰富的着色技术，例如每像素照明和后期处理。</p><ul><li>输入：顶点数据</li><li>输出：SV_Target、SV_Depth</li></ul><h3 id="7-输出合并阶段（OM）"><a href="#7-输出合并阶段（OM）" class="headerlink" title="7. 输出合并阶段（OM）"></a>7. 输出合并阶段（OM）</h3><p>将像素着色器生成的像素数据按原始三角形的顺序进行进一步处理。</p><ol><li><p>裁剪测试：</p><p>剔除呈现目标区域之外的像素。</p></li><li><p>alpha 测试：</p><p>剔除透明度低于指定值的像素。（Direct3D 10 及以上版本不支持，但可通过<code>clip()</code>实现等效操作）</p></li><li><p>模板测试</p></li><li><p>深度测试</p></li><li><p>混合</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/overviews-direct3d-11-graphics-pipeline">图形管道</a></li><li><a href="https://www.zhihu.com/question/384124671">深度测试&#x2F;模版测试&#x2F;透明度测试先后顺序是什么样的？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】光照解决方案笔记</title>
    <link href="/posts/150670921.html"/>
    <url>/posts/150670921.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】光照解决方案笔记"><a href="#【Unity】光照解决方案笔记" class="headerlink" title="【Unity】光照解决方案笔记"></a>【Unity】光照解决方案笔记</h1><p><a href="https://docs.unity.cn/cn/2022.3/Manual/BestPracticeLightingPipelines.html">https://docs.unity.cn/cn/2022.3/Manual/BestPracticeLightingPipelines.html</a></p><h2 id="确定对象显示效果的三阶段"><a href="#确定对象显示效果的三阶段" class="headerlink" title="确定对象显示效果的三阶段"></a>确定对象显示效果的三阶段</h2><ol><li><p>剔除</p><p>列出了需要渲染的对象，确保这些对象摄像机可见（视锥体剔除）且不被遮挡（遮挡剔除）。</p></li><li><p>渲染</p><p>将这些对象绘制到基于像素的缓冲区中（通过正确的光照以及它们的一些属性）。</p></li><li><p>后期处理</p><p>在这些缓冲区上执行后期处理操作，生成发送到显示设备的最终输出帧。</p></li></ol><h2 id="光照类型"><a href="#光照类型" class="headerlink" title="光照类型"></a>光照类型</h2><ul><li>直接光照</li></ul><p>从自发光光源（如灯泡）发出的光照，而不是光从表面反射的结果。</p><ul><li>间接光照</li></ul><p>由于光从表面反射并通过介质（如大气或半透明物质）传播和散射而形成的结果。</p><h2 id="全局光照（GI）"><a href="#全局光照（GI）" class="headerlink" title="全局光照（GI）"></a>全局光照（GI）</h2><p>全局光照 (Global Illumination) 是一组特殊照明技术的总称，它<strong>考虑了综合且复杂的现实光照模型</strong>（如光的反射、折射等），并以此<strong>对直接和间接光照</strong>进行建模，从而为游戏<strong>提供逼真的光照效果</strong>。</p><p>从使用角度来看可以将 GI 简单理解为<strong>产生间接光的手段</strong>。单纯的兰伯特光照之类的经验光照模型技术并不是 GI。</p><p>GI 提供几种方法，如：</p><ul><li>烘焙&#x2F;动态光照贴图（Unity 支持）</li><li>烘焙&#x2F;动态光照探针（Unity 支持）</li><li>辐照度体积</li><li>光传播体积</li><li>基于体素的 GI 和基于距离场的 GI</li></ul><h2 id="光照贴图程序（Lightmapper）"><a href="#光照贴图程序（Lightmapper）" class="headerlink" title="光照贴图程序（Lightmapper）"></a>光照贴图程序（Lightmapper）</h2><p>这是一个基础系统，它通过发射光线、计算光线反弹并将产生的光线应用到纹理来生成光照贴图和光照探针的数据。</p><h2 id="如何点亮你的项目？"><a href="#如何点亮你的项目？" class="headerlink" title="如何点亮你的项目？"></a>如何点亮你的项目？</h2><p><a href="https://docs.unity.cn/cn/2022.3/uploads/Main/BestPracticeLightingPipeline15.svg">https://docs.unity.cn/cn/2022.3/uploads/Main/BestPracticeLightingPipeline15.svg</a></p><ol><li><p>选择渲染管线</p><ul><li>Built-in RP</li><li>URP</li><li>HDRP</li><li>自定义 SRP</li></ul></li><li><p>决定 GI 模式（产生间接光的 GI 系统）</p><ul><li>烘焙 GI</li><li>实时 GI</li><li>烘焙 &amp; 实时 GI</li></ul></li><li><p>选择光照模式（GI 光与实时光的混合方式）</p><ul><li>Baked Indirect</li><li>Subtractive</li><li>Shadowmask</li><li>Distance Shadowmask</li></ul></li><li><p>添加场景光照</p><ul><li>添加灯光</li><li>添加发光表面</li><li>添加反射探针</li><li>添加光照探针</li><li>添加光照探针代理体（LPPVs）</li></ul></li></ol><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><h3 id="内置渲染管线（Built-in-RP）"><a href="#内置渲染管线（Built-in-RP）" class="headerlink" title="内置渲染管线（Built-in RP）"></a>内置渲染管线（Built-in RP）</h3><p>2018 年之前，Unity 只有一个内置渲染管线（Built-in RP），其提供两种渲染路径。</p><ul><li>向前渲染（多通道：每一盏灯光占用一个 Pass）</li><li>延迟渲染</li></ul><h3 id="高清渲染管线-HDRP"><a href="#高清渲染管线-HDRP" class="headerlink" title="高清渲染管线 (HDRP)"></a>高清渲染管线 (HDRP)</h3><p>提供了先进的渲染和着色功能，为高端游戏平台设计。</p><ul><li>混合延迟&#x2F;前向瓦片&#x2F;聚类渲染器</li></ul><h3 id="通用渲染管线（URP）"><a href="#通用渲染管线（URP）" class="headerlink" title="通用渲染管线（URP）"></a>通用渲染管线（URP）</h3><p>内置管线替代品，保持全平台通用且性能提升。</p><ul><li>向前渲染（单通道：一个 Pass 中渲染所有灯光）</li><li>向前渲染+：Unity 2022.2 新增</li><li>延迟渲染：Unity 2021.2 新增</li></ul><h2 id="渲染路径"><a href="#渲染路径" class="headerlink" title="渲染路径"></a>渲染路径</h2><h3 id="向前渲染路径"><a href="#向前渲染路径" class="headerlink" title="向前渲染路径"></a>向前渲染路径</h3><p>按顺序渲染场景中的所有对象和灯光。</p><p>当对象被多个光源照亮时，渲染成本会急剧增加。</p><p>这种类型的渲染器通常提供各种各样的着色器，并且可以很轻松地处理透明度。</p><h3 id="延迟渲染路径"><a href="#延迟渲染路径" class="headerlink" title="延迟渲染路径"></a>延迟渲染路径</h3><p>先将所有不透明几何体渲染到缓冲区中，其中存储着有关材质的信息（颜色，镜面反射，光滑度等）。然后在后一个 Pass（也就是名字中的“延迟”）渲染所有像素的灯光信息。</p><p>渲染时间将主要取决于影响每个像素的光源数量。但对于透明对象或更复杂的着色器对象，依然需要回退到向前渲染路径中渲染。</p><p>当处理包含许多动态光源的场景时（例如具有人工光照的内部空间，或室外与室内光照相结合的项目），通常建议使用延迟渲染。</p><h2 id="Unity-中的-GI-系统"><a href="#Unity-中的-GI-系统" class="headerlink" title="Unity 中的 GI 系统"></a>Unity 中的 GI 系统</h2><p>在 Unity 的 5.6 之前，Unity 主要使用 Geomerics 公司的 Enlighten 来提供实时 GI 以及烘焙 GI，但在 5.6 之后 Unity 引入了新的 Progressive Lightmapper，如今 Enlighten 将陆续弃用。</p><p><a href="https://forum.unity.com/threads/update-on-global-illumination-2021.1067015/">Unity GI 发展计划</a></p><ul><li><p>实时 GI</p><ul><li>Enlighten 实时 GI（已弃用，仅支持到 Unity 2024）</li></ul></li><li><p>烘焙 GI</p><p>利用光照贴图程序将光照数据烘焙到光照探针、反射探针、称为光照贴图的纹理中</p><ul><li>Enlighten 烘焙 GI（已弃用，仅支持到 Unity 2021）</li><li>渐进式光照贴图程序（Progressive Lightmapper）</li></ul></li></ul><p>不要同时使用 Enlighten 实时 GI 和烘焙 GI，这将对性能产生影响，且两者获取到的间接光也存在视觉差异。</p><h2 id="如何让物体获取间接光"><a href="#如何让物体获取间接光" class="headerlink" title="如何让物体获取间接光"></a>如何让物体获取间接光</h2><ul><li><p>静态物体</p><p>标记为“Contribute GI”的物体将被识别为静态物体，只有静态物体可以接受烘焙&#x2F;预计算的 GI 光照。</p></li><li><p>动态物体</p><p>动态物体只能通过光照探针获得间接光的支持。</p></li></ul><p>由于光照的烘焙是一个相当缓慢的过程，所以只推荐自身具有不同光照变化（如存在凹洞或接受自身阴影）的大型复杂物体才推荐标记“Contribute GI”；对于自身受光均匀的小型凸面网格应该作为动态物体从光照探针中获取间接光。</p><ul><li><p>大型不可烘焙物体（如大型粒子系统或蒙皮网格）</p><p>可以使用 LPPV（Light Probe Proxy Volume）来获取更好的本地化间接光照。</p></li></ul><p>要最大程度减少烘焙时间并同时保持足够的光照质量，最重要的就是限制场景中标记为“Contribute GI”的对象数量。</p><p>照明优化教程：<br><a href="https://learn.unity.com/project/lighting-optimization-with-precomputed-realtime-gi">https://learn.unity.com/project/lighting-optimization-with-precomputed-realtime-gi</a></p><h2 id="光照模式"><a href="#光照模式" class="headerlink" title="光照模式"></a>光照模式</h2><p>Light 组件和 Lighting Settings Asset 中都有一个光照模式的设置，但两者是不同的概念。</p><h3 id="灯光光照模式"><a href="#灯光光照模式" class="headerlink" title="灯光光照模式"></a>灯光光照模式</h3><ul><li>烘焙<br>为 GI 提供光照信息，从这些光源产生的直接和间接光照将被光照贴图程序处理。</li><li>实时<br>实时计算的光照效果，受性能影响无法产生间接光，且光照没有 GI 的效果真实。</li><li>混合<br>提供实时光照的同时也为烘焙光照（GI）提供烘焙信息，并能将两种光照进行混合，混合方式取决于场景光照模式。</li></ul><h3 id="场景光照模式"><a href="#场景光照模式" class="headerlink" title="场景光照模式"></a>场景光照模式</h3><p>指定场景中实时光照和烘焙光照（GI）的混合方式，配合灯光的混合模式使用。</p><h4 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h4><ul><li>阴影贴图：实时阴影实现方案</li><li>阴影距离：显示阴影的最大范围。<strong>若非注明，则所有阴影都受此影响</strong>。</li></ul><h4 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h4><ul><li><p>Subtractive</p><p>最早的混合光照模式。将大部分光照和阴影都采取烘焙实现，仅提供主方向光的实时灯光。</p><p>光照效果比较简陋，但在低端硬件上非常有用。</p><table><thead><tr><th>接收光照</th><th>静态物体</th><th>动态物体</th></tr></thead><tbody><tr><td>直接光照</td><td>光照贴图</td><td>实时</td></tr><tr><td>间接光照</td><td>光照贴图</td><td>光照探针</td></tr><tr><td>静态物体阴影</td><td>光照贴图</td><td>光照探针</td></tr><tr><td>动态物体阴影</td><td>阴影贴图（仅主方向光）</td><td>阴影贴图（仅主方向光）</td></tr></tbody></table><ul><li>主方向光：强度最高的方向光</li></ul></li><li><p>BakedIndirect</p><p>仅烘焙间接光，直接光和阴影都采用实时计算。</p><p>光照效果逼真，但有一定的性能问题。</p><table><thead><tr><th>接收光照</th><th>静态物体</th><th>动态物体</th></tr></thead><tbody><tr><td>直接光照</td><td>实时</td><td>实时</td></tr><tr><td>间接光照</td><td>光照贴图</td><td>光照探针</td></tr><tr><td>静态物体阴影</td><td>阴影贴图</td><td>阴影贴图</td></tr><tr><td>动态物体阴影</td><td>阴影贴图</td><td>阴影贴图</td></tr></tbody></table></li><li><p>Shadowmask</p><p>升级版 BakedIndirect，针对静态物体阴影进行了优化，可同时采取烘焙和实时两种方案，且可以超出阴影距离限制。</p><p>光照效果更逼真，且在性能上有一定优化。</p><table><thead><tr><th>接收光照</th><th>静态物体</th><th>动态物体</th></tr></thead><tbody><tr><td>直接光照</td><td>实时</td><td>实时</td></tr><tr><td>间接光照</td><td>光照贴图</td><td>光照探针</td></tr><tr><td>静态物体阴影</td><td>阴影贴图 | 阴影遮罩</td><td>阴影贴图 | 光照探针</td></tr><tr><td>动态物体阴影</td><td>阴影贴图</td><td>阴影贴图</td></tr></tbody></table><ul><li>阴影遮罩：一种额外的光照贴图，用于确定目标像素是否在阴影中。</li></ul><p>针对静态物体阴影方案有两种模式：</p><ul><li>DistanceShadowmask：阴影距离内采用阴影贴图实现，超出则采用烘焙实现。</li><li>Shadowmask：全距离的都采用烘焙实现。</li></ul></li></ul><h2 id="后处理间接光"><a href="#后处理间接光" class="headerlink" title="后处理间接光"></a>后处理间接光</h2><p>GI 烘焙间接光的时间很长不利于快速原型开发，此时可以利用“屏幕空间环境光遮蔽”功能来模拟间接光效果。</p>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
      <category>渲染管线</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】URP 中的 UGUIShader 实现</title>
    <link href="/posts/1602965714.html"/>
    <url>/posts/1602965714.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】URP-中的-UGUIShader-实现"><a href="#【Unity】URP-中的-UGUIShader-实现" class="headerlink" title="【Unity】URP 中的 UGUIShader 实现"></a>【Unity】URP 中的 UGUIShader 实现</h1><p>参考官方 Shader 代码实现：</p><p><a href="https://github.com/TwoTailsGames/Unity-Built-in-Shaders/blob/master/DefaultResourcesExtra/UI/UI-Default.shader">https://github.com/TwoTailsGames/Unity-Built-in-Shaders/blob/master/DefaultResourcesExtra/UI/UI-Default.shader</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;UI/Template&quot;<br>&#123;<br>Properties<br>&#123;<br>// PerRendererData 表明纹理由每个渲染器提供，似乎是起某种优化作用。<br>[PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;<br><br>_Color (&quot;Tint&quot;, Color) = (1,1,1,1)<br><br>_StencilComp (&quot;Stencil Comparison&quot;, Float) = 8<br>_Stencil (&quot;Stencil ID&quot;, Float) = 0<br>_StencilOp (&quot;Stencil Operation&quot;, Float) = 0<br>_StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255<br>_StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255<br><br>_ColorMask (&quot;Color Mask&quot;, Float) = 15<br><br>// 启用Clip功能，Clip掉的像素将不会参与模板测试等。<br>[Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0<br>&#125;<br>SubShader<br>&#123;<br>LOD 100 //内置无光照系列Shader的LOD一般为100<br>Tags<br>&#123;<br>&quot;Queue&quot;=&quot;Transparent&quot; // 渲染顺序为透明队列<br>&quot;PreviewType&quot;=&quot;Plane&quot; // 材质预览效果为平面<br>&quot;RenderType&quot;=&quot;Transparent&quot; // 渲染类型为透明<br>&quot;CanUseSpriteAtlas&quot;=&quot;True&quot; // 表明兼容 LegacySpritePacker 图集功能。<br>&quot;IgnoreProjector&quot;=&quot;True&quot; // 表明不受内置管线中投影器功能的影响。<br>&#125;<br><br>//UI利用模板功能实现遮罩效果<br>Stencil<br>&#123;<br>Ref [_Stencil]<br>Comp [_StencilComp]<br>Pass [_StencilOp]<br>ReadMask [_StencilReadMask]<br>WriteMask [_StencilWriteMask]<br>&#125;<br><br>//渲染器将自动排序，再加上UI都是半透明物体，所以无需深度功能<br>ZWrite Off<br>ZTest [unity_GUIZTestMode] // unity_GUIZTestMode 根据当前画布的渲染模式自动设置<br><br>Blend SrcAlpha OneMinusSrcAlpha<br>ColorMask [_ColorMask]<br><br>Pass<br>&#123;<br>HLSLPROGRAM<br>#pragma vertex VertexPass<br>#pragma fragment PixelPass<br>#pragma shader_feature _ UNITY_UI_ALPHACLIP<br>#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;<br><br>cbuffer UnityPerMaterial<br>&#123;<br>sampler2D _MainTex;<br>float4 _MainTex_ST;<br>float4 _Color;<br>&#125;<br><br>struct Vertex<br>&#123;<br>float3 positionOS:POSITION;<br>float4 color : COLOR;<br>float2 uv:TEXCOORD0;<br>&#125;;<br><br>struct Pixel<br>&#123;<br>float4 positionCS:SV_POSITION;<br>float4 color : COLOR;<br>float2 uv:TEXCOORD0;<br>&#125;;<br><br><br>Pixel VertexPass(const Vertex vertex)<br>&#123;<br>Pixel pixel;<br>pixel.positionCS = TransformObjectToHClip(vertex.positionOS);<br>pixel.color = vertex.color * _Color;<br>pixel.uv = TRANSFORM_TEX(vertex.uv, _MainTex);<br>return pixel;<br>&#125;<br><br>float4 PixelPass(const Pixel pixel):SV_TARGET<br>&#123;<br>float4 color = tex2D(_MainTex, pixel.uv) * pixel.color;<br>#ifdef UNITY_UI_ALPHACLIP<br>clip (pixel.color.a - 0.001);<br>#endif<br>return color;<br>&#125;<br>ENDHLSL<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】ShaderLab 语法笔记</title>
    <link href="/posts/1843614380.html"/>
    <url>/posts/1843614380.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】ShaderLab-语法笔记"><a href="#【Unity】ShaderLab-语法笔记" class="headerlink" title="【Unity】ShaderLab 语法笔记"></a>【Unity】ShaderLab 语法笔记</h1><p><a href="https://docs.unity.cn/cn/2022.3/Manual/SL-Reference.html">https://docs.unity.cn/cn/2022.3/Manual/SL-Reference.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;&lt;shaderName&gt;&quot;<br>&#123;<br>    [Properties]<br><br>    [Category] // 可以实现批量设置SubShader参数<br>    &#123;<br>        SubShader<br>        &#123;<br>            [PackageRequirements]<br>            [LOD]<br>            [Tags]<br>            [Commands]<br><br>            Pass&#123;<br>                [PackageRequirements]<br>                [Name] &quot;&lt;passName&gt;&quot; // 配合UsePass等功能使用<br>                [Tags]<br>                [Commands]<br>                &lt;PassCode&gt;<br>            &#125;<br>            ...// 一次Pass渲染一次，可填写多个，按顺序多次渲染。<br><br>            [UsePass] &quot;&lt;shaderName/passName&gt;&quot; // 直接使用现成的Pass，等于将另一个Pass的代码复制进来。<br>            [GrabPass] &#123; &#123;&#125; | &quot;textureName&quot; &#125; // 纹理抓取Pass，仅内置管线可用，影响性能不建议使用。<br>        &#125;<br>        ...// 可填多个SubShader，但只会使用首个有效的，用于根据设备环境调整显示效果。<br>    &#125;<br><br>    [Fallback] &#123;&quot;&lt;shaderName&gt;&quot; | Off&#125; // 所有SubShader无效时的回调。<br><br>    [CustomEditor] &quot;&lt;className&gt;&quot; // 自定义面板界面，需继承ShaderGUI的类。<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果 shaderName 以<code>Hidden/</code>为前缀则将在 Shader 菜单中隐藏。</li></ul><h2 id="PackageRequirements"><a href="#PackageRequirements" class="headerlink" title="PackageRequirements"></a>PackageRequirements</h2><p><a href="https://docs.unity.cn/cn/2022.3/Manual/SL-PackageRequirements.html">https://docs.unity.cn/cn/2022.3/Manual/SL-PackageRequirements.html</a></p><p>描述该着色器依赖的 Unity 包环境，这对那些需要做多管线支持的着色器非常有用，可以避免因管线兼容性导致的编译错误。</p><h2 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h2><p>指明当前 SubShader 对计算方面的需求，可配合 Shader.maximumLOD 排除高于指定 LOD 的 SubShader，从而实现根据不同硬件性能使用不同的显示效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">LOD &lt;number&gt;<br></code></pre></td></tr></table></figure><h3 id="内置-Shader-的-LOD"><a href="#内置-Shader-的-LOD" class="headerlink" title="内置 Shader 的 LOD"></a>内置 Shader 的 LOD</h3><ul><li>Unlit 系列：100</li><li>Standard：300</li></ul><h2 id="Propertie"><a href="#Propertie" class="headerlink" title="Propertie"></a>Propertie</h2><p>用于定义显示在面板的参数，同时这些参数会被序列化保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Properties<br>&#123;<br>    [attribute]... &lt;name&gt; (&quot;&lt;displayname&gt;&quot;,&lt;type&gt;) = &lt;defaultValue&gt;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="支持的-type-及其-defaultValue"><a href="#支持的-type-及其-defaultValue" class="headerlink" title="支持的 type 及其 defaultValue"></a>支持的 type 及其 defaultValue</h3><table><thead><tr><th>type</th><th>defualtValue</th><th>备注</th></tr></thead><tbody><tr><td>Integer</td><td>&lt;number&gt;</td><td></td></tr><tr><td>Int</td><td>&lt;number&gt;</td><td>旧版整数，实际是浮点实现</td></tr><tr><td>Float</td><td>&lt;number&gt;</td><td></td></tr><tr><td>Range(&lt;min&gt;,&lt;max&gt;)</td><td>&lt;number&gt;</td><td>显示为滑动条的浮点数</td></tr><tr><td>Color</td><td>(&lt;number&gt;,&lt;number&gt;,&lt;number&gt;,&lt;number&gt;)</td><td></td></tr><tr><td>Vector</td><td>(&lt;number&gt;,&lt;number&gt;,&lt;number&gt;,&lt;number&gt;)</td><td></td></tr><tr><td>2D</td><td>“&lt;defaulttexture&gt;”</td><td></td></tr><tr><td>2DArray</td><td>“”</td><td></td></tr><tr><td>3D</td><td>“”</td><td></td></tr><tr><td>Cube</td><td>“”</td><td></td></tr><tr><td>CubeArray</td><td>“”</td><td></td></tr></tbody></table><ul><li><p><strong>number、min、max</strong></p><p>任意数值</p></li><li><p><strong>defaulttexture</strong></p><p>内置纹理</p><ul><li>留空：默认为 gray</li><li>white：（RGBA：1,1,1,1）</li><li>black：（RGBA：0,0,0,0）</li><li>gray：（RGBA：0.5,0.5,0.5,0.5）</li><li>bump：（RGBA：0.5,0.5,1,0.5）</li><li>red：（RGBA：1,0,0,0）</li></ul></li></ul><h3 id="支持的-attribute"><a href="#支持的-attribute" class="headerlink" title="支持的 attribute"></a>支持的 attribute</h3><ul><li>[Gamma] - 指示浮点数或矢量属性使用 sRGB 值，这意味着如果项目中的颜色空间需要，则它必须与其他 sRGB 值一起转换。</li><li>[HDR] - 指示纹理或颜色属性使用高动态范围 (HDR) 值。</li><li>[HideInInspector] - 指示检视面板中隐藏该属性值。</li><li>[MainTexture] - 表示该属性为材质主纹理，否则默认纹理为_MainTex，多次使用选首个。</li><li>[MainColor] - 表示该属性为材质主色，否则默认主色为_Color，多次使用选首个。</li><li>[NoScaleOffset] - 指示检视面板隐藏此纹理属性的平铺和偏移字段。</li><li>[Normal] - 指示该纹理属性需要法线贴图。</li><li>[PerRendererData] - 指示纹理属性将来自每个渲染器数据，形式为 MaterialPropertyBlock。</li></ul><h4 id="自定义-attribute"><a href="#自定义-attribute" class="headerlink" title="自定义 attribute"></a>自定义 attribute</h4><p><a href="https://docs.unity.cn/cn/2022.3/ScriptReference/MaterialPropertyDrawer.html">https://docs.unity.cn/cn/2022.3/ScriptReference/MaterialPropertyDrawer.html</a></p><p>允许通过 MaterialPropertyDrawer 创建自定义 attribute，可实现修改属性的显示效果或其他特殊功能。</p><p>内置的 MaterialPropertyDrawer 实现有以下几种：</p><ul><li>[Toggle]：将浮点数属性显示为开关，打开时会自动启用材质中对应的着色器关键字，需配合 shader_feature 使用。默认关键字为“{propertieName}_ON”全大写，也可用括号参数自定义关键字。</li><li>[ToggleOff]：类似 Toggle 的取反版本，默认关键字为“{propertieName}_OFF”全大写。</li><li>[KeywordEnum(enum1,enum2…)]：类似 Toggle 的多选项版本，将浮点属性显示为弹出菜单，浮点的值将决定启动的关键字，关键字为“{propertieName}_{enumName}”全大写，最多 9 个。</li><li>[Enum(enum1,number1,enum2,number2…)]：将浮点属性显示为弹出菜单，按枚举值给浮点设置数值。</li><li>[PowerSlider(number)]：将 Range 属性的滑动条改为非线性滑动条。</li><li>[IntRange]：将 Range 属性的滑动条改为整数滑动条。</li></ul><h2 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Tags<br>&#123;<br>    &quot;&lt;key&gt;&quot; = &quot;&lt;value&gt;&quot;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SubShader-专用"><a href="#SubShader-专用" class="headerlink" title="SubShader 专用"></a>SubShader 专用</h3><ul><li><p><strong>RenderPipeline</strong></p><p>告知 Unity 该 Shader 是否支持 Unity 预定义的几个渲染管线。</p><ul><li>UniversalRenderPipeline：支持 URP</li><li>HighDefinitionRenderPipeline：支持 HDRP</li><li>其他值或未声明：不兼容相关管线</li></ul></li><li><p><strong>Queue</strong></p><p>定义渲染顺序，数字越大越靠后，可用加减运算进一步调整。</p><ul><li>Background：1000</li><li>Geometry：2000，不透明物体</li><li>AlphaTest：2450</li><li>Transparent：3000，透明物体</li><li>Overlay：3000</li></ul></li><li><p><strong>RenderType</strong></p><p><a href="https://docs.unity.cn/cn/2019.4/Manual/SL-ShaderReplacement.html">https://docs.unity.cn/cn/2019.4/Manual/SL-ShaderReplacement.html</a></p><p>给 SubShader 分类，用于实现着色器替换功能，仅内置渲染管线支持。</p></li><li><p><strong>ForceNoShadowCasting</strong></p><p>禁用 Shader 投射或接收阴影，具体不同管线效果不一样，一般用于配合着色器替换功能使用。</p><ul><li>True</li><li>False</li></ul></li><li><p><strong>DisableBatching</strong></p><p>禁用动态批处理功能。因为动态批处理会将所有几何体转为世界空间，这对需要物体空间的 Shader 将产生负面影响，所以要关闭。</p><ul><li>True</li><li>False</li><li>LODFading：当几何体使用 LODGroup 功能且 Fade Mode 不为 None 时生效。</li></ul></li><li><p><strong>IgnoreProjector</strong></p><p>使几何体不受内置渲染管线的投影器功能的影响，在其他渲染管线中该标签无效。</p><ul><li>True</li><li>False</li></ul></li><li><p><strong>PreviewType</strong></p><p>指明材质在 Inspector 面板中的预览效果。</p><ul><li>Sphere：默认值</li><li>Plane</li><li>Skybox</li></ul></li><li><p><strong>CanUseSpriteAtlas</strong></p><p>在 SpritePacker（已弃用） 功能中，实现警告用户着色器依赖于原始纹理坐标，因此不应将其纹理打包到图集中。</p><ul><li>True：默认值，兼容图集</li><li>Flase：不兼容图集</li></ul></li></ul><h3 id="Pass-专用"><a href="#Pass-专用" class="headerlink" title="Pass 专用"></a>Pass 专用</h3><p>也可在 SubShader 中填写 Pass 的 Tags，这会自动应用到所有 Pass。</p><ul><li><p><strong>LightMode</strong></p><p>不同的渲染任务（如渲染深度图，向前或延迟渲染）一般需要使用一些特定 Pass，所以要用该标签声明这些特殊 Pass ，这样 Unity 渲染时就知道此时要调用 Shader 中的哪些 Pass。</p><p>该标签与多 Pass 功能存在关联，使用标签通常会导致无法使用多 Pass 功能，反之如果不提供该标签则默认为使用多 Pass 功能，按序多次渲染，具体还是要看渲染管线的实现方式。</p><p>具体标签值要根据渲染管线填写。</p><p><a href="https://docs.unity.cn/Packages/com.unity.render-pipelines.universal@11.0/manual/urp-shaders/urp-shaderlab-pass-tags.html#urp-pass-tags-lightmode">渲染管线 (URP) 中的 LightMode 通道标签</a></p></li></ul><h3 id="自定义-Tags"><a href="#自定义-Tags" class="headerlink" title="自定义 Tags"></a>自定义 Tags</h3><p>可自由填写键值对，然后用 Material.GetTag 读取。</p><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><ul><li>在 SubShader 中填写 Commands 会自动应用到所有 Pass。</li><li>命令的参数实际是数字，故也可用 Propertie 表示值，如 <code>ZTest [&lt;propertieName&gt;]</code>，从而实现程序化控制。</li></ul><h3 id="颜色输出相关"><a href="#颜色输出相关" class="headerlink" title="颜色输出相关"></a>颜色输出相关</h3><h4 id="Blend"><a href="#Blend" class="headerlink" title="Blend"></a>Blend</h4><p>确定 GPU 如何将片元着色器的输出与渲染目标进行合并。</p><p>默认混合公式：$finalValue &#x3D; sourceFactor * sourceValue + destinationFactor * destinationValue$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">//默认值，禁用混合。<br>Blend [&lt;renderTarget&gt;] Off<br>// 设置当前输出值和缓冲区值的各自系数<br>Blend [&lt;renderTarget&gt;] &lt;sourceFactor&gt; &lt;destinationFactor&gt;<br>//将RGB与Alpha的系数分开设置<br>Blend [&lt;renderTarget&gt;] &lt;sourceRGBFactor&gt; &lt;destinationRGBFactor&gt;, &lt;sourceAlphaFactor&gt; &lt;destinationAlphaFactor&gt;<br></code></pre></td></tr></table></figure><ul><li><p><strong>factor</strong>（<code>UnityEngine.Rendering.BlendMode</code>）</p><p>混合系数。</p><ul><li>One（1）</li><li>Zero（0）</li><li>SrcColor（3）</li><li>SrcAlpha（5）</li><li>DstColor（2）</li><li>DstAlpha（7）</li><li>OneMinusSrcColor（6）</li><li>OneMinusSrcAlpha（10）</li><li>OneMinusDstColor（4）</li><li>OneMinusDstAlpha（8）</li></ul></li><li><p><strong>renderTarget</strong></p><p>渲染目标索引，0-7 的整数。</p></li></ul><h4 id="BlendOp"><a href="#BlendOp" class="headerlink" title="BlendOp"></a>BlendOp</h4><p><a href="https://docs.unity.cn/cn/current/Manual/SL-BlendOp.html">https://docs.unity.cn/cn/current/Manual/SL-BlendOp.html</a></p><p>指定 Blend 命令使用的混合操作。使用该命令时必须同时使用 Blend 命令。并非所有设备都支持所有混合操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">BlendOp &lt;operation&gt;<br></code></pre></td></tr></table></figure><ul><li><p><strong>operation</strong>（<code>UnityEngine.Rendering.BlendOp</code>）</p><ul><li>Add（0）：默认值，将源和目标相加。</li><li>…</li></ul></li></ul><h4 id="ColorMask"><a href="#ColorMask" class="headerlink" title="ColorMask"></a>ColorMask</h4><p>颜色通道写入遮罩，可用于禁用部分通道的写入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">ColorMask &lt;channels&gt; [&lt;renderTarget&gt;]<br></code></pre></td></tr></table></figure><ul><li><p><strong>channels</strong>（<code>UnityEngine.Rendering.ColorWriteMask</code>）</p><p>可写入的通道，其中 RGBA 4 项可任意组合使用，如默认值为 RGBA。</p><ul><li>0（0）：全通道不可写入</li><li>R（8）：仅 R 通道</li><li>G（4）</li><li>B（2）</li><li>A（1）</li></ul></li><li><p><strong>renderTarget</strong></p><p>渲染目标索引，0-7 的整数。</p></li></ul><h3 id="模板深度相关"><a href="#模板深度相关" class="headerlink" title="模板深度相关"></a>模板深度相关</h3><h4 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h4><p>设置深度偏移，负数将减小深度，使离摄像机更近。</p><p>偏移公式：$offset &#x3D; (m * factor) + (r * units)$</p><ul><li>m：多边形相对摄像机 z 轴的斜率，如果正视摄像机即与近平面平行则为 0。</li><li>r：其是使深度差异可分辩的最小值，这是由渲染设备定义的一个常量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Offset &lt;factor&gt;, &lt;units&gt;<br></code></pre></td></tr></table></figure><ul><li>factor：-1 到 1 的小数。</li><li>units：-1 到 1 的小数。</li></ul><h4 id="Stencil"><a href="#Stencil" class="headerlink" title="Stencil"></a>Stencil</h4><p>如何进行模板测试，测试通过后将进入深度测试，否则丢弃片元。</p><ul><li>所有遮罩均是指哪些位可操作，并不是直接与值并运算，所以如写入遮罩为 0，表示所有位都无法写入，而不是写入 0。</li><li>部分参数支持 Back 和 Front 的后缀，从而实现对正反片元单独处理，但如果提供了无后缀版本，则后缀版本被覆盖。</li></ul><p>测试公式：$\text{(ref &amp; readMask) comparisonFunction (stencilBufferValue &amp; readMask)}$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Stencil<br>&#123;<br>    [Ref &lt;ref&gt;] //表明引用值，0-255的整数，默认为0<br>    [ReadMask &lt;readMask&gt;] //缓冲区读取遮罩，0-255的整数，默认为255<br>    [WriteMask &lt;writeMask&gt;] //缓冲区写入遮罩，0-255的整数，默认为255<br>    [Comp[&#123;Back | Fornt&#125;] &lt;comparisonOperationFront&gt;] // 定义如何测试<br>    [&lt;event&gt; &lt;operation&gt;] // 定义测试结束后的处理事件<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>comparisonFunction</strong></p><p>可用 C#中的 Rendering.CompareFunction 表示。</p><table><thead><tr><th>值</th><th>对应数值</th><th>描述</th></tr></thead><tbody><tr><td>Never</td><td>1</td><td>比较永远失败，即从不渲染像素。</td></tr><tr><td>Less</td><td>2</td><td>参考值小于缓冲区值时通过。</td></tr><tr><td>Equal</td><td>3</td><td></td></tr><tr><td>LEqual</td><td>4</td><td></td></tr><tr><td>Greater</td><td>5</td><td></td></tr><tr><td>NotEqual</td><td>6</td><td></td></tr><tr><td>GEqual</td><td>7</td><td></td></tr><tr><td>Always</td><td>8</td><td>默认值，比较始终成功。</td></tr></tbody></table></li><li><p><strong>event</strong></p><p>可添加 Back 或 Front 后缀。</p><ul><li>Pass：当通过模板测试和深度测试时</li><li>Fail：当未通过模板测试时</li><li>ZFail：当通过模板测试，但未通过深度测试时</li></ul></li><li><p><strong>operation</strong></p><p>可用 C#中的 Rendering.Rendering.StencilOp 表示。</p><table><thead><tr><th>值</th><th>对应数值</th><th>描述</th></tr></thead><tbody><tr><td>Keep</td><td>0</td><td>默认值，保持模板缓冲区中的内容。</td></tr><tr><td>Zero</td><td>1</td><td>将 0 写入模板缓冲区。</td></tr><tr><td>Replace</td><td>2</td><td>将参考值写入模板缓冲区。</td></tr><tr><td>Invert</td><td>3</td><td>将缓冲区中的值的所有位取反。</td></tr><tr><td>IncrSat</td><td>4</td><td>递增缓冲区中的值，上限 255。</td></tr><tr><td>DecrSat</td><td>5</td><td>递减缓冲区中的值，下限 0。</td></tr><tr><td>IncrWrap</td><td>6</td><td>递增缓冲区中的值，如果当前值为 255 则变为 0。</td></tr><tr><td>IncrWrap</td><td>7</td><td>递减缓冲区中的值，如果当前值为 0 则变为 255。</td></tr></tbody></table></li></ul><h4 id="ZClip"><a href="#ZClip" class="headerlink" title="ZClip"></a>ZClip</h4><p>如何处理近平面和远平面的片元。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">ZClip &lt;state&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>state</strong><ul><li>True：默认值，超出近平面或远平面的片元直接丢弃。</li><li>False：夹紧超出近平面或远平面的片元。</li></ul></li></ul><h4 id="ZTest"><a href="#ZTest" class="headerlink" title="ZTest"></a>ZTest</h4><p>如何进行深度测试，片元越近深度值越小，越远深度值越大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">ZTest &lt;operation&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>operation</strong><ul><li>Less</li><li>LEqual：默认值，当前深度值小于等于缓冲区的值时渲染，当前几何体位于现有几何体的前面或等距。</li><li>Equal</li><li>GEqual</li><li>NotEqual</li><li>Always：不进行深度测试，永远绘制。</li></ul></li></ul><h4 id="ZWrite"><a href="#ZWrite" class="headerlink" title="ZWrite"></a>ZWrite</h4><p>是否写入深度值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">ZTest &lt;state&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>state</strong><ul><li>On：默认值，写入深度值。</li><li>Off</li></ul></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="AlphaToMask"><a href="#AlphaToMask" class="headerlink" title="AlphaToMask"></a>AlphaToMask</h4><p><a href="https://docs.unity.cn/cn/current/Manual/SL-AlphaToMask.html">https://docs.unity.cn/cn/current/Manual/SL-AlphaToMask.html</a></p><p>启用或禁用 GPU 上的 alpha-to-coverage 模式，可以减少将多样本抗锯齿 (MSAA) 与使用 Alpha 测试的着色器（如植被着色器）一起使用时出现的过度锯齿。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">AlphaToMask &lt;state&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>state</strong><ul><li>On：启用 alpha-to-coverage 模式。</li><li>Off：禁用 alpha-to-coverage 模式。</li></ul></li></ul><h4 id="Conservative"><a href="#Conservative" class="headerlink" title="Conservative"></a>Conservative</h4><p>是否启用保守光栅化。正常光栅化在确定像素被三角面覆盖的同时还会判断覆盖范围是否足够，保守光栅化则只要被覆盖就光栅化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Conservative &lt;state&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>state</strong><ul><li>True：启用保守光栅化。</li><li>False：默认值，禁用保守光栅化。</li></ul></li></ul><h4 id="Cull"><a href="#Cull" class="headerlink" title="Cull"></a>Cull</h4><p>设置多边形的正反面剔除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Cull &lt;state&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>state</strong><ul><li>Back：默认值，剔除背面。</li><li>Front：剔除前面。</li><li>Off：不剔除。</li></ul></li></ul><h2 id="PassCode"><a href="#PassCode" class="headerlink" title="PassCode"></a>PassCode</h2><p>见 PassCode 语法笔记。</p>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
      <category>Unity文档笔记</category>
      
      <category>图形</category>
      
      <category>着色器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【计算机】常见 CPU 指令集发展及其关系</title>
    <link href="/posts/1481637271.html"/>
    <url>/posts/1481637271.html</url>
    
    <content type="html"><![CDATA[<h1 id="【计算机】常见-CPU-指令集发展及其关系"><a href="#【计算机】常见-CPU-指令集发展及其关系" class="headerlink" title="【计算机】常见 CPU 指令集发展及其关系"></a>【计算机】常见 CPU 指令集发展及其关系</h1><h2 id="CPU-与指令集"><a href="#CPU-与指令集" class="headerlink" title="CPU 与指令集"></a>CPU 与指令集</h2><p>任何计算机都有一块 CPU，CPU 有其支持的指令集，根据指令集间的兼容性，一种 CPU 可能同时支持多种指令集。</p><p>指令集中记录了 CPU 的机器代码格式，由于很多编译性语言最终都是要编译成机器代码才能运行，所以编译时必须指明目标指令集，在 IDE 中也能看到对应选项。</p><p>使用不同指令集的平台间软件通常无法兼容，所以跨平台时需要重新打包程序，或者也有同时打包多份不同指令集的程序塞在一个软件中的方法，以便平台按需选取。</p><p>这也是为什么 Github 中很多支持跨平台的软件，其发布时都会提供好多种不同指令集后缀的版本，或者不写清指令集但体积巨大的版本。</p><h2 id="x86-系列"><a href="#x86-系列" class="headerlink" title="x86 系列"></a>x86 系列</h2><h3 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h3><p>x86 架构由 Intel 公司发明，首次使用在其 1978 年推出的 Intel 8086 处理器中，且后来逐渐成为了个人电脑的标准架构。</p><p>最早使用该架构的系列处理器（如 Intel 8086、80186、80286 等）都是以数字表示，且都采用了 86 作为后缀，所以该架构也就称为 x86 架构，其中 x 是为了表示同系列有多款 CPU 使用该架构。</p><h3 id="x86、i386、IA-32"><a href="#x86、i386、IA-32" class="headerlink" title="x86、i386、IA-32"></a>x86、i386、IA-32</h3><p>最早的 x86 是 16 位的，但从 80386 开始被经改进成为了 32 位架构。</p><p>对于这升级后的一新架构，Intel 将其称为 IA-32（Intel Architecture 32bit）；而在 Linux 平台则习惯将其称为 i386，因为这是从第三代 86 系列处理器（80386）开始的。</p><p>如今 16 位的 x86 已经淘汰，所以通常我们也会直接称呼 x86 来泛指其 32 位版本。</p><h3 id="IA-64"><a href="#IA-64" class="headerlink" title="IA-64"></a>IA-64</h3><p>在 1989 年，惠普认为现有的 RISC 架构存在性能瓶颈，于是在 1994 年与 Intel 开始合作设计一款全新的架构 IA-64。Intel 很看好这一新架构，投入了大量开发资源，并在 2001 年推出第一代基于 IA-64 的安腾处理器。</p><p>但该架构有一个致命缺陷，那就是和之前大火的 x86 架构不能兼容，且旧架构通过增强超标量的方法足以赶上 IA-64 的优势，所以该架构很快就退出市场了，2017 年之后 Intel 再也没发布过基于 IA-64 的新处理器。</p><h3 id="x86-64、x64、AMD64、Intel-64"><a href="#x86-64、x64、AMD64、Intel-64" class="headerlink" title="x86_64、x64、AMD64、Intel 64"></a>x86_64、x64、AMD64、Intel 64</h3><p>在 1976 年时，Intel 公司将 8080 架构（x86 的前身）的微指令授权给了 AMD 公司，导致 AMD 公司拥有在 x86 基础上继续开发的权力。</p><p>之后除开 Intel，AMD 公司也在进行 64 位架构的开发。其吸取了 IA-64 的失败，选择在 x86 的基础上继续开发，并于 1999 设计出了新的 AMD64 架构。</p><p>AMD64 架构可以说就是 x86 架构的 64 位版本，所以与之兼容，也为了给 Intel 留点面子，所以该架构又叫 x86_64 架构，简称 x64。</p><p>后来 Intel 公司也开始采用该架构，并将其直接将称为 Intel 64。</p><h2 id="ARM-系列"><a href="#ARM-系列" class="headerlink" title="ARM 系列"></a>ARM 系列</h2><p>ARM 架构是 ARM 公司推出的指令集，过去也被称为进阶精简指令集机器（Advanced RISC Machine），其设计简单且功耗低，所以广泛使用在嵌入式和移动通讯领域。</p><p>ARM 架构随着时代发展发布了多个版本，最早于 1985 年开发出了第一代 ARM 架构（ARMv1），次年又开发了第二代 ARM 架构（ARMv2） 并开始量产。</p><p>在早期 ARM 的指令集架构一直以“ARMv{版本号}”的形式命名。但为了顺应市场发展，从 ARMv6 开始，又会以“ARMv{版本号}-{型号}”的命名方式推出多个分支指令集架构，以应对不同的使用环境。而从 ARMv7 开始则完全采用后一种命名方式，所以说此时实际已不存在名为 ARMv7 的某一特定架构，ARMv7 是对第七代 ARM 架构的统称。</p><p>相应的，之后的处理器也改为了“Cortex-{型号}{版本号}”的命名方式，比如曾经手机主流的 Cortex-A7 处理器就是基于 ARMv7-A 指令集架构制作的。</p><p>虽然 ARM 架构的版本众多，但 ARM 架构具有版本兼容性，采用旧版本指令集构建的软件在搭载新版本指令集的处理器中依然可用，从而保障了它的发展生命力。</p><p>今天最多听到 ARM 架构的地方都是在 Android 开发上，Android 开发中通常用 ABI 来描述程序集所用框架，虽然 ABI 并不是专指指令集架构但也有包含的关系，所以考虑常用性这里就借用 ABI 介绍指令集好了。</p><h3 id="armeabi、ARMv5、ARMv6"><a href="#armeabi、ARMv5、ARMv6" class="headerlink" title="armeabi、ARMv5、ARMv6"></a>armeabi、ARMv5、ARMv6</h3><p>armeabi 是最早手机所用的 ABI，其对应 ARMv5 架构 ，因为兼容性的原因后续的 ARMv6 等架构处理器也可使用，不过现今该架构已被 Android NDK 弃用。</p><h3 id="armeabi-v7a、ARMv7、ARMv7-A"><a href="#armeabi-v7a、ARMv7、ARMv7-A" class="headerlink" title="armeabi-v7a、ARMv7、ARMv7-A"></a>armeabi-v7a、ARMv7、ARMv7-A</h3><p>armeabi-v7a 是 armeabi 架构的升级版，其中 v7a 就是指其对应架构为 ARMv7-A 。其一个显著的特点是增加了硬件浮点运算的功能，所以大幅提高了性能，是过去非常主流的手机架构。</p><p>不过 ARMv7-A 是 32 位指令集，在如今的 64 位时代已然过时，目前市面上只有少部分手机还在使用。</p><h3 id="arm64-v8a、ARM64、ARMv8-A"><a href="#arm64-v8a、ARM64、ARMv8-A" class="headerlink" title="arm64-v8a、ARM64、ARMv8-A"></a>arm64-v8a、ARM64、ARMv8-A</h3><p>arm64-v8a 对应 ARMv8-A 架构，其名称中的 64 宣布了又一个里程碑式的进步，从此刻开始 ARM 架构也步入了 64 位时代，并且从 2019 年 8 月 1 日起 Google Play 就开始强制要求所以软件都必须支持 64 位设备，即支持 arm64-v8a。</p><p>所以该架构是目前手机最主流的架构。</p><h2 id="mips-系列"><a href="#mips-系列" class="headerlink" title="mips 系列"></a>mips 系列</h2><p>在查资料时发现的另一种指令集系列，很多跨平台软件的发布类型中除开 x86 和 ARM 就剩它了，但生活中并没见过，而且其和 armeabi 一样被 Android NDK 弃用了，显然应该是某种过时的处理器架构，所以此处不进行讨论。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.zhihu.com/question/63040129">计算机中 x32、x64、x86 是什么意思？</a></li><li><a href="https://www.zhihu.com/question/438625652">为什么 64 位是 x64 而 32 位是 x86？</a></li><li><a href="https://www.zhihu.com/question/19573226">i386 和 x86-64 有什么区别？</a></li><li><a href="https://baike.baidu.com/item/%E5%AE%89%E8%85%BE%E5%A4%84%E7%90%86%E5%99%A8">百科-安腾处理器</a></li><li><a href="https://www.zhihu.com/question/397027038">Intel 为什么不取消 AMD 的 X86 架构授权？</a></li><li><a href="https://baike.baidu.com/item/X86-64/1352293">百科-X86-64</a></li><li><a href="https://baike.baidu.com/item/ARM%E6%9E%B6%E6%9E%84">百科-ARM 架构</a></li><li><a href="https://zhuanlan.zhihu.com/p/362648496">armv7-A 系列 0 - ARM 处理器架构发展史</a></li><li><a href="https://en.wikipedia.org/wiki/List_of_ARM_processors">List of ARM processors</a></li><li><a href="https://developer.android.google.cn/ndk/guides/abis?hl=zh-cn">Android ABI</a></li><li><a href="https://developer.android.com/google/play/requirements/64-bit">支持 64 位架构</a></li><li><a href="https://docs.unity3d.com/2020.1/Documentation/ScriptReference/AndroidArchitecture.html">UnityAPI AndroidArchitecture</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】热更新原理与 Xlua 配置</title>
    <link href="/posts/4133014859.html"/>
    <url>/posts/4133014859.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】热更新原理与-Xlua-配置"><a href="#【Unity】热更新原理与-Xlua-配置" class="headerlink" title="【Unity】热更新原理与 Xlua 配置"></a>【Unity】热更新原理与 Xlua 配置</h1><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p>直接理解即是让代码可以像资源包一样被运行时更新。当然它其实还一个名称叫热修复，即实现不重新打包项目也能把 Bug 修好，这也正是它常用的地方。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li><p>C# 无法直接热更新</p><p>C# 是编译型语言，需要先编译成 IL 再送到虚拟机里才可运行。部分平台不支持 C# 编译器的使用,所以没法通过直接重新编译 C# 代码来实现热更新。</p></li><li><p>lua 可以轻松热更新</p><p>lua 是解释性语言，不需要编译，直接在代码中传递字符串给解释器就能运行，所以可以将其作为文本资源对待，更新起来非常轻松。</p></li><li><p>不建议完全使用 lua 编程</p><p>解释性语言执行效率低，且 Unity 是 C# 编程环境，开发和学习的难度都会大幅提升。</p></li><li><p>在 C# 中混合 lua 实现热更新</p><p>例如在每个 C# 函数的开头加一句判断，如果资源文件里有该函数对应的 lua 文件，才调用 lua 代码，否则说明还不需要热更新，正常调用后续的 C# 代码就行。这样的话只有需要修 Bug 的时候才要编写 lua 代码，否则正常情况可以一直使用 C# 开发。</p></li><li><p>手动混合 C# 和 lua 过于麻烦</p><p>必须要求每个函数开头都要加上一段代码，想想就可怕，这工作量太大了，视觉效果也不美观。如果能实现自动把这些代码写上去且只在打包项目时才写上就好了。</p></li><li><p>通过 Mono.Cecil 实现 C# 库的自动修改</p><p>C# 首先会被打包成 IL 库，最后才被 IL2CPP 编译成平台代码，IL 的状态下反编译非常容易。利用 Mono.Cecil 我们可以通过程序对这些 IL 库的内容进行调整，比如实现自动修改里面每个函数的代码，从而实现上述需求。</p></li><li><p>使用 Xlua 实现上述需求</p><p>Xlua 已经完成了以上需求的实现，并且免费开源，我们可以直接白嫖，又有大厂加持，安全稳定，不说了开冲。</p></li></ol><h2 id="Xlua-热更新"><a href="#Xlua-热更新" class="headerlink" title="Xlua 热更新"></a>Xlua 热更新</h2><p>Xlua 在官方的介绍里说是为 Unity 增加了使用 lua 脚本的能力，所以他的功能其实比较多，热更新只是其中一个。在官方文档里，热更新又叫热补丁，热补丁的文档链接如下，必看。<br><a href="https://github.com/Tencent/xLua/blob/master/Assets/XLua/Doc/hotfix.md">https://github.com/Tencent/xLua/blob/master/Assets/XLua/Doc/hotfix.md</a></p><h3 id="使用简介"><a href="#使用简介" class="headerlink" title="使用简介"></a>使用简介</h3><ol><li>安装方式不说了，直接去他的仓库看。 <a href="https://github.com/Tencent/xLua">https://github.com/Tencent/xLua</a></li><li>为项目添加 HOTFIX_ENABLE 宏，从而打开热更新功能。</li><li>把所有你需要热更新的代码打上[Hotfix]标签，具体看文档，注意方式一高版本 Unity 用不了。</li><li>搞个单例类，在里面开一个 lua 虚拟机，在里面加载一个文本文件给虚拟机。</li><li>这个加载上来的文本文件就是写 lua 热更新代码的地方，即出了 bug 需要替换上的新代码。</li><li>lua 热更新代码里主要是调用 xlua.hotfix 函数实现代码替换，具体看文档。</li><li>点击菜单项 XLua&#x2F;Generate Code，然后直接打包游戏就行，Xlua 会自动按之前说过的原理修改标记好函数使其支持热更新。</li></ol><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li><p>高版本 Unity 中所有打标签方式都请使用文档中打[Hotfix]标签的方式二。</p></li><li><p>使用 IL2CPP 时，仅 lua 中用到的类有可能会被字节代码剥离程序删除。</p><p>IL2CPP 的过程中会自动删除没有被使用无效代码，而 lua 中调用 C#代码的方式有点类似于反射，这种间接的类型访问方式无法被 IL2CPP 程序识别，因而会导致相关代码被错误的剥离。</p><p>推荐打上[LuaCallCSharp]或[ReflectionUse]标签来解决这个问题，这样 XLua 便能自动把这些类型配置为不可被剥离。</p></li><li><p>GenerateCode 前建议先调用 ClearGenerateCode，这样才能保证生成的文件确实和代码中设置的一致。</p></li></ol><h2 id="其他猜想"><a href="#其他猜想" class="headerlink" title="其他猜想"></a>其他猜想</h2><ol><li><p>为什么 C# 变 C++ 代码后，代码结构剧变，lua 也能正常调用？</p><p>C# 访问函数的方式不是直接使用地址，而是先用符号(函数名)去检索地址，然后再跳转到该地址。IL2CPP 中虽然 C# 代码被转换，但这种访问方式被保留了下来，其符号信息就存在 global-metadata.dat 文件中，所以 lua 使用 C# 中的名称也能正常访问。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>抛开细节不谈还是蛮简单的，不说了学 lua 去了。</p>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】图形渲染瓶颈与批处理优化</title>
    <link href="/posts/4239874620.html"/>
    <url>/posts/4239874620.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】图形渲染瓶颈与批处理优化"><a href="#【Unity】图形渲染瓶颈与批处理优化" class="headerlink" title="【Unity】图形渲染瓶颈与批处理优化"></a>【Unity】图形渲染瓶颈与批处理优化</h1><h2 id="图形渲染"><a href="#图形渲染" class="headerlink" title="图形渲染"></a>图形渲染</h2><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>显卡的工作方式并非连续的，一般分三步。</p><ol><li>上传更新渲染数据至显存</li><li>设置显卡的渲染管线状态</li><li>启动绘制并等待绘制结果</li></ol><h3 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h3><p>由于显卡是大规模并行计算，绘制几个或几千个三角面在速度上基本没有区别，这时候瓶颈就容易出现在工作方式中第一第二点上。</p><ol><li><p>内存到显存的传输是有代价的</p><p>如果对比过 Unity 的作业系统就会发现一点，对应一些数据量大但计算量小的任务，使用计算着色器的速度反而比作业系统要慢的多。</p><p>原因就是因为计算量小导致显卡的强大计算能力没法体现，结果时间全花在了大量数据的传输上，不如直接用 CPU 就地解决。</p></li><li><p>处理器与显卡的沟通是有代价的</p><p>此时数据已经传输到了显存中，但具体使用那些数据，哪种绘制方式，这些都需要进行设置，这就需要 CPU 与 GPU 进行沟通。</p><p>同第一点，这是两种不同的硬件，交流本就有延迟，再加上 GPU 因此切换内部状态的时间，那就更长了。</p></li></ol><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p>由此可见我们应在两个方向上进行优化</p><ol><li>减少显存中数据的更新频率</li><li>减少显卡中工作状态的切换</li></ol><p>诸如网格，纹理，着色器，常量缓冲区等这些都是需要存储在显存中的，因此应仅可能减少其内容的修改。</p><p>如果可以，尽可能多物体共用这些资源，这不仅仅可以减少缓存的使用，还可以减少调整渲染状态的次数。</p><h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><p>最原始的渲染方案，我们可能每个物体都要单独渲染一次，即使不考虑显存大小的问题，我们每次也都要重新设置渲染用的目标数据和状态，还没正式让 GPU 工作，仅设置 GPU 的环境就花费了很多时间。</p><p>然后当我们正式启动 GPU，结果因为单个物体的计算量较小，GPU 瞬间就好了，这时又要进入缓慢的准备阶段，让 GPU 一直空等着。</p><p>这很类似早期的单道批处理操作系统的问题，IO 时间与处理速度不匹配，所以我们要增加处理速度的时间并减少 IO 的次数。</p><p>比如我们可以合并多个物体的渲染数据，并确保他们可以使用同样的着色器和渲染管线状态，从而将它们变成一个完整单一的大型物体。</p><p>此时渲染这一个物体依然可以变相实现渲染多个物体的效果，但每个物体间不再有准备时间，GPU 也能跑更长的时间了，CPU 不再需要动不动停下来指挥 GPU 做事，并行能力也大幅提高。</p><h2 id="渲染批处理"><a href="#渲染批处理" class="headerlink" title="渲染批处理"></a>渲染批处理</h2><p>渲染批处理即是上述优化方案的具体实现。它将有共通属性的多个物体看成同一组甚至同一个，以批为单位进行渲染。</p><p>在 Unity 中渲染模型需要两种图形资源，材质+网格：</p><ul><li>材质包含了常量缓冲区，渲染状态，着色器的数据。</li><li>网格包含了顶点、索引缓冲区的数据。</li></ul><p>物体能被一起渲染，说明他们用到的数据都一样，也因此如果希望物体能被识别为同一批，只要确保他们用到的材质和网格一样即可。</p><h3 id="材质的共用"><a href="#材质的共用" class="headerlink" title="材质的共用"></a>材质的共用</h3><ul><li><p>使用纹理图集功能</p><p>对于因纹理不同而导致材质差异的情况，可以尝试用该功能将纹理合并成一个，接着只要在网格的 UV 上进行特殊处理即可保留原功能的同时合并材质。</p><p>因为 UI 和 Sprite 是自动生成的网格，所以可以自动兼容 Unity 中的图集设置，简单设置就可轻松获得性能优势。</p></li><li><p>使用 GPU 实例化功能</p><p>GPU 实例化是一种特殊的渲染方式，由底层图形引擎提供，可以实现一次显卡调用但自动保留环境的同时多次绘制同一网格，同时会在着色器阶段传递这些网格的绘制编号。</p><p>利用这些编号做区分我们便可为不同的网格采取不同的绘制数据，从而实现一次调用却好像使用了不同材质多次绘制的效果。</p></li></ul><h3 id="网格的共用"><a href="#网格的共用" class="headerlink" title="网格的共用"></a>网格的共用</h3><ul><li><p>静态批处理</p><p>提前自动将选择的多个网格合并成一个“大网格”，所有原本的模型将共享该网格中的顶点索引缓冲区等，这样绘制时只要直接绘制一次这个大网格即可。</p><p>当然该网格的渲染也不一定是完全正向的，因为共用一个大网格也意味着没法进行剔除等操作，过多看不见的三角面被渲染，可能导致得不偿失。</p></li><li><p>动态批处理</p><p>和静态批处理的原理一样，但区别是实时的，所以必须每帧都要考虑重新生成用于批处理的大网格，也因此存在性能问题：生成网格的消耗可能比渲染批处理节省的开销要大。</p><p>因此只能用于小型网格的合并，主要还是用于对过去旧低端设备进行优化，目前并不是太推荐。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】各种操作触发 GC 情况</title>
    <link href="/posts/2970632423.html"/>
    <url>/posts/2970632423.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】各种操作触发-GC-情况"><a href="#【Unity】各种操作触发-GC-情况" class="headerlink" title="【Unity】各种操作触发 GC 情况"></a>【Unity】各种操作触发 GC 情况</h1><p>在 Update 中持续执行下列操作，统计每帧触发 GC 的情况，仅首帧触发 GC 的情况不计入。</p><h2 id="使用-Linq-处理数据"><a href="#使用-Linq-处理数据" class="headerlink" title="使用 Linq 处理数据"></a>使用 Linq 处理数据</h2><p>基本上使用就会分配内存，所以不要用。</p><h2 id="利用-Foreach-遍历容器"><a href="#利用-Foreach-遍历容器" class="headerlink" title="利用 Foreach 遍历容器"></a>利用 Foreach 遍历容器</h2><p>不会分配内存，可以用，但根据不同的迭代器实现，速度可能不如 For 循环。</p><h2 id="将值类型装箱"><a href="#将值类型装箱" class="headerlink" title="将值类型装箱"></a>将值类型装箱</h2><p>会触发内存分配，不要使用。</p><h2 id="使用-enum-做键的字典"><a href="#使用-enum-做键的字典" class="headerlink" title="使用 enum 做键的字典"></a>使用 enum 做键的字典</h2><p>使用 enum 作为键实测并不会触发装箱，查看源代码就会发现，内部已经改为用泛型处理，所以没有内存分配。</p><h2 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h2><p>字符串是引用类型，修改字符串实质是创建了一个新字符串，接着旧字符串将被回收，所以会触发 GC，常见如修改 UI 文字时出现。</p><h2 id="创建委托"><a href="#创建委托" class="headerlink" title="创建委托"></a>创建委托</h2><p>只有使用匿名函数的方式创建时不会分配内存。</p><table><thead><tr><th>创建方式</th><th>是否分配内存</th><th>分配量级</th></tr></thead><tbody><tr><td>静态函数</td><td>是</td><td>1</td></tr><tr><td>成员函数</td><td>是</td><td>1</td></tr><tr><td>局部函数</td><td>是</td><td>1</td></tr><tr><td>匿名函数</td><td>否</td><td>0</td></tr></tbody></table><h2 id="调用匿名函数"><a href="#调用匿名函数" class="headerlink" title="调用匿名函数"></a>调用匿名函数</h2><p>默认情况没有内存分配，但用到对象成员则分配内存加一，触发闭包再加一，避免这些情况。</p><h3 id="在匿名函数内调用其他函数的情况"><a href="#在匿名函数内调用其他函数的情况" class="headerlink" title="在匿名函数内调用其他函数的情况"></a>在匿名函数内调用其他函数的情况</h3><table><thead><tr><th>函数类型</th><th>是否分配内存</th><th>分配量级</th></tr></thead><tbody><tr><td>静态函数</td><td>否</td><td>0</td></tr><tr><td>成员函数</td><td>是</td><td>1</td></tr><tr><td>成员局部函数</td><td>是</td><td>1</td></tr><tr><td>非成员局部函数</td><td>否</td><td>0</td></tr></tbody></table><h3 id="在匿名函数内使用其他变量的情况"><a href="#在匿名函数内使用其他变量的情况" class="headerlink" title="在匿名函数内使用其他变量的情况"></a>在匿名函数内使用其他变量的情况</h3><table><thead><tr><th>变量类型</th><th>是否分配内存</th><th>分配量级</th></tr></thead><tbody><tr><td>对象成员变量</td><td>是</td><td>1</td></tr><tr><td>作用域外变量</td><td>是</td><td>2</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【汇编】寄存器速查</title>
    <link href="/posts/2731825535.html"/>
    <url>/posts/2731825535.html</url>
    
    <content type="html"><![CDATA[<h1 id="【汇编】寄存器速查"><a href="#【汇编】寄存器速查" class="headerlink" title="【汇编】寄存器速查"></a>【汇编】寄存器速查</h1><h2 id="一般存储关键值的寄存器"><a href="#一般存储关键值的寄存器" class="headerlink" title="一般存储关键值的寄存器"></a>一般存储关键值的寄存器</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>rbp</td><td>存储当前函数用于操作局部变量的基本地址</td></tr><tr><td>rsp</td><td>存储栈顶的地址（注意操作方向，入栈实际上是向低地址移动）</td></tr><tr><td>rip</td><td>存储下一个执行指令的地址</td></tr></tbody></table><h2 id="一般用于传值的寄存器"><a href="#一般用于传值的寄存器" class="headerlink" title="一般用于传值的寄存器"></a>一般用于传值的寄存器</h2><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><ol><li>rdi</li><li>rsi</li><li>rdx</li><li>rcx</li><li>r8</li><li>r9</li><li>其他再多的参数将会以入栈的方式传递</li></ol><h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><ol><li>rax</li><li>rdx</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>计算机</category>
      
      <category>汇编</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【汇编】操作码速查</title>
    <link href="/posts/1744230454.html"/>
    <url>/posts/1744230454.html</url>
    
    <content type="html"><![CDATA[<h1 id="【汇编】操作码速查"><a href="#【汇编】操作码速查" class="headerlink" title="【汇编】操作码速查"></a>【汇编】操作码速查</h1><h2 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h2><p>部分指令的执行方式会受结果标志位的影响而导致不同的效果，而大多算术逻辑类的操作都会设置结果标志位，从而以此搭配条件指令来实现一些代码上的逻辑分支，具体情况请参见各操作数的说明。</p><h4 id="涉及到的标志位举例"><a href="#涉及到的标志位举例" class="headerlink" title="涉及到的标志位举例"></a>涉及到的标志位举例</h4><ul><li>SF 结果是否有符号（是否为负数）</li><li>ZF 结果是否为零</li><li>CF 计算中最高位是否发生了进位或借位（可用于判断大小）</li></ul><h2 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h2><h3 id="算术逻辑类"><a href="#算术逻辑类" class="headerlink" title="算术逻辑类"></a>算术逻辑类</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>add</td><td>加法</td></tr><tr><td>sub</td><td>减法</td></tr><tr><td>imul</td><td>有符号乘法</td></tr><tr><td>inc</td><td>加一</td></tr><tr><td>dec</td><td>减一</td></tr><tr><td>xor</td><td>异或</td></tr><tr><td>cmp</td><td>比较目标操作数相对源操作数的大小，仅修改结果标志位</td></tr><tr><td>test</td><td>对操作数进行与运算，仅修改结果标志位</td></tr></tbody></table><h3 id="数据传输类"><a href="#数据传输类" class="headerlink" title="数据传输类"></a>数据传输类</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>mov</td><td>将源操作数指向的值赋值给目操作数</td></tr><tr><td>movzx</td><td>执行mov，位数不匹配时其余位置设0</td></tr><tr><td>cmovz</td><td>结果为0时执行mov</td></tr><tr><td>lea</td><td>将源操作数直接赋值给目操作数</td></tr><tr><td>push</td><td>将目的操作数的值压入栈中</td></tr><tr><td>pop</td><td>出栈并将值赋值到目标操作数</td></tr></tbody></table><h3 id="函数执行类"><a href="#函数执行类" class="headerlink" title="函数执行类"></a>函数执行类</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>call</td><td>调用函数</td></tr><tr><td>ret</td><td>退出函数</td></tr><tr><td>leave</td><td>用于函数末尾的退栈操作，等于mov rsp rbp;pop rbp;</td></tr><tr><td>jmp</td><td>无条件跳转指令执行到目标位置</td></tr><tr><td>ja</td><td>结果无符号大于时执行jmp</td></tr><tr><td>jg</td><td>结果大于时执行jmp</td></tr><tr><td>jng</td><td>结果不大于时执行jmp</td></tr><tr><td>jge</td><td>结果大于或等于时执行jmp</td></tr><tr><td>jnge</td><td>结果不大于或等于时执行jmp</td></tr><tr><td>jz</td><td>结果等于时执行jmp</td></tr></tbody></table><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li>为什么会出现目标和源操作数都一样的情况？<ol><li>获取特定操作数的属性（设置结果标志位）<br>如：test rax rax，相同的数进行与运算等于自身，于是可以根据自身属性设置标志位，并以此让后续的条件指令得以判断操作数是否为0。</li><li>实现一些效率更高的算法<br>如：xor rax rax，相同的数进行异或结果为0，这会使rax被置空，这比mov rax 0效率高。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>计算机</category>
      
      <category>汇编</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Web】Hexo 使用笔记</title>
    <link href="/posts/3410375722.html"/>
    <url>/posts/3410375722.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Web】Hexo-使用笔记"><a href="#【Web】Hexo-使用笔记" class="headerlink" title="【Web】Hexo 使用笔记"></a>【Web】Hexo 使用笔记</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>_config.yml</td><td>网站的配置信息</td></tr><tr><td>themes</td><td>主题文件夹</td></tr><tr><td>scaffolds</td><td>模板文件夹</td></tr><tr><td>scripts</td><td>脚本文件夹</td></tr><tr><td>source</td><td>资源文件夹</td></tr><tr><td>source&#x2F;_drafts</td><td>草稿文件夹</td></tr><tr><td>source&#x2F;_posts</td><td>发布文件夹</td></tr></tbody></table><h3 id="文章存储"><a href="#文章存储" class="headerlink" title="文章存储"></a>文章存储</h3><p>文章一般存放在“source&#x2F;_drafts”和“source&#x2F;_posts”文件夹，两者分别对应文章的两种状态：草稿和发布。</p><p>存储为草稿状态的文章默认是不在网站显示的，可通过修改网站配置“render_drafts”更改。</p><p>只要将 md 文件放入这些文件夹即可被 Hexo 识别到。</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>布局即是创建文章所用的模板文件，其统一存放在 scaffolds 文件夹，可用_config.yml 文件中 default_layout 参数指定默认布局。</p><p>Hexo 支持三种默认布局，用其创建的文章会自动存放到不同的文件夹，如果是自定义布局则和 post 相同。</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td>page</td><td>source</td></tr><tr><td>draft</td><td>source&#x2F;_drafts</td></tr><tr><td>post</td><td>source&#x2F;_posts</td></tr><tr><td>自定义布局</td><td>source&#x2F;_posts</td></tr></tbody></table><p>编写布局文件时还可以利用 Hexo 的变量功能，使创建文章时自动编写 Front-matter，变量需要用两个大括号括起。</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>layout</td><td>布局</td></tr><tr><td>title</td><td>标题</td></tr><tr><td>date</td><td>文件建立日期</td></tr></tbody></table><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p>Front-matter 是每个文章开头处用“—”或“;;;”分割的区域，两者分别对应着“YAML”和“JSON”两种写法，它用于指定当前文章的属性信息，Hexo 中部分功能的运行依赖其中的信息。</p><p>常用的一些文章属性如下。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>标题</td></tr><tr><td>categories</td><td>分类</td></tr><tr><td>date</td><td>建立时间</td></tr><tr><td>published</td><td>是否发布</td></tr><tr><td>layout</td><td>布局（主题可能识别该项从而影响页面效果）</td></tr><tr><td>updated</td><td>更新时间</td></tr><tr><td>comments</td><td>开启评论</td></tr></tbody></table><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>使用命令前需要全局安装 hexo-cli，这样才能使用 hexo 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g<br></code></pre></td></tr></table></figure><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init [folder] <span class="hljs-comment"># 创建一个博客网站</span><br>hexo &#123;g|generate&#125; <span class="hljs-comment"># 编译网站静态资源（很多pages服务自带构建功能，所以该命令一般不用）</span><br>hexo clean <span class="hljs-comment"># 清除项目的缓存文件</span><br></code></pre></td></tr></table></figure><h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo config [key] [value] <span class="hljs-comment"># 查看或修改网站配置</span><br>hexo list &lt;<span class="hljs-built_in">type</span>&gt; <span class="hljs-comment"># 列出网站数据</span><br>hexo server [--draft] <span class="hljs-comment"># 启动本地服务器以预览网站[包括草稿文章]</span><br>hexo &#123;d|deploy&#125; <span class="hljs-comment"># 将网站部署到托管平台</span><br></code></pre></td></tr></table></figure><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new [layout] &lt;title&gt; <span class="hljs-comment"># 新建一篇文章</span><br>hexo publish &lt;filename&gt; <span class="hljs-comment">#发布一篇文章</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【汇编】基本概念</title>
    <link href="/posts/3178886567.html"/>
    <url>/posts/3178886567.html</url>
    
    <content type="html"><![CDATA[<h1 id="【汇编】基本概念"><a href="#【汇编】基本概念" class="headerlink" title="【汇编】基本概念"></a>【汇编】基本概念</h1><h2 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h2><p>计算机有多种储存空间提供使用，不同的存储空间有着不同的使用场景</p><ul><li>寄存器<br>一般CPU中都有直接配备，速度最快，可以完全匹配CPU的速度，但容量小，一般和平台位数有关。除一些做特殊用途的寄存器外，一般只用来放置一次计算中的临时数据。</li><li>存储器<ul><li>内存<br>空间大，在一次程序运行期间可长期储存，但速度慢，一般配合Cache功能以适应CPU的速度。</li><li>外存<br>速度最慢，但可以长期存储，是所有数据和程序存储的地方，使用时相关数据都会加载到内存中，一般配合虚拟存储器功能以匹配内外存的容量差异。</li></ul></li><li>栈空间<br>函数的执行就是入栈出栈，包括返回地址和局部变量等数据，都在栈空间中存储，栈空间的扩展方向是由高到低地址，所以入栈时一般用减法。<br>栈帧：某一时刻栈空间的状态</li></ul><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h3><p>操作码 [运算符]&lt;操作数&gt; …</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>操作码</td><td>指定使用的函数，为固定关键字</td></tr><tr><td>操作数</td><td>供函数使用的参数，如立即数，寄存器等</td></tr><tr><td>运算符</td><td>一些固定关键字，能对操作数进行微调，比如类型转换</td></tr></tbody></table><h3 id="操作单位"><a href="#操作单位" class="headerlink" title="操作单位"></a>操作单位</h3><p>默认单位为计算机系统位数，如x86_64就是64位，即8字节。也允许显式指定，指定方式有多种，一般作为操作码后缀出现。（注意寻址的单位是字节和操作单位不是一个概念）</p><table><thead><tr><th>表示</th><th>名称</th><th>大小（一般情况下）</th></tr></thead><tbody><tr><td>b</td><td>字节（byte）</td><td>8位</td></tr><tr><td>w</td><td>字（word）</td><td>16位</td></tr><tr><td>l</td><td>双字（doubleword）</td><td>32位</td></tr><tr><td>q</td><td>四字（quadword）</td><td>64位</td></tr></tbody></table><h3 id="参数形式"><a href="#参数形式" class="headerlink" title="参数形式"></a>参数形式</h3><p>目的操作数：一般也是输出结果的位置，即存储返回值</p><ul><li>&lt;目的操作数&gt;</li><li>&lt;目的操作数&gt;,&lt;源操作数&gt;（可能反向）</li></ul><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="识别方式"><a href="#识别方式" class="headerlink" title="识别方式"></a>识别方式</h3><p>寄存器排除前后缀后名称相同，表明是同一寄存器，只是读写长度不同</p><h4 id="对于不带编号的寄存器："><a href="#对于不带编号的寄存器：" class="headerlink" title="对于不带编号的寄存器："></a>对于不带编号的寄存器：</h4><ol><li>前缀为r，表明是64位</li><li>前缀为e，表明是32位</li><li>后缀为l，表示是8位</li><li>无前后缀，表示是16位</li></ol><h4 id="对于带编号寄存器（第8-16号寄存器）："><a href="#对于带编号寄存器（第8-16号寄存器）：" class="headerlink" title="对于带编号寄存器（第8-16号寄存器）："></a>对于带编号寄存器（第8-16号寄存器）：</h4><ol><li>后缀为d，表示32位</li><li>后缀为w，表示16位</li><li>后缀为b，表示8位</li><li>无前后缀，表示64位</li></ol><h3 id="运算符（不是操作码）"><a href="#运算符（不是操作码）" class="headerlink" title="运算符（不是操作码）"></a>运算符（不是操作码）</h3><ul><li>[]：对寄存器运算时都要加上。</li><li>+&#x2F;-：取寄存器中的值进行运算，并返回新值。</li><li>PTR：将值强制识别为地址。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>计算机</category>
      
      <category>汇编</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】个人编码规范</title>
    <link href="/posts/3651714765.html"/>
    <url>/posts/3651714765.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Unity】个人编码规范"><a href="#【Unity】个人编码规范" class="headerlink" title="【Unity】个人编码规范"></a>【Unity】个人编码规范</h1><h2 id="文件结构规范"><a href="#文件结构规范" class="headerlink" title="文件结构规范"></a>文件结构规范</h2><h3 id="先确保动静态分离"><a href="#先确保动静态分离" class="headerlink" title="先确保动静态分离"></a>先确保动静态分离</h3><p>当一个类存在静态和非静态两种成员时，需要利用 partial 将类分成两部分，分别存放静态与非静态成员。</p><h3 id="再按访问修饰符排序"><a href="#再按访问修饰符排序" class="headerlink" title="再按访问修饰符排序"></a>再按访问修饰符排序</h3><ol><li>公开成员</li><li>保护成员</li><li>私有 SerializeField 字段</li><li>私有成员</li><li>私有用户事件</li><li>私有 Unity 事件</li></ol><h3 id="最后按成员类型排序"><a href="#最后按成员类型排序" class="headerlink" title="最后按成员类型排序"></a>最后按成员类型排序</h3><ol><li>数据结构定义</li><li>构造函数</li><li>字段</li><li>属性</li><li>函数</li></ol><h2 id="代码设计规范"><a href="#代码设计规范" class="headerlink" title="代码设计规范"></a>代码设计规范</h2><ul><li>字段永远是私有的，除了只读字段。</li><li>用到多个 if 时，尽可能采用级联而非嵌套。</li><li>“!bool”仅用于取反操作，作为逻辑判断时应用“bool &#x3D;&#x3D; false”。</li><li>当代码中用到 switch 或 if，但无法确定最大数量时，应改用继承重写，委托等方式来替代。</li><li>Start 之前完成所有初始化工作，在 Awake 和 Start 期间可以修改参数，按情况配备初始化函数。</li><li>尽可能利用序列化引用物体而非运行时绑定，从而使引用关系在面板可见。</li></ul><h3 id="模糊要求"><a href="#模糊要求" class="headerlink" title="模糊要求"></a>模糊要求</h3><ul><li>函数内容过长时应改为拆成多个局部方法再挨个调用的方式实现。</li><li>代码间的关系应该层级分明，形成树形结构，不要出现越级操作。</li><li>出现复制粘贴的编码方式时，应考虑封装相关代码避免复制粘贴。</li></ul><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>需要限定命名的原因</p><ul><li>统一风格，美观。</li><li>便于区分类型和作用。</li><li>避免重名。</li></ul><p>若没有上述十足的理由，不应强制实施命名规范，否则会增加工作负担。</p><h3 id="风格限制"><a href="#风格限制" class="headerlink" title="风格限制"></a>风格限制</h3><ul><li>使用驼峰命名法</li><li>名字要容易理解</li><li>倒序域名化命名</li></ul><p>名称怕短不怕长，可以结合上下文简化名称，但一定要能让别人理解意思。比如对于采用驼峰命名法的名称在其含有的单词间加入空格，放入翻译软件应能正确获取到对应中文名。</p><p>名称结构要层次化，并按从大到小的顺序，便于分类和查找。如 DbTableServer,Db 说明是数据库相关功能，Table 表明是针对数据库中的表功能，Server 表示是一个实例类。</p><h3 id="类型限制"><a href="#类型限制" class="headerlink" title="类型限制"></a>类型限制</h3><ul><li>私有成员首字母小写，其他成员首字母大写。</li></ul><table><thead><tr><th>类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>接口</td><td>对应类名添加<code>I</code>前缀</td><td><code>IInterface</code></td></tr><tr><td>泛型</td><td>对应类型添加<code>T</code>前缀</td><td><code>TGeneric</code></td></tr><tr><td>函数</td><td>动作，主动语态。</td><td><code>OpenDoor</code></td></tr><tr><td>事件</td><td>动作，被动语态，触发在对应函数开头或期间添加<code>ing</code>后缀，触发在函数结束添加<code>ed</code>后缀。</td><td><code>DoorOpening</code>、<code>DoorOpened</code></td></tr><tr><td>事件函数</td><td>动作，被动语态，添加<code>on</code>前缀。</td><td><code>OnDoorOpen</code></td></tr><tr><td>字段</td><td>名词，被动语态。</td><td><code>isDoorOpening</code></td></tr><tr><td>属性</td><td>与对应字段同名，大写开头。</td><td><code>IsDoorOpening</code></td></tr></tbody></table><h3 id="前后缀限制"><a href="#前后缀限制" class="headerlink" title="前后缀限制"></a>前后缀限制</h3><ul><li>若未指明，则不要私自添加前后缀。</li><li>部分类型要添加特殊的前后缀。</li></ul><table><thead><tr><th>后缀</th><th>描述</th></tr></thead><tbody><tr><td>s,es</td><td>容器</td></tr><tr><td>UI</td><td>用户界面相关</td></tr><tr><td>Prefab</td><td>用于实例化的预制体</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Unity</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【计算机】字符编码的发展与关系</title>
    <link href="/posts/1673174570.html"/>
    <url>/posts/1673174570.html</url>
    
    <content type="html"><![CDATA[<h1 id="【计算机】字符编码的发展与关系"><a href="#【计算机】字符编码的发展与关系" class="headerlink" title="【计算机】字符编码的发展与关系"></a>【计算机】字符编码的发展与关系</h1><h2 id="编码方案与字符集"><a href="#编码方案与字符集" class="headerlink" title="编码方案与字符集"></a>编码方案与字符集</h2><p>字符编码说到底就是一种将字符存储在计算机中的方式，如通常会将字符与一个二进制串对应，从而映射到字节流中。而表示字符与二进制串对应关系的表叫做字符集，而具体将对应的二进制串映射到字节流中的方法则叫编码方案。</p><p>所以说编码方案和字符集不是同一种东西，两者配合才构成一个完整的字符编码。通常一个系列的编码考虑兼容性都会使用同一个字符集，但一个字符集可能有多个编码方案，这些编码方案之间可能兼容也可能不兼容。</p><p>所以，虽然看起来下文较多的讲述编码方案，但要知道每种编码都有隐含的字符集在内，一般编码名即使是字符集的名称。</p><h2 id="ASCII（美国信息交换标准代码）"><a href="#ASCII（美国信息交换标准代码）" class="headerlink" title="ASCII（美国信息交换标准代码）"></a>ASCII（美国信息交换标准代码）</h2><p>ASCII发布于1967年，是相当早期的编码标准，并一直沿用至今，奠定了后续编码标准的基础。</p><p>其采用一个字节对应一个字符的形式，但也因此只能存储字母数字等西文字符，不能满足全球化的需求。</p><h2 id="ANSI码（美国国家标准学会码）"><a href="#ANSI码（美国国家标准学会码）" class="headerlink" title="ANSI码（美国国家标准学会码）"></a>ANSI码（美国国家标准学会码）</h2><p>由于ASCII不能满足全球化的需求，所以之后各国都开始以ASCII为基础定制自己本国的编码格式，如GB2312（一种中文编码），Shift_JIS（一种日文编码）等。</p><p>这些编码都有同一特性：和ASCII兼容，但互相之间不兼容。所以使用这些编码同时只能显示一种地区支持的语言。</p><p>这类的编码格式种类繁杂，因此一个叫ASNI的组织站了出来，定制了一个叫“代码页”的标准，其统计了这类编码格式，给每个格式都分配了专属的代码页编号，也因此这类编码又被称做ANSI编码。</p><p>所以说ANSI码并不是指一个特定的文本编码，而是指代一群有相同特征的编码。</p><h3 id="GB系列编码"><a href="#GB系列编码" class="headerlink" title="GB系列编码"></a>GB系列编码</h3><p>GB是“国标”的拼音首字母，是中国地区的ANSI码，其一共有三代：“GB2312”、“GBK”、“GB18030”，三者都是按顺序发展出来。</p><h4 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h4><p>GB2312是最早的中文编码标准，每个字占两个字节，与ASCII兼容，一共收录了6763个汉字以及682个特殊符号，已经包含了所有生活中的常用汉字了。</p><h4 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h4><p>GB2312只有6000多个汉字，肯定是无法满足所有汉字的数量需求的，因此GBK得以出现，在与GB2312兼容的基础上，将汉字数量扩充到了20902个，符号数达到了984个，并且包含了对繁体字的支持。</p><h4 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h4><p>即使GBK的字符数高达两万多，但依旧是不够中国地区使用的，在与GBK兼容的基础上，这次直接将每字符两字节改为了四字节，还增加了很多少数民族所用的文字。</p><h2 id="Unicode（万国码）"><a href="#Unicode（万国码）" class="headerlink" title="Unicode（万国码）"></a>Unicode（万国码）</h2><p>ANSI码只是让各国有了自己的字符编码，但依旧没有满足全球化的需求，现在急需一款能在全球通用的字符编码，于是Unicode编码得以出现。</p><p>最开始的时候有多个组织都在试图制定全球通用的编码标准，比如一个是ISO定制的UCS，还有一个是统一码联盟指定的“Unicode”。当然，1991年前后，人们很开就意识到世界不需要两个通用编码标准，所以两者开始合并成果并协同后续工作，于是现代的Unicode得以诞生。</p><h3 id="UCS-4与UTF-32"><a href="#UCS-4与UTF-32" class="headerlink" title="UCS-4与UTF-32"></a>UCS-4与UTF-32</h3><p>这两个编码方案都是4字节的定长存储，但这太浪费空间了所以很少使用。其他地方两者基本一样，UTF-32的提出主要是为了ISO和统一码联盟两者字符集互相兼容而产生的。</p><h3 id="UCS-2与UTF-16"><a href="#UCS-2与UTF-16" class="headerlink" title="UCS-2与UTF-16"></a>UCS-2与UTF-16</h3><p>UCS-2是很早期的Unicode编码方案，采用2字节的定长方式存储字符，很显然现在它已经被淘汰了，因为2字节根本无法满足存储全球文字的需求。</p><p>所以UTF-16诞生了，它是UCS-2的升级版，所以与之兼容，同时将定长存储改为了变长存储，需要时会将字符空间扩展到4字节。</p><p>因为最低两字节，所以UTF-16有字节序的问题，因此会在文本开头带上额外的DOM（字节序标记），用于标识大端模式（BE）还是小端模式（LE），在Windows环境下通常会将UTF-16<br>LE直接叫做“Unicode”。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8是较新的编码方案同时也是最流行的编码方案，它采用变长存储，与ASCII兼容，最低时一个字符只需1字节，直接化身ASCII码，所以在多语言文本环境（如HTML文件）中能很大的节省空间，同时扩展性也很强。</p><h4 id="UTF-8-BOM"><a href="#UTF-8-BOM" class="headerlink" title="UTF-8 BOM"></a>UTF-8 BOM</h4><p>因为UTF-8是最低单字节的变长编码，所以实际上它是不需要BOM的，而且这不符合Unix使用习惯，因为Unix在设计上不建议这种看不见的文本内容；加BOM是微软的习惯，用于区分ASCII和UTF-8。所以虽然有这种编码方式，但因为兼容性的原因并不推荐。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/27136737">刨根究底字符编码之七——ANSI编码与代码页</a></li><li><a href="https://cloud.tencent.com/developer/article/1343240">一图弄懂ASCII、GB2312、GBK、GB18030编码</a></li><li><a href="https://www.cnblogs.com/malecrab/p/5300503.html">细说：Unicode, UTF-8, UTF-16, UTF-32, UCS-2, UCS-4</a></li><li><a href="https://www.zhihu.com/question/308677093">Java 为什么使用 UTF-16 而不是更节省内存的 UTF-8？</a></li><li><a href="https://www.zhihu.com/question/20167122">「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【COM3D2Mod 制作教程（8）】实战！制作衣服部分（下）</title>
    <link href="/posts/440186531.html"/>
    <url>/posts/440186531.html</url>
    
    <content type="html"><![CDATA[<h1 id="【COM3D2Mod-制作教程（8）】实战！制作衣服部分（下）"><a href="#【COM3D2Mod-制作教程（8）】实战！制作衣服部分（下）" class="headerlink" title="【COM3D2Mod 制作教程（8）】实战！制作衣服部分（下）"></a>【COM3D2Mod 制作教程（8）】实战！制作衣服部分（下）</h1><h2 id="制作袜子-Mod"><a href="#制作袜子-Mod" class="headerlink" title="制作袜子 Mod"></a>制作袜子 Mod</h2><p>体会了裙子 Mod 的制作流程，不知道你有没有被麻烦的权重和形态键搞崩溃过，现在做袜子难道还得在来一遍？而且裆下的权重和形态键因为靠的太近做起来也很麻烦。</p><p>不用害怕，袜子有一个裙子没有的特征：它够简单，没用复杂的装饰布线，看起来示例 Mod 真的非常相似。利用这一点，我们将采取一种全新的制作方式，完全不用搞上面的麻烦事，还能做出绝对完美的衣服。</p><h3 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h3><blockquote><p>使用官方模型然后改贴图的方式完成袜子 Mod 制作，贴图采用烘焙加人工微调的方式制作。</p></blockquote><p>之前，示例 Mod 一直都只被用来转移数据和做参照，用完就扔，但今天它们将翻身做主人。我们将直接使用示例 Mod 作为导出 Mod，所以权重和形态键完全官方正品，<del>绝不会出问题</del>，我们唯一要做的就是改一张贴图，让它看起来像源模型，从而狸猫换太子。</p><p>所以 model 文件不需要我们制作了，但也多了个 tex 文件要制作，或许你会担心自己不会画画，但没关系，这部分也是自动化的，我们将直接利用 Blendr 的烘焙功能，实现“贴图转移”，然后一样稍加调整即可。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>直接使用官方 model，完全跳过 model 制作环节，工作量大幅降低，质量还非常高。</li><li>需要示例模型与源模型非常相似才行，对衣装特征有局限性，不过袜子等就很适合。</li><li>有额外的 tex 制作环节，但因为可以利用烘焙自动化绘制，所以影响不大。</li></ul><h3 id="制作流程"><a href="#制作流程" class="headerlink" title="制作流程"></a>制作流程</h3><h4 id="制作-tex-文件"><a href="#制作-tex-文件" class="headerlink" title="制作 tex 文件"></a>制作 tex 文件</h4><ol><li><p>选取和源模型最接近的示例袜子 Mod。</p><ul><li>如果你是半透明袜子，那官方袜子也一定要选半透明的，因为官方会用“Hide Node”偷懒。</li><li>根据具体情况可能需要重新生成示例模型的 uv，因为部分示例模型的 uv 是重叠的。</li></ul></li><li><p>将源模型加面并利用裹缩修改器贴合示例模型。</p></li><li><p>利用 Cycles 渲染器的烘焙功能“转移贴图”。</p><ol><li>将源模型材质设为自发光，确保场景没有其他光源干扰。</li><li>给示例模型添加材质和贴图，确保可以在贴图绘制模式绘制。</li><li>切换至 Cycles 渲染器，打开“所选物体-&gt;活动物体”功能。</li><li>稍微设置一些“挤出”参数，可以减少画面的坏块。</li><li>可以降低一些渲染采样参数，加快贴图烘焙。</li><li>先选源模型再选示例模型，点击烘焙即可出图。</li></ol><p>可以看一下效果还是很不错的，只有缺模型的脚部和裆下的犄角旮旯烘的有问题，后面简单修一下即可。</p><p><img src="/assets/images/2454431-20240128180134284-205623999.jpg" alt="img"></p></li><li><p>利用印章工具绘制修补烘焙错误或缺漏的地方。</p></li></ol><p><img src="/assets/images/2454431-20240128180951129-1160719241.jpg" alt="img"></p><p>修补完成</p><p><img src="/assets/images/2454431-20240128182034906-1725762272.jpg" alt="img"></p><h4 id="制作其他文件"><a href="#制作其他文件" class="headerlink" title="制作其他文件"></a>制作其他文件</h4><p>剩下的 mate 和 menu 和之前的 Mod 一样做即可；model 则直接用我们现在修改过的示例模型即可。因为 mate 不用导出，再除去 tex 文件，共计也就 menu 和 model 两个文件。</p><h3 id="完成袜子-Mod-制作"><a href="#完成袜子-Mod-制作" class="headerlink" title="完成袜子 Mod 制作"></a>完成袜子 Mod 制作</h3><p>nice~，成功又做完一个部件，这可真的比裙子简单多了。</p><p><img src="/assets/images/2454431-20240128184626079-974063066.jpg" alt="img"></p><h2 id="制作鞋子-Mod"><a href="#制作鞋子-Mod" class="headerlink" title="制作鞋子 Mod"></a>制作鞋子 Mod</h2><p>鞋子 Mod 我感觉完全不需要我写了，因为它基本就是裙子 Mod 的那一套做法，不同同样也有些属于他的技巧和特点。</p><ul><li><p>鞋子是对称的，所以我们只需要做一个，另一个镜像即可。</p></li><li><p>原版游戏是不支持高跟鞋的，硬上只会穿模，所以高跟鞋得特殊处理。</p><p>可选的方案有以下几种：</p><ol><li>改模型，将高跟鞋改成非高跟鞋。</li><li>利用“Hide Node”隐藏脚部，避免穿模。（但得保证鞋子模型确实能遮蔽脚部）</li><li>将鞋子旋转，根部放低，遮住穿模部位。（相当于把穿模换成了鞋子浮空）</li></ol></li><li><p>由于是从袜子上拆下的模型，一般存在双面问题。</p><p>最简单方法，可以利用之前说过的轮廓线材质解决。</p></li></ul><p>目前大部分移植的鞋子 Mod 都是高跟鞋，都要处理高跟问题，这也是为什么鞋子需要一定的建模能力。不过也有很多 Mod 作者会利用高跟鞋插件来解决问题，但这有一定的兼容性问题，所以不是本教程的内容，有兴趣就自行研究吧。</p><h3 id="制作流程-1"><a href="#制作流程-1" class="headerlink" title="制作流程"></a>制作流程</h3><ol><li><p>将源模型鞋子由一双改为一只。</p><p>后续我们可以通过镜像自动创建另一只，这样可以省去一半的工作量，而且转移权重时也能更准确。</p></li><li><p>匹配源模型与示例模型，可根据之前的提示处理高跟问题。</p><p>本次实战制作的鞋子很巧的是靴子，所以支持第二个解决方案，这样我甚至都不需要处理穿模问题了。</p></li><li><p>和裙子 Mod 一样的流程，解决穿模刷权重做形态键，等等。</p><p>操作细节也完全一样，如何解决穿模之前说过了，此外一样要注意权重刷取是否符合物理性质的问题。鞋子一共就两根骨骼，还是很好处理的。</p></li><li><p>检查鞋子无误后，制作另一只鞋子。</p><p>直接复制镜像即可，记得把顶点组的名字也改一下，然后合并成一个物体，修正一下法线即可。</p><p><img src="/assets/images/2454431-20240128202228842-259936890.jpg" alt="img"></p></li></ol><h3 id="完成鞋子-Mod-的制作"><a href="#完成鞋子-Mod-的制作" class="headerlink" title="完成鞋子 Mod 的制作"></a>完成鞋子 Mod 的制作</h3><p>靴子做 Mod 还真方便，这下最后一个部件也终于做好啦！</p><p><img src="/assets/images/2454431-20240128202710938-1996549408.jpg" alt="img"></p><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>恭喜你成功完成了所有 Mod 制作教程，如果继续深入，还有很多技术可以挖掘，但相信这些基础知识已经足以让你满足对老婆的需求了。</p><p>也恭喜我终于成功完结这个系列了，太费时间了，重获自由的感觉真好啊，很快我将退坑这款游戏，但你依然可以从网站的联系方式里找到我。</p><p>回想起来，一路从入坑到退坑，遇上了很多事，也学到了很多东西，真的感慨良多啊~所以我决定将这些经验留下，希望能帮到和我一样踩坑的你们。</p><p>最后，完结撒花！ o(*≧▽≦)ツ ┏━┓</p><p><img src="/assets/images/2454431-20240128204355302-1441202585.jpg" alt="img"></p><p>话说绫华好像做胖了……</p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
      <category>COM3D2Mod制作教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【COM3D2Mod 制作教程（7）】实战！制作衣服部分（上）</title>
    <link href="/posts/4186352253.html"/>
    <url>/posts/4186352253.html</url>
    
    <content type="html"><![CDATA[<h1 id="【COM3D2Mod-制作教程（7）】实战！制作衣服部分（上）"><a href="#【COM3D2Mod-制作教程（7）】实战！制作衣服部分（上）" class="headerlink" title="【COM3D2Mod 制作教程（7）】实战！制作衣服部分（上）"></a>【COM3D2Mod 制作教程（7）】实战！制作衣服部分（上）</h1><h2 id="教程介绍"><a href="#教程介绍" class="headerlink" title="教程介绍"></a>教程介绍</h2><p>隔了 N 个月终于迎来了第二期的 Mod 教程部分，这一期我们将开始制作人物的衣服部分。</p><p>因为体型适配的原因，衣服部分要比身体部分难得多，但主要也就是多了个刷权重和制作形态键的任务，只要掌握技巧，勤加练习，做起来也不会太难。</p><p>由于大量步骤和身体部分相同，这期教程的内容会有所简化，所以一定要先把前置的第一期学好，只要理解了 Mod 的制作原理，哪怕不看教程，自己也能举一反三。</p><h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><p>本期教程将使用三种装扮类型作为教学内容：“裙子”、“袜子”、“鞋子”，这三者是人物的外衣，是最能体现人物的装扮，同时对应着几种不同的制作方向，作为教程内容再适合不过了。</p><p><img src="/assets/images/2454431-20240125201310367-1633834850.jpg" alt="img"></p><ul><li><p>裙子：</p><p>裙子是特征点最多的衣物，并且往往还会附带配饰，要绑定的骨骼和形态键也是最多的，所以要在权重和形态键的制作上要下功夫。</p></li><li><p>袜子：</p><p>袜子由于和鞋子相连，通常无法得到完整的原始模型，但因为都长得都差不多，我们可以利用这一点，直接使用示例模型加改贴图的方式实现。</p></li><li><p>鞋子：</p><p>鞋子通常是从袜子上拆出来了，加上游戏对高跟鞋不兼容，鞋子需要额外的一些建模处理，不过因为鞋子模型比较简单又是对称的，所以可以自己改模。</p></li></ul><p>_为啥是袜子而不是裤子，首先我们没法获取到袜子模型（腿部模型只有一层，看成裤子就没袜子了），另外从游戏内看裤子模型比袜子模型更复杂，大部分源模型的特征也更接近袜子（穿裙子后谁还穿正经裤子啊，结果不是黑丝就是白丝）_。</p><h2 id="导入官方身体模型"><a href="#导入官方身体模型" class="headerlink" title="导入官方身体模型"></a>导入官方身体模型</h2><p>在头发部分我们确定模型是否正确的方式是：直接导入游戏，对照游戏进行修改，再重导再测试。这种方式对简单的模型来说还能接受，但对复杂的衣服部分就不再适用了。</p><p>而且除了刷权重，衣服部分还多了制作形态键，确认身体部位等工作，所以我们必须要获取官方身体的相关数据才行。</p><h3 id="1-获取身体模型"><a href="#1-获取身体模型" class="headerlink" title="1. 获取身体模型"></a>1. 获取身体模型</h3><p>幸运的是官方身体也是 Mod 的一种，我们可以在“SybarisArcEditor”中搜索 body 来获取到官方的身体模型，或者我在之前的“Mod 制作工具”整合中也留了一份。</p><p>和正常的 Mod 一样，我们将 model 文件导入到 Blender 即可。</p><p><img src="/assets/images/2454431-20240125202339905-1029588424.jpg" alt="img"></p><h3 id="2-调整身体姿势"><a href="#2-调整身体姿势" class="headerlink" title="2. 调整身体姿势"></a>2. 调整身体姿势</h3><p>可以看到身体模型的默认姿势成 C 型的扭曲状，这种姿势适合查看人物的肌肉表现效果，但并不适合我们绘制权重和调整网格，所以我们必须先将身体姿势调整为易于使用的 T 型姿势。</p><p>因为之前有网友给我提供了 T 型姿势的动画文件，所以我们不需要再手动调整了。选中我们的身体，然后利用“Blender-CM3D2-Converter”插件导入动画的功能，导入“Mod 制作工具”（第三章给出的工具整合包）中的 T 型姿势文件即可。</p><p>注意，插件导入动画的功能只会调整你在姿势模式中选中的骨骼，所以如果通过上述方法导入姿势后，实际姿势没有发生变化或只有部分变化，那可能是因为你没有在姿势模式下选择全部骨骼。</p><p><img src="/assets/images/2454431-20240125202943869-359838356.jpg" alt="img"></p><h3 id="3-增加导出姿势"><a href="#3-增加导出姿势" class="headerlink" title="3. 增加导出姿势"></a>3. 增加导出姿势</h3><p>现在我们已经有了 T 型身体，但要注意的是原先官方默认的姿势是 C 型的，这意味着我们导出 Mod 时也必须保持 C 型，幸运的是插件提供了自定义姿势与默认姿势切换的功能。</p><p>让我们进入姿势模式，在确保当前身体姿势是 T 型的情况下，使用“姿势-应用-当前姿势的身体”菜单项，稍等片刻后，在骨架面板便会多出两种姿势切换的对应按钮。</p><p><img src="/assets/images/2454431-20240126163533640-2141730298.jpg" alt="img"></p><p><strong>上述的处理流程不仅对身体生效，因为我们制作 Mod 时要用到官方示例 Mod，所以同样要对示例 Mod 的模型处理一边，之后我们将采用 T 型制作，C 型导出的方式，进行 Mod 开发。</strong></p><h2 id="制作裙子-Mod"><a href="#制作裙子-Mod" class="headerlink" title="制作裙子 Mod"></a>制作裙子 Mod</h2><p>现在让我们正式进入教学内容，根据身体部分的制作经验，此时你应该知道如何预处理模型，以及导入官方示例模型了，所以我将跳过这部分，假定你已经拆好了模型，并准备好了官方示例模型。</p><p>和以往的帽子 Mod 之类不同的是，这次我们先制作裙子 Mod 的 model 文件，最后再制作 menu 文件，因为 menu 文件的部分参数必须要根据具体的模型情况填写。</p><h3 id="一、制作-model-文件"><a href="#一、制作-model-文件" class="headerlink" title="一、制作 model 文件"></a>一、制作 model 文件</h3><p>model 文件是制作最为复杂的文件，我将挨个写出我的制作流程，并将该流程中的一些注意事项或技巧写在下面。</p><h4 id="1-匹配模型姿态体型"><a href="#1-匹配模型姿态体型" class="headerlink" title="1. 匹配模型姿态体型"></a>1. 匹配模型姿态体型</h4><p>源模型和身体模型在姿态和体型上一般都有所差别，首先我们要减少这些差异。这一步可以不处理太细致穿模问题，但要保证两模型基本相符。良好的初始状态有利于我们后续的制作，现在做越贴合后面进一步的细节调整就越少。</p><p>在这一步我们选择利用源模型本身骨架进行模型调节，调节完后应用骨架修改器完成网格编辑，因为本身就是按身体结构绑定的，所以当我们想调整特定身体部位时会很方便，这样子对齐模型的效果又快又好。</p><h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><ul><li>对于部分骨骼可以先在编辑模式中进行拆分再使用，从而避免影响到子骨骼。</li><li>匹配时建议稍微往外偏一些，这样可以减少穿模发生的概率，但也别偏多。</li><li>如果发现骨骼调不动，可以确认一下变换属性是不是被锁上了。</li><li><strong>留意胸部、裙子等区域是否和示例 Mod 的骨骼匹配，不然会影响后续的权重刷取。</strong></li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>和身体以及裙子进行了匹配，<del>裙子确保在示例模型的外面</del>（做完了才发现错了，和示例模型的裙子差不多最好，不然前面的裙子和手会穿模，好在最后用衰减编辑救了下）；身体部分略有穿模，后续简单调一下网格即可。</p><p><img src="/assets/images/2454431-20240125223755558-845332007.jpg" alt="img"></p><h4 id="2-匹配模型面大小"><a href="#2-匹配模型面大小" class="headerlink" title="2. 匹配模型面大小"></a>2. 匹配模型面大小</h4><p>移植 Mod 的源模型大多是一些游戏模型，面的精度较低，做出的蒙皮网格容易出现穿模的情况，提高面数可以方便解决这一问题，而且还可以提高权重、形态键转移的精度。</p><p>所以源模型和示例模型的面大小应尽可能匹配，可以更精细，但一定不能少，对于一些特殊部位还可以根据情况再加面</p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>利用边的细分功能，我在不影响模型形状的情况下将源模型的面精度增加了一倍，从而使得源模型和示例模型的面大小基本匹配。</p><p><img src="/assets/images/2454431-20240125231502243-1534195618.jpg" alt="img"></p><h4 id="3-解决模型穿模问题"><a href="#3-解决模型穿模问题" class="headerlink" title="3. 解决模型穿模问题"></a>3. 解决模型穿模问题</h4><p>现在我们的模型与示例模型基本一致，即将进入骨骼绑定阶段。但对比身体模型，仍有部分穿模情况，我们需要调整网格解决这些。</p><h5 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h5><ul><li>适时调整身体模型的视图显示方式，便于对比或选点。</li><li>先选身体模型再选源模型编辑，这样身体模型将有特殊的颜色标记，便于区分。</li><li>打开显示叠加层中的线框，方便查看顶点位置。</li><li>利用雕刻模式调整网格。</li><li>利用选择菜单、顶点组、隐藏等功能调整网格选区。</li><li>利用法向坐标系、变换轴心点、法向缩放工具调整网格。</li><li>利用衰减编辑来调整网格，这样可以批量处理且效果也更平滑。</li><li>利用平滑顶点功能修复调整后网格可能过尖锐的问题。</li><li><strong>上述方法不仅是该阶段，后续的所有网格处理都可使用。</strong></li></ul><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><p>利用上述提示中的方法，我轻松解决了穿模问题。</p><p><img src="/assets/images/2454431-20240127091717096-757067066.jpg" alt="img"></p><h4 id="4-制作骨骼权重"><a href="#4-制作骨骼权重" class="headerlink" title="4. 制作骨骼权重"></a>4. 制作骨骼权重</h4><p>现在模型已完美贴合在身体模型上，直接利用之前的“权重转移”功能，进行我们的初始权重刷取。</p><p>但自动刷取的权重肯定是不完美的，我们要按具体情况进一步优化。</p><p>接着借助身体模型确认不会发生穿模。</p><h5 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h5><ul><li>将身体和源模型所用骨架共用为衣服骨架，并调整衣服骨架姿势，检修穿模情况。</li><li>检查衣服上的装饰，确保符合其物理性质。</li><li>利用“权重”菜单中的处理功能调整权重，如快速实现权重区域扩大平滑，<strong>注意这些处理功能默认是对全部骨骼处理</strong>。</li><li>利用直接编辑“顶点组”的方式调整权重，如快速移除错误权重区域。</li><li>将骨架修改器的罩体和编辑模式显示打开，继续利用“解决模型穿模问题”环节的方式解决穿模。</li><li><strong>犄角旮旯的地方优先通过调整顶点位置来解决穿模，否则选择自己刷权重可能适得其反。</strong></li><li>增大骨骼间公共的权重区域可以有效解决过渡生硬的问题。</li><li><strong>想重算或专门绘制部分区域的权重时，可分离物体再编辑然后合并或借助数据传递修改器实现。</strong></li></ul><h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><ol><li><p>我先用权重转移获得了初始权重，然后给骨架摆些检查姿势，进行二次穿模解决。</p></li><li><p>胸部权重稍微人工画了下，因为初始权重把胸部前端识别偏了。</p></li><li><p>胸部和腰部的权重都用“光滑”功能扩展了下范围，这样和胸部交界处能平滑些。</p></li><li><p>肩部的丝巾和腰后的蝴蝶结手动调了下权重，并通过编辑顶点组移除了一些骨骼权重，使其符合物理性质。</p></li><li><p>脖子加强了对应骨骼的权重，去除了其他骨骼对其的影响，使其完全跟着脖子骨骼动，从而解决穿模。</p></li><li><p>腋下顶点通过沿法线偏移的方式大幅扩大范围来防止穿模，附近骨骼权重仅做了些平滑处理。</p><p>这是我写完教程后补上的环节，当时摆姿势看不出来，结果一跳舞就穿模，检查起来太麻烦了。</p><p>原先是先尝试调的权重，结果调了一整晚都没调好，甚至更差了，所以最后选择了调顶点的方式来解决，这样效果好些，做也简单。</p><p>而为了还原到旧的权重，我复制了份模型，重新运行了转移权重，再通过数据传递修改器还原了腋下附近骨骼的权重，之后就如该条所说的，通过调整顶点来解决穿模了。</p></li><li><p>修复其他杂七杂八的穿模，基本用雕刻模式画一遍即可。</p></li></ol><p><img src="/assets/images/2454431-20240127145821411-1993980550.jpg" alt="img"></p><h4 id="6-制作形态键"><a href="#6-制作形态键" class="headerlink" title="6. 制作形态键"></a>6. 制作形态键</h4><p>形态键和绑骨非常类似，并且插件也支持形态键的转移功能，所以我们可以先用插件制作初始的形态键。</p><p>但同样，自动形态键也是不能直接用的，部分可能还得自己重做。</p><p>最后一样利用身体模型检验结果，并且要混合绑骨效果进一步检查。</p><h5 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h5><ul><li>前两个环节的很多提示在该环节也适用。</li><li>注意确定选的是要编辑的形态键，别做完发现搞错形态键或搞到基态上去了。</li><li>可以把形态键有问题的部分分离出来单独做，然后再合并回去，特别是一些装饰品。</li><li>衰减编辑不仅是用于平滑调整的工具，还可以让我们拉出特定形状，做胸部很实用。</li><li>胸下垂的形态键在胸大小形态键的基础上制作会更方便，此时可以打开形态键编辑模式选项。</li><li>如果怕麻烦，部分形态键可不做或不百分百匹配，但这也会导致可适配的体型变少。</li></ul><h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h5><p>上半身形态键就 5 个，一个凹陷效果的形态键我感觉对衣服没用就没做，肚子和手臂的形态键用自动转移的改改就 OK 了，胸部形态键用衰减编辑自己做了下，身上的金属挂饰拆下来单独做了形态键。</p><p>最后再组合一下权重和多形态键，大致处理了下穿模问题，还是有部分穿模但想着触发概率较低，就不搞那么严格了。</p><p><img src="/assets/images/2454431-20240127172343885-1000489949.jpg" alt="img"></p><h3 id="二、制作-mate-文件"><a href="#二、制作-mate-文件" class="headerlink" title="二、制作 mate 文件"></a>二、制作 mate 文件</h3><p>哎，我又犯了个错误，在过去的教学中我声称 mate 和 model 是引用关系，然而我现在才发现实际上它们是包含关系，model 文件中包含了 mate 文件的信息，这也解释了以往修改 mate 文件后还得重导 model 的原因。</p><p>这样一来的话，因为我们没有中途变更材质的需求，所以可以完全不导出 mate 文件，这样可以省下很多时间，而且因为 mate 的使用成本就此下降，我们可以更加自由的使用 mate 来为每件装扮做出定制化的效果。</p><p>所以从新的视角来看，mate 文件不再是工作负担，而将是我们用于简化美化 Mod 开发的便利工具，例如以下几种常见用法：</p><ul><li><p>利用半透明效果消除人物皮肤</p><p>我们做的是衣服，但源模型是连带人体部分的，所以做出来衣服上会带有皮肤，显然这是不应该出现的。所以我们要使用半透明类材质，接着改贴图，使皮肤部分透明度为 0，即可消除。</p><p>但注意半透明类材质有 pmat 问题，如果多个半透明材质叠加就可能需要制作额外的 pmat 文件。</p><p>或者你也可以故意留着，这样可以帮你遮挡因为 Node</p></li><li><p>解决衣服单面导致背面不可见的问题</p><p>这个我之前也有说过，只要利用轮廓线类材质的双面特性，就可以让模型背面也能显示出颜色。</p><p>但注意双面衣服就不要使用了，因为两个面间距过小可能导致背面效果穿模，从而产生异常的黑斑。</p></li><li><p>解决衣服拐角处角度过大导致高光的问题</p><p>默认材质会在模型边缘添加高光效果，而拐角处的权重比较难刷，容易出现不平滑导致误识别为边缘的情况，这是可以通过直接修改材质中的“_RimColor”属性，降低高光亮度，这样玩家看到的差异感会小很多。</p></li><li><p>多类材质混合使用</p><p>一个 model 是可以同时使用多个材质的，所以可以根据面的不同情况使用不同的材质，比如部分区域半透明，配饰加上轮廓线等。</p><p>因为 mate 文件不再需要手动导出，所以可以放心搭配，利用这种方式甚至可以解决 pmat 的问题，因为半透明材质将不再被滥用。</p></li></ul><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><ol><li>裙子自带正反面，所以没有双面问题，不需要用轮廓线材质。</li><li>裙子背面根据源材质情况，用的半透明材质。没有编写 pmat 文件，因为虽然面积较大，但有不透明的裙子正面做遮挡。</li><li>其他部位就是正常的颜色贴图，但修改了下高光亮度，解决腋下等部位的因不平滑而高亮的问题。</li><li>胸上的皮肤部分和裙子背面可以共用贴图，所以也共用了透明材质，后续再将贴图的皮肤部分扣掉，隐藏显示。</li></ol><p><img src="/assets/images/2454431-20240127182551660-923275687.jpg" alt="img"></p><h3 id="三、制作-tex-文件"><a href="#三、制作-tex-文件" class="headerlink" title="三、制作 tex 文件"></a>三、制作 tex 文件</h3><p>虽然 mate 文件不再需要导出，但所使用 tex 文件还是需要的，但 tex 文件基本就那几个，导出也很简单，甚至在制作身体部分时可能就已经把所需的 tex 都导好了。</p><p>我们目前所用的两张贴图之前已经导出过了，只有一个衣服贴图要把皮肤扣一下，可以直接用 Blender 的绘图工具扣，扣完重导一下就行。</p><p><img src="/assets/images/2454431-20240127192701224-667581940.jpg" alt="img"></p><h3 id="四、制作-menu-文件"><a href="#四、制作-menu-文件" class="headerlink" title="四、制作 menu 文件"></a>四、制作 menu 文件</h3><p>终于解决 model 文件了，现在让我们观察一下示例 Mod 的 menu 文件……</p><p>前面的部分基本上和之前的帽子 Mod 等一样，但后面较多的出现了些新的带 Item 和 Node 的菜单项。</p><p><img src="/assets/images/2454431-20240127172736500-1679541062.jpg" alt="img"></p><h4 id="认识关键词"><a href="#认识关键词" class="headerlink" title="认识关键词"></a>认识关键词</h4><p>首先让我补充一些有关 Item 和 Node 的知识点，这两个关键词其实都有着明确的特殊含义，很有必要认识它们。</p><ul><li><p><strong>Item</strong></p><blockquote><p>代表装扮部件，如：头发、上衣、鞋子。</p></blockquote><p>装扮部件很容易理解，因为我们现在就是做装扮部件，玩家使用的也是装扮部件，每一次都必须要带的条目“Add Item”就是把指定模型设置为装扮部件的意思。</p><p>如何知道想要的 Item 所对应的部件名？我们可以利用之前说过的“M-O-D”快捷键打开的信息面板查看，比如下图就可以判断出“连衣裙”的部件名即“onepiece”</p><p><img src="/assets/images/2454431-20240125214232161-1984608666.jpg" alt="img"></p></li><li><p><strong>Node</strong></p><blockquote><p>代表身体部位，如：颈椎、胸部、脚趾。</p></blockquote><p>Node 在游戏中没有直接的查看方式，但从原理上讲它是通过识别骨骼名称和权重实现的，如控制胸部有专门的骨骼，而它的这些骨骼所会影响的顶点构成的面就将被认为是胸部范围。</p><p>所以如果想知道一个 Node 的具体名称和范围，只需要在 Blender 中查看相关骨骼的名称及其顶点组即可：</p><p><img src="/assets/images/2454431-20240127173232091-1700207999.jpg" alt="img"></p></li></ul><h4 id="对应的新增条目"><a href="#对应的新增条目" class="headerlink" title="对应的新增条目"></a>对应的新增条目</h4><p>了解了这些知识后再回头看 menu 文件，很多条目就能看懂了，且在衣服部分的制作中，我们也将经常用到这些条目。</p><ul><li><p><strong>Mask Item</strong></p><blockquote><p>隐藏目标装扮部件。</p></blockquote><p>衣服是一层一层穿上的，当穿上外套时内衣自然就会不可见，而这个菜单项就是用来实现这个效果的，通常我们也不需要调节这个项，因为示例 Mod 的菜单项一般都够用。</p></li><li><p><strong>Node Hide&#x2F;Display</strong></p><blockquote><p>目标部位及其子部位标记隐藏&#x2F;显示。</p></blockquote><p>我们的衣服要做的贴合身体，但贴合又会容易导致穿模的发生，而该项可以将目标身体部位变的不可见，这样就能从根本上解决部分身体部位的穿模问题，可以说是非常实用的一项功能。</p><p><strong>但注意该项在用法上还比较特别，首先它的作用范围不仅是目标部位还包括它的子部位，而且名为标记的作用方式也很可疑。</strong></p><ul><li><p>什么叫子部位？</p><p>了解 Node 的含义后可以容易的想到骨骼的层级关系，没用错，目标部位的子部位其实就是目标部位所对应骨骼的子骨骼范围而已。</p><p><img src="/assets/images/2454431-20240127173549858-995051135.jpg" alt="img"></p></li><li><p>什么叫标记？</p><p>标记意味着这项功能不会立即生效，而是记录一个信息，表示在之后的某个时间要把该部位隐藏&#x2F;显示。这种延迟的特性使得标记在真正生效前能够被多次修改，这样我们就可以利用多个“Node Display”和“Node Hide”联动，抵消子部位的隐藏。</p></li><li><p>其他细节</p><ul><li>填写 Node 名称时只要包含关键词即可，这样我们便可以只用一个 Node 同时作用两边的部位。</li><li>身体部位默认显示，结算时只负责隐藏，所以如果一个区域同时被多根骨骼影响，优先隐藏。</li></ul></li></ul></li></ul><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><p>裙子的 menu 文件中除去上述的几项外，因为有了之前的 Mod 制作经验，我想你应该都会填写了，那这谈到的几项该如何填呢？</p><ul><li><p><strong>Mask Item</strong></p><p>首先“Mask Item”我们基本用示例 Mod 自带的就好，因为裙子都是差不多的，所以需要隐藏的东西也差不多，比如一样都要隐藏内衣这些，除非你做的是半透明的衣服。</p><p>这次我们的模型是常见的裙子款式，所以“Mask Item”直接使用了示例参数。</p></li><li><p><strong>Node Hide&#x2F;Display</strong></p><p>再者“Node Hide&#x2F;Display”则需要我们手动填一下，因为我们的模型不像官方模型有严格的部位遮蔽标准，所以要根据实际的能覆盖的身体部位进行隐藏。</p><p>不过暂时不想处理这个，因为主要还是为防穿模准备的，如果不穿模可以不弄，所以先继续用默认值，后续再看。</p></li></ul><h3 id="五、完善裙子-Mod"><a href="#五、完善裙子-Mod" class="headerlink" title="五、完善裙子 Mod"></a>五、完善裙子 Mod</h3><p>最后我们将上述制作的文件导入到我们的游戏中，由于有些文件被简化或已被制作过，结果裙子 Mod 就只多了个 model 和 menu 文件，重导了张 tex 文件而已。</p><p>穿上衣服摆几个姿势，确认一下 Mod 没有问题……果然有问题啊。</p><p><img src="/assets/images/2454431-20240128103732281-585908975.jpg" alt="img"></p><ol><li><p>手穿到裙子里了</p><p>之前做模型匹配时我故意把裙子做在了示例 Mod 外面，因为放里面会导致腿穿模，结果现在发现放外面也不行，会手穿模。( ╯□╰ )</p><p>解决方法就是把裙子的前面部分用衰减编辑往后拉一些，确保和示例裙子差不多位置，即恰好互相穿模，不能多太多。</p><p><img src="/assets/images/2454431-20240128092320126-106922107.jpg" alt="img"></p></li><li><p>背后的飘带不见了</p><p>发现因为飘带没有自带正反面模型，解决方法就是给它单独设置了一个轮廓线材质，这样我不需要建模，处理起来比较简单。另外为了和衣服匹配，将它的轮廓线宽度设为了 0，只要双面效果，背面的颜色也没用默认值。</p><p><img src="/assets/images/2454431-20240128092516873-1056567009.jpg" alt="img"></p></li><li><p>部分人物身体破面</p><p>因为这部分利用“Hide Node”隐藏了，而我们的模型又不能完全遮盖这个区域，解决方法就是让这个部位显示，即去掉对应的“Hide Node”。</p><p>看了下肚子和脖子下都是会破面的，所以这些部分不再隐藏，只隐藏了手臂和胸部，手臂靠肩和手的区域也不能隐藏，胸部的上半也是。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">//新编写的菜单项及其内容如下<br><br>node消去 Mune //隐藏整个胸部<br>node消去 UpperArm //隐藏整个手臂<br>node表示 Hand //取消手的隐藏<br>node表示 Foretwist_ //取消手腕的隐藏<br>node表示 Uppertwist_ //取消肩膀的隐藏<br>node表示 Mune_L_sub //取消左上半胸的隐藏<br>node表示 Mune_R_sub //取消右上半胸的隐藏<br><br>//Mune_L_sub是Mune的子部位，所以标记隐藏时会连带。但Mune_L_sub是全部胸部，而我们只要Mnue代表的上半胸，所以后面要取消Mune_L_sub的隐藏，其他取消隐藏的部位基本也是同样原因。<br><br>//大部分部位可以利用模糊匹配的规则，不需要名称写全，但Mune_L_sub等因为L和R的区别恰好卡在文字中间，所以只能分别写明。<br></code></pre></td></tr></table></figure></li><li><p>肚子上有一条缝</p><p>图上看不出来，但通过摆姿势时看到了，原因是模型预处理没做好，那个地方是断面。利用“网格-合并”功能融并了两边的顶点来解决了，很庆幸这功能没有影响到形态键这些。</p></li><li><p>部分权重不自然和少许穿模</p><p>用之前的制作方法继续完善即可。</p></li><li><p>在大体型中衣服扭曲</p><p>说明权重或者形态键没做好，当时只想着别穿模，却忘了考虑衣服的线条布局是否正确。</p><p>嘛，这个就不管了，反正我更喜欢幼的<del>(￣ ▽ ￣)</del>*</p></li></ol><h3 id="六、完成裙子-Mod-制作"><a href="#六、完成裙子-Mod-制作" class="headerlink" title="六、完成裙子 Mod 制作"></a>六、完成裙子 Mod 制作</h3><p>其他就基本没啥问题了，把上述这些小问题修好后，我宣布“衣服部分最难的裙子 Mod 制作成功！”</p><p>太棒了，差点一命通关，我甚至感觉时间还能缩，踩完了坑，掌握了技巧，做起来真的好简单。\^o^&#x2F;</p><p><img src="/assets/images/2454431-20240128140721419-362141272.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
      <category>COM3D2Mod制作教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Blender】插件开发笔记</title>
    <link href="/posts/953923210.html"/>
    <url>/posts/953923210.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Blender】插件开发笔记"><a href="#【Blender】插件开发笔记" class="headerlink" title="【Blender】插件开发笔记"></a>【Blender】插件开发笔记</h1><h2 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h2><ol><li>打开设置“界面-开发选项”：<br>这样可以通过对功能按钮的右键菜单直接复制或查看其源码，以及快速跳转到 API 手册。</li><li>打开设置“界面-Python 工具提示”：<br>这样可以通过界面的悬停菜单直接查看该条目在代码中的表示方式。</li><li>安装 python 环境，下载 fake-bpy-module 包：<br>这样可以在外部编辑器编写代码，并且有代码代码提示。</li><li>下载 VSCode 及其插件 Blender-Development：<br>这样可以快速创建插件项目并能自动导入和调试插件。</li></ol><h2 id="插件基本原理"><a href="#插件基本原理" class="headerlink" title="插件基本原理"></a>插件基本原理</h2><h3 id="插件是什么？"><a href="#插件是什么？" class="headerlink" title="插件是什么？"></a>插件是什么？</h3><p>插件是将代码集成到 Blender 的一种方式，只要符合以下要求，便可被 Blender 识别为插件。</p><ul><li>插件是一个 Python 包，即一个带有__init__.py 的文件夹。</li><li>该包带有 register()和 unregister()两个函数。</li></ul><h3 id="插件如何被集成？"><a href="#插件如何被集成？" class="headerlink" title="插件如何被集成？"></a>插件如何被集成？</h3><p>Blender 识别到插件会主动调用其中的 register 和 unregister 函数，这分别发生在启用插件和禁用插件两个时段，除此之外 Blender 不会调用任何函数。</p><p>所以我们必须借助 register 和 unregister 两个时段，主动将我们的“功能”注册给 Blender 编辑器或从中取消注册。</p><p>向 Blender 编辑器注册或取消注册是借助 Blender 的内置函数实现的，使用该函数时必须要提供一个参数，而该参数正是用来传递我们的“功能”的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 向Blender集成功能的代码示意</span><br><br><span class="hljs-keyword">import</span> bpy <span class="hljs-comment"># blender提供的所有功能都在bpy包中</span><br><br>functions = [function1,function2,function3,...] <span class="hljs-comment"># 我们的功能</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(): <span class="hljs-comment"># Blender将在启用插件时调用该函数</span><br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> functions: <span class="hljs-comment"># 利用数组加循环快速批量注册</span><br>        bpy.utils.register_class(f) <span class="hljs-comment"># 注册功能</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">unregister</span>(): <span class="hljs-comment"># Blender将在禁用插件时调用该函数</span><br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> functions: <span class="hljs-comment"># 利用数组加循环快速批量取消注册</span><br>        bpy.utils.unregister_class(f) <span class="hljs-comment"># 取消注册功能</span><br></code></pre></td></tr></table></figure><h3 id="集成的功能是什么？"><a href="#集成的功能是什么？" class="headerlink" title="集成的功能是什么？"></a>集成的功能是什么？</h3><p>注册功能的函数是 Blender 提供的，所以我们的功能也必须符合 Blender 注册函数对参数的要求。</p><p>具体来说这些功能实际上是几个 Blender 接口类的实现，目前 Blender 提供以下可用于集成的接口类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">bpy.types.Panel <span class="hljs-comment"># 常见的用户界面</span><br>bpy.types.Menu <span class="hljs-comment"># 菜单项（可通过“编辑-菜单查找”查看）</span><br>bpy.types.Operator <span class="hljs-comment"># 操作命令（可通过“编辑-操作搜索”查看）</span><br>bpy.types.PropertyGroup <span class="hljs-comment"># 批量存储数据的容器</span><br>bpy.types.KeyingSet<br>bpy.types.RenderEngine<br></code></pre></td></tr></table></figure><p>具体关于这些接口类的解释，留到后续使用时再进行讲述。</p><p>除此之外其实还有些更高级的功能也可以注册，例如网格修改器， 对象类型或着色器节点等，但这些必须要用 C&#x2F;C++实现，故不做讨论。</p><h2 id="Blender-关键概念"><a href="#Blender-关键概念" class="headerlink" title="Blender 关键概念"></a>Blender 关键概念</h2><h3 id="内置资源"><a href="#内置资源" class="headerlink" title="内置资源"></a>内置资源</h3><blockquote><p>所有资源都由集合存储管理，资源的创建销毁是通过对集合的增删来实现。</p></blockquote><p>在此我们把 Blender 自带的数据类型，如物体，网格，材质等叫做内置资源。</p><p>Blender 中所有的内置资源都有专门的类对应，而它们的实例则全部统一存在几个集合中。</p><p>Blender 完全用这些集合控制资源的生命周期，所以资源的创建销毁不能用常规的 new，delete 方式，而是要直接操作这些集合，集合的增删就代表着类的创建销毁。</p><p>这些集合可以通过 bpy.data 进行访问，也可以通过“大纲视图-Blender 文件”界面进行可视化访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 内置资源处理伪码</span><br><span class="hljs-keyword">import</span> bpy<br>newMaterial = bpy.data.materials.new(<span class="hljs-string">&#x27;New Material&#x27;</span>) <span class="hljs-comment"># 创建资源</span><br>oldMaterial = bpy.data.materials[<span class="hljs-string">&#x27;Old Material&#x27;</span>] <span class="hljs-comment"># 获取资源</span><br>bpy.data.materials.remove(oldMaterial) <span class="hljs-comment"># 删除资源</span><br></code></pre></td></tr></table></figure><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><blockquote><p>若要存储或显示自己的数据，必须借助“自定义属性”功能来实现。</p></blockquote><p>自定义属性是 Blender 提供的一种在 Blender 文件中存储数据的方法，除此之外没有其他方式。</p><p>用户可以利用 Blender 提供的属性类创建自己的数据容器，并将其附加到任何一个 Blender 的内置资源上。</p><p>不单是存储数据，如果要在面板上显示数据，也必是自定义属性的数据才行。</p><p>在代码中利用 bpy.props 空间提供的类就能创建自定义属性对象，或在资源面板的“自定义属性”子面板中也能可视化编辑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义数据存储伪码</span><br><span class="hljs-keyword">import</span> bpy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br>    <span class="hljs-comment"># 向Scene类型注册一个名为my_data的自定义属性</span><br>    bpy.types.Scene.my_data = bpy.props.StringProperty()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">unregister</span>():<br>    <span class="hljs-comment"># 取消注册自定义属性</span><br>    <span class="hljs-keyword">del</span> bpy.types.Scene.my_data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_function</span>():<span class="hljs-comment"># 在自己的函数中使用自定义属性</span><br>    bpy.data.scenes[<span class="hljs-string">&#x27;Scene&#x27;</span>].my_data = <span class="hljs-string">&#x27;Hello Blender&#x27;</span> <span class="hljs-comment"># 给名为&quot;Scene&quot;的场景资源中的自定义属性赋值</span><br>    <span class="hljs-built_in">print</span>(bpy.data.scenes[<span class="hljs-string">&#x27;Scene&#x27;</span>].my_data) <span class="hljs-comment"># 读取自定义属性</span><br><br></code></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><blockquote><p>若要实现显示或执行自定义功能，必须借助“运算符”功能来实现。</p></blockquote><p>Blender 中所有的可执行功能也即界面上的按钮都一定对应一个运算符，可以借此在代码中像在用户界面上一样调用这些功能，blender 内置的运算符都存放在 bpy.ops 空间。</p><p>同理若要实现自己的功能并显示在界面上也一定要实现自己的运算符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义运算符伪码</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyOperator</span>(bpy.types.Operator): <span class="hljs-comment"># 某个自定义运算符</span><br>    bl_idname = <span class="hljs-string">&quot;my.operator&quot;</span> <span class="hljs-comment"># 自定义属性的ID</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPanel</span>(bpy.types.Panel): <span class="hljs-comment"># 某个自定义面板</span><br>    layout.operator(MyOperator.bl_idname, text=<span class="hljs-string">&quot;MyOperator&quot;</span>) <span class="hljs-comment"># 显示运算符</span><br><br><span class="hljs-comment"># 两者都需要注册</span><br>bpy.utils.register_class(MyOperator)<br>bpy.utils.register_class(MyPanel)<br></code></pre></td></tr></table></figure><h2 id="Blender-框架结构"><a href="#Blender-框架结构" class="headerlink" title="Blender 框架结构"></a>Blender 框架结构</h2><p>根据框架结构可以了解到 Blender 中有哪些可操作对象，以及它们的关系，配合英文名搜索，可以快速定位目标对象在代码中的修改位置。</p><h3 id="库结构"><a href="#库结构" class="headerlink" title="库结构"></a>库结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">bpy.types <span class="hljs-comment">#blender中所有的类型，可以此为特定类注册自定义属性，以及获取用于继承的接口类。</span><br>bpy.props <span class="hljs-comment">#blender中所有的属性类型，可用于创建自定义属性。</span><br>bpy.ops <span class="hljs-comment">#blender中所有的自带运算符，当成函数调用则可直接运行。</span><br>bpy.data <span class="hljs-comment">#当前文件里所有的资源，对应“大纲视图-Blender文件”界面。</span><br>bpy.context <span class="hljs-comment">#当前编辑环境，如选中的物体，正在使用的编辑模式等。</span><br>bpy.utils <span class="hljs-comment">#可选的帮助函数，注意用于注册或取消注册自定义类。</span><br>bpy.msgbus<br>bpy.path<br>bpy.app<br></code></pre></td></tr></table></figure><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>参考“大纲视图-Blender 文件”界面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">bpy.data.<br>    <span class="hljs-comment">#用户界面相关</span><br>    window_managers. <span class="hljs-comment">#窗口管理器</span><br>    workspaces. <span class="hljs-comment">#工作区：编辑器顶部切换工作区域的工具栏</span><br>    screens. <span class="hljs-comment">#屏幕：编辑器中间的工作区域</span><br>    <span class="hljs-comment">#工具相关</span><br>    brushes. <span class="hljs-comment">#笔刷</span><br>    palettes. <span class="hljs-comment">#调色板</span><br>    <span class="hljs-comment">#场景资源</span><br>    worlds. <span class="hljs-comment">#世界环境</span><br>    collections. <span class="hljs-comment">#集合</span><br>    objects. <span class="hljs-comment">#物体</span><br>    scenes. <span class="hljs-comment">#场景</span><br>    <span class="hljs-comment">#物体资源</span><br>    cameras. <span class="hljs-comment">#摄像机</span><br>    lights. <span class="hljs-comment">#灯光</span><br>    meshes. <span class="hljs-comment">#网格</span><br>    <span class="hljs-comment">#渲染资源</span><br>    images. <span class="hljs-comment">#图像</span><br>    materials. <span class="hljs-comment">#材质</span><br>    linestyles. <span class="hljs-comment">#线条样式</span><br></code></pre></td></tr></table></figure><h3 id="资源结构"><a href="#资源结构" class="headerlink" title="资源结构"></a>资源结构</h3><p>参考“大纲视图-Blender 文件”界面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">bpy.context.<br>    scene. <span class="hljs-comment">#当前场景</span><br>        view_layers. <span class="hljs-comment">#视图层</span><br>        world. <span class="hljs-comment">#世界环境</span><br>        collection. <span class="hljs-comment">#集合</span><br>        objects. <span class="hljs-comment">#物体</span><br>    active_object. <span class="hljs-comment">#当前选中的物体</span><br>        data. <span class="hljs-comment">#物体绑定的数据，存在多种类型</span><br>        data(camera). <span class="hljs-comment">#相机</span><br>        data(light). <span class="hljs-comment">#灯光</span><br>        data(mesh). <span class="hljs-comment">#网格</span><br>            materials. <span class="hljs-comment">#材质</span><br></code></pre></td></tr></table></figure><h3 id="界面结构"><a href="#界面结构" class="headerlink" title="界面结构"></a>界面结构</h3><p>参考 <a href="https://docs.blender.org/manual/en/latest/interface/index.html#window-system">https://docs.blender.org/manual/en/latest/interface/index.html#window-system</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">bpy.context.screen. <span class="hljs-comment">#当前工作区</span><br>    areas. <span class="hljs-comment">#工作区细分为多个功能区域</span><br>        regions. <span class="hljs-comment">#将区域中的界面按部位进一步细分</span><br>        spaces. <span class="hljs-comment">#区域空间信息，存在多种空间类型</span><br>        space(SpaceView3D). <span class="hljs-comment">#3D视图空间</span><br></code></pre></td></tr></table></figure><h4 id="SpaceView3D"><a href="#SpaceView3D" class="headerlink" title="SpaceView3D"></a>SpaceView3D</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">SpaceView3D.<br>    region_3d. <span class="hljs-comment">#3D视图区域数据</span><br>        view_perspective <span class="hljs-comment">#视图投影模式</span><br>        view_camera_offset <span class="hljs-comment">#相机视图偏移</span><br>        view_camera_zoom  <span class="hljs-comment">#相机视图缩放</span><br></code></pre></td></tr></table></figure><h3 id="工具结构"><a href="#工具结构" class="headerlink" title="工具结构"></a>工具结构</h3><h4 id="图像绘制工具"><a href="#图像绘制工具" class="headerlink" title="图像绘制工具"></a>图像绘制工具</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">bpy.context.tool_settings <span class="hljs-comment">#当前使用工具的相关设置</span><br>    image_paint. <span class="hljs-comment">#图像绘制工具</span><br>        brush. <span class="hljs-comment">#当前使用的笔刷</span><br>            texture_slot <span class="hljs-comment">#纹理功能设置</span><br>            stencil_dimension <span class="hljs-comment">#楼板尺寸</span><br>            stencil_pos <span class="hljs-comment">#楼板位置</span><br><br>bpy.context.active_object. <span class="hljs-comment">#当前选择的物体</span><br>    active_material. <span class="hljs-comment">#当前选择的材质球</span><br>        texture_paint_images <span class="hljs-comment">#当前可绘制的贴图</span><br>        paint_active_slot <span class="hljs-comment">#当前绘制中的贴图索引</span><br><br></code></pre></td></tr></table></figure><h2 id="常用接口类"><a href="#常用接口类" class="headerlink" title="常用接口类"></a>常用接口类</h2><h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><p>添加自定义操作时必须要实现 Operator。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">bpy</span>.types.Operator:<br>    <span class="hljs-comment"># 必填，需要按“类别.名称”的ID格式填写，具体内容可自定义，但点号必须要有且全小写。</span><br>    bl_idname : <span class="hljs-built_in">str</span><br>    <span class="hljs-comment"># 必填，表示操作名称。</span><br>    bl_label : <span class="hljs-built_in">str</span><br><br>    <span class="hljs-comment"># 可选，用于告知blender该运算符是否可用。</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">poll</span>(<span class="hljs-params">cls, context</span>) -&gt; <span class="hljs-built_in">bool</span><br><br>    <span class="hljs-comment"># 必填，用于编写执行操作的具体代码。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self, context</span>) -&gt; <span class="hljs-type">Set</span>[<span class="hljs-built_in">str</span>]<br></code></pre></td></tr></table></figure><h3 id="Panel"><a href="#Panel" class="headerlink" title="Panel"></a>Panel</h3><p>添加自定义面板界面时必须要实现 Panel。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">bpy</span>.types.Panel：<br>    <span class="hljs-comment"># 必填，表明该面板应显示在哪种界面空间上。</span><br>    bl_space_type : <span class="hljs-built_in">str</span><br>    <span class="hljs-comment"># 必填，表示该面板的区块类型。</span><br>    bl_region_type : <span class="hljs-built_in">str</span><br>    <span class="hljs-comment"># 必填，表示面板标题。</span><br>    bl_label : <span class="hljs-built_in">str</span><br><br>    <span class="hljs-comment"># 可选，表明显示在所处界面的哪个二级分类下。</span><br>    bl_category : <span class="hljs-built_in">str</span><br><br>    <span class="hljs-comment"># 必填，用于编写绘制界面的代码。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">self,context</span>) -&gt; <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h3 id="PropertyGroup"><a href="#PropertyGroup" class="headerlink" title="PropertyGroup"></a>PropertyGroup</h3><p>自定义参数过多时可以借助 PropertyGroup 实现合并注册。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">bpy</span>.types.PropertyGroup:<br>    <span class="hljs-comment"># 任意个用类型注解表示的自定义属性，不要赋值</span><br>    ......<br></code></pre></td></tr></table></figure><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="绘制界面"><a href="#绘制界面" class="headerlink" title="绘制界面"></a>绘制界面</h3><p>bpy.types.Panel 等类提供名为 layout 的成员变量，该变量提供绘制函数使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用案例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPanel</span>(bpy.types.Panel):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">self, context</span>):<br>        layout = self.layout<br><br>        <span class="hljs-comment"># 显示文字</span><br>        layout.label(text=<span class="hljs-string">&quot;渲染参数&quot;</span>)<br><br>        <span class="hljs-comment"># 显示属性</span><br>        column = layout.column(align=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 创建布局组</span><br>        column.prop(context.scene.render, <span class="hljs-string">&quot;resolution_x&quot;</span>,text=<span class="hljs-string">&quot;宽度&quot;</span>)<br>        column.prop(context.scene.render, <span class="hljs-string">&quot;resolution_y&quot;</span>,text=<span class="hljs-string">&quot;高度&quot;</span>)<br><br>        <span class="hljs-comment"># 显示操作</span><br>        layout.operator(<span class="hljs-string">&quot;view3d.view_center_camera&quot;</span>, text=<span class="hljs-string">&quot;重置摄像机视图&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="弹出信息"><a href="#弹出信息" class="headerlink" title="弹出信息"></a>弹出信息</h3><p>bpy.types.Operator 等类提供名为 report 的成员函数，可以在底部信息栏弹出消息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用案例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyOperator</span>(bpy.types.Operator):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self, context</span>):<br>        <span class="hljs-keyword">if</span>(context.active_object == <span class="hljs-literal">None</span>):<br>            self.report(&#123;<span class="hljs-string">&quot;ERROR&quot;</span>&#125;, <span class="hljs-string">&quot;当前没有激活的物体&quot;</span>)<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;CANCELLED&quot;</span>&#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;FINISHED&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="细节提示"><a href="#细节提示" class="headerlink" title="细节提示"></a>细节提示</h2><ul><li>在注册期间无法访问 bpy.data 和 bpy.context，所以要注册自定义函数必须借助 bpy.types 以类为目标。</li><li>可以借助“编辑”菜单中的“菜单查找”和“操作搜索”找到注册进 blender 的自定义菜单或运算符。</li><li>如果要利用插件传递资源，可以在插件中携带 blender 文件，并利用“关联”和“追加”功能实现。</li><li>如果在自定义运算符的 bl_idname 中使用了非官方的类别，那右键菜单中将缺少指定快捷键功能。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.blender.org/api/current/index.html">Blender 官方 API 文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Blender</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【数据库系统原理（4）】视图处理语句</title>
    <link href="/posts/3037167271.html"/>
    <url>/posts/3037167271.html</url>
    
    <content type="html"><![CDATA[<h1 id="【数据库系统原理（4）】视图处理语句"><a href="#【数据库系统原理（4）】视图处理语句" class="headerlink" title="【数据库系统原理（4）】视图处理语句"></a>【数据库系统原理（4）】视图处理语句</h1><h2 id="创建或修改"><a href="#创建或修改" class="headerlink" title="创建或修改"></a>创建或修改</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123;<span class="hljs-keyword">CREATE</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALTER</span>&#125; <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>viewName<span class="hljs-operator">&gt;</span>[(<span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span>[,...])] <span class="hljs-keyword">as</span> <span class="hljs-operator">&lt;</span>selectSql<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION]<br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> [IF <span class="hljs-keyword">EXISTS</span>] <span class="hljs-operator">&lt;</span>viewName<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>viewName<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>软件开发</category>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【数据库系统原理（3）】数据处理语句</title>
    <link href="/posts/372718776.html"/>
    <url>/posts/372718776.html</url>
    
    <content type="html"><![CDATA[<h1 id="【数据库系统原理（3）】数据处理语句"><a href="#【数据库系统原理（3）】数据处理语句" class="headerlink" title="【数据库系统原理（3）】数据处理语句"></a>【数据库系统原理（3）】数据处理语句</h1><h2 id="语句参数"><a href="#语句参数" class="headerlink" title="语句参数"></a>语句参数</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123; count <span class="hljs-operator">|</span> max <span class="hljs-operator">|</span> min <span class="hljs-operator">|</span> sum <span class="hljs-operator">|</span> avg <span class="hljs-operator">|</span> ... &#125;<br></code></pre></td></tr></table></figure><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123; <span class="hljs-operator">=</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-operator">!=</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;=</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&gt;=</span> &#125;<br><br><span class="hljs-comment">-- &lt;&gt;：早期符号，等同于!=，据说移植和性能略优。</span><br></code></pre></td></tr></table></figure><h3 id="条件描述"><a href="#条件描述" class="headerlink" title="条件描述"></a>条件描述</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123;<br>    <span class="hljs-comment">--将当前值作为条件</span><br>    <span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span> &#123;<br>        比较运算符 <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-comment">--比较值</span><br>        <span class="hljs-keyword">BETWEEN</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">AND</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-comment">--范围值</span><br>        <span class="hljs-keyword">IN</span> (<span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>[,...]) <span class="hljs-operator">|</span> <span class="hljs-comment">--枚举值</span><br>        <span class="hljs-keyword">LIKE</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-comment">--模糊值</span><br>        <span class="hljs-keyword">IS</span> [<span class="hljs-keyword">NOT</span>] <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-comment">--空值</span><br>        [<span class="hljs-keyword">NOT</span>] <span class="hljs-keyword">IN</span> (<span class="hljs-operator">&lt;</span>selectSql<span class="hljs-operator">&gt;</span>) <span class="hljs-comment">--子查询</span><br>        比较运算符 &#123;<span class="hljs-keyword">ALL</span><span class="hljs-operator">|</span><span class="hljs-keyword">ANY</span>&#125; (<span class="hljs-operator">&lt;</span>selectSql<span class="hljs-operator">&gt;</span>) <span class="hljs-comment">--比较子查询</span><br>    &#125;<br>    <span class="hljs-operator">|</span><br>    <span class="hljs-comment">--将子查询作为条件</span><br>    <span class="hljs-keyword">EXISTS</span>(<span class="hljs-operator">&lt;</span>selectSql<span class="hljs-operator">&gt;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="模糊值中的通配符"><a href="#模糊值中的通配符" class="headerlink" title="模糊值中的通配符"></a>模糊值中的通配符</h4><ul><li>%：表示任意 0 个或多个字符，可匹配任意类型和长度的字符。</li><li>_：表示任意单个字符，通常用来限定表达式的字符长度语句。</li><li>[]：表示括号内所列字符中的一个（类似正则表达式）。</li><li>[^]：表示不在括号所列之内的单个字符，相当于[]的否定形式。</li></ul><h3 id="查询列描述"><a href="#查询列描述" class="headerlink" title="查询列描述"></a>查询列描述</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123;<br>    <span class="hljs-comment">--查询当前已有列</span><br>    &#123; <span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> 聚合函数(<span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span>) &#125;<br>    [<span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>newColumnName<span class="hljs-operator">&gt;</span>] <span class="hljs-comment">--调整列名</span><br>    <span class="hljs-operator">|</span><br>    <span class="hljs-comment">--通过表达式计算新列</span><br>    <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> 条件描述 <span class="hljs-keyword">THEN</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>[...] [<span class="hljs-keyword">ELSE</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>] <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整语句"><a href="#完整语句" class="headerlink" title="完整语句"></a>完整语句</h2><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [&#123;<span class="hljs-keyword">ALL</span><span class="hljs-operator">|</span><span class="hljs-keyword">DISTINCT</span>&#125;] &#123;查询列描述[,...]<span class="hljs-operator">|</span><span class="hljs-operator">*</span>&#125;<br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span> [&#123;<span class="hljs-keyword">INNER</span><span class="hljs-operator">|</span><span class="hljs-keyword">LEFT</span><span class="hljs-operator">|</span><span class="hljs-keyword">RIGHT</span>&#125; <span class="hljs-keyword">JOIN</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> 条件描述][,...]<br>[<span class="hljs-keyword">WHERE</span> 条件描述[AND...]]<br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span>[,...] [&#123;<span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>&#125;]] <span class="hljs-comment">--分组归纳（通常配合聚合函数使用）</span><br>[<span class="hljs-keyword">HAVING</span> 条件描述] <span class="hljs-comment">--过滤分组（相当于在GROUP BY之后运行的WHERE语句）</span><br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span>[,...] [&#123;<span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>&#125;]]<br>[LIMIT [<span class="hljs-operator">&lt;</span><span class="hljs-keyword">offset</span><span class="hljs-operator">&gt;</span>,]<span class="hljs-operator">&lt;</span>rowCount<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure><ul><li><code>ORDER BY</code>的排序顺序：先排序前面的条件，然后再遵照此顺序的基础上排序后续条件。</li></ul><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span>[(<span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span>[,...])] <span class="hljs-keyword">VALUES</span> (&#123;<span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">|</span><span class="hljs-keyword">DEFAULT</span>&#125;[,...]);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;=</span>&#123;<span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">|</span><span class="hljs-keyword">DEFAULT</span>&#125;[,...];<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span>[(<span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span>[,...])] <span class="hljs-operator">&lt;</span>selectSql<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">condition</span><span class="hljs-operator">&gt;</span>]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span> [&#123;<span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>&#125;]]<br>[LIMIT <span class="hljs-operator">&lt;</span>rowCount<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;=</span>&#123;<span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">|</span><span class="hljs-keyword">DEFAULT</span>&#125;[,...]<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">condition</span><span class="hljs-operator">&gt;</span>]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span> [&#123;<span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>&#125;]]<br>[LIMIT <span class="hljs-operator">&lt;</span>rowCount<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/weixin_45659364/article/details/115466885">MySQL 不等于的三种表示及区别</a></li><li><a href="https://blog.csdn.net/VariatioZbw/article/details/106938495">SQL 模糊查询【like】的四种匹配模式</a></li><li><a href="https://blog.csdn.net/tyt_XiaoTao/article/details/81532495">sql 语句中 GROUP BY 和 HAVING 的用法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>软件开发</category>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【数据库系统原理（2）】表处理语句</title>
    <link href="/posts/4147230756.html"/>
    <url>/posts/4147230756.html</url>
    
    <content type="html"><![CDATA[<h1 id="【数据库系统原理（2）】表处理语句"><a href="#【数据库系统原理（2）】表处理语句" class="headerlink" title="【数据库系统原理（2）】表处理语句"></a>【数据库系统原理（2）】表处理语句</h1><h2 id="语句参数"><a href="#语句参数" class="headerlink" title="语句参数"></a>语句参数</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123;<span class="hljs-type">INT</span><span class="hljs-operator">|</span><span class="hljs-keyword">DOUBLE</span><span class="hljs-operator">|</span>BOOL<span class="hljs-operator">|</span><span class="hljs-type">DATE</span><span class="hljs-operator">|</span><span class="hljs-type">TIMESTAMP</span><span class="hljs-operator">|</span><span class="hljs-type">TIME</span><span class="hljs-operator">|</span><span class="hljs-type">CHAR</span><span class="hljs-operator">|</span><span class="hljs-type">VARCHAR</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="列级约束"><a href="#列级约束" class="headerlink" title="列级约束"></a>列级约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123;AUTO_INCREMENT<span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="字段描述语句"><a href="#字段描述语句" class="headerlink" title="字段描述语句"></a>字段描述语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span> 数据类型 [列级约束] [<span class="hljs-keyword">DEFAULT</span> <span class="hljs-operator">&lt;</span>defaultValue<span class="hljs-operator">&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="外键关联选项"><a href="#外键关联选项" class="headerlink" title="外键关联选项"></a>外键关联选项</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123;RESTRICT<span class="hljs-operator">|</span>CASCADE<span class="hljs-operator">|</span><span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-keyword">NO</span> ACTION&#125;<br></code></pre></td></tr></table></figure><h3 id="索引目标描述语句"><a href="#索引目标描述语句" class="headerlink" title="索引目标描述语句"></a>索引目标描述语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span>[(<span class="hljs-operator">&lt;</span>length<span class="hljs-operator">&gt;</span>)] [&#123;<span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>&#125;]<br></code></pre></td></tr></table></figure><h3 id="表级约束"><a href="#表级约束" class="headerlink" title="表级约束"></a>表级约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>主键，名称为<span class="hljs-keyword">PRIMARY</span><br><span class="hljs-keyword">PRIMARY</span> KEY(<span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span>)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>外键<br><span class="hljs-keyword">FOREIGN</span> KEY [<span class="hljs-operator">&lt;</span>name<span class="hljs-operator">&gt;</span>](<span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span>[,...])<br><span class="hljs-keyword">REFERENCES</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span>(<span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span>[,...])<br>[<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> 外键关联选项]<br>[<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> 外键关联选项]<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>索引<br>[<span class="hljs-keyword">UNIQUE</span>] INDEX [<span class="hljs-operator">&lt;</span>name<span class="hljs-operator">&gt;</span>](索引目标描述语句[,...])<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>检查<br><span class="hljs-keyword">CHECK</span>(<span class="hljs-operator">&lt;</span><span class="hljs-keyword">condition</span><span class="hljs-operator">&gt;</span>)<br></code></pre></td></tr></table></figure><h2 id="完整语句"><a href="#完整语句" class="headerlink" title="完整语句"></a>完整语句</h2><h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TABLES;<br></code></pre></td></tr></table></figure><h3 id="查看列"><a href="#查看列" class="headerlink" title="查看列"></a>查看列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> COLUMNS <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h3 id="查看约束"><a href="#查看约束" class="headerlink" title="查看约束"></a>查看约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEXES <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span><br>[TEMPORARY] <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span><br>(<br>    字段描述语句[,...]<br>    [表级约束]<br>);<br></code></pre></td></tr></table></figure><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">RENAME <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>oldtableName<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h3 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span><br>    [<span class="hljs-keyword">ADD</span> 字段描述语句][,...] <span class="hljs-operator">/</span><span class="hljs-operator">/</span>添加列<br>    [CHANGE <span class="hljs-operator">&lt;</span>oldcolumnName<span class="hljs-operator">&gt;</span> 字段描述语句][,...] <span class="hljs-operator">/</span><span class="hljs-operator">/</span>啥都可以修改<br>    [<span class="hljs-keyword">ALTER</span> <span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-operator">&lt;</span>defaultValue<span class="hljs-operator">&gt;</span>][,...] <span class="hljs-operator">/</span><span class="hljs-operator">/</span>修改默认值<br>    [MODIFY <span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span> 数据类型 &#123;<span class="hljs-keyword">FIRST</span><span class="hljs-operator">|</span>AFTER [<span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span>]&#125;[,...] <span class="hljs-operator">/</span><span class="hljs-operator">/</span>修改数据类型和位置<br>    [<span class="hljs-keyword">DROP</span> <span class="hljs-operator">&lt;</span>columnName<span class="hljs-operator">&gt;</span>][,...] <span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除列<br>    [&#123;<span class="hljs-keyword">ADD</span><span class="hljs-operator">|</span><span class="hljs-keyword">DROP</span>&#125; 表级约束];<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>增删表级约束<br></code></pre></td></tr></table></figure><h3 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span><br>[<span class="hljs-keyword">UNIQUE</span>] INDEX [<span class="hljs-operator">&lt;</span>indexName<span class="hljs-operator">&gt;</span>] <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span>(索引目标描述语句[,...]);<br></code></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span><br>[TEMPORARY] <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">EXISTS</span>] <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h3 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX <span class="hljs-operator">&lt;</span>indexName<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>软件开发</category>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【数据库系统原理（1）】库处理语句</title>
    <link href="/posts/4219286117.html"/>
    <url>/posts/4219286117.html</url>
    
    <content type="html"><![CDATA[<h1 id="【数据库系统原理（1）】库处理语句"><a href="#【数据库系统原理（1）】库处理语句" class="headerlink" title="【数据库系统原理（1）】库处理语句"></a>【数据库系统原理（1）】库处理语句</h1><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>u <span class="hljs-operator">&lt;</span><span class="hljs-keyword">user</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">-</span>p<br><span class="hljs-operator">&lt;</span>password<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;<br></code></pre></td></tr></table></figure><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span><br>DATABASE [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] <span class="hljs-operator">&lt;</span>name<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span><br>DATABASE <span class="hljs-operator">&lt;</span>name<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE <span class="hljs-operator">&lt;</span>name<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>软件开发</category>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Manim】空间与变换笔记</title>
    <link href="/posts/3454987331.html"/>
    <url>/posts/3454987331.html</url>
    
    <content type="html"><![CDATA[<h1 id="【Manim】空间与变换笔记"><a href="#【Manim】空间与变换笔记" class="headerlink" title="【Manim】空间与变换笔记"></a>【Manim】空间与变换笔记</h1><p>所有常量都可以在constants.py中找到</p><h2 id="屏幕空间"><a href="#屏幕空间" class="headerlink" title="屏幕空间"></a>屏幕空间</h2><p>屏幕中心为原点(0,0,0)，遵循右手坐标系，向右为x轴正方向，向上为y轴正方向，向前为z轴负方向，旋转时正方向为顺时针方向。</p><h3 id="相关常量"><a href="#相关常量" class="headerlink" title="相关常量"></a>相关常量</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>FRAME_HEIGHT</td><td>屏幕高度，默认为8</td></tr><tr><td>FRAME_WIDTH</td><td>屏幕宽度，默认为ASPECT_RATIO * FRAME_HEIGHT</td></tr><tr><td>ASPECT_RATIO</td><td>屏幕宽高比，默认为16 &#x2F; 9</td></tr><tr><td>FRAME_Y_RADIUS</td><td>屏幕高度的一半</td></tr><tr><td>FRAME_X_RADIUS</td><td>屏幕宽度的一半</td></tr></tbody></table><h2 id="向量（np-ndarray）"><a href="#向量（np-ndarray）" class="headerlink" title="向量（np.ndarray）"></a>向量（np.ndarray）</h2><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.array([x,y,z])<br></code></pre></td></tr></table></figure><h3 id="相关常量-1"><a href="#相关常量-1" class="headerlink" title="相关常量"></a>相关常量</h3><table><thead><tr><th>名称</th><th>对应坐标</th><th>描述</th></tr></thead><tbody><tr><td>RIGHT</td><td>(1,0,0)</td><td></td></tr><tr><td>UP</td><td>(0,1,0)</td><td></td></tr><tr><td>LEFT</td><td>(-1,0,0)</td><td></td></tr><tr><td>DOWN</td><td>(0,-1,0)</td><td></td></tr><tr><td>UR</td><td>(1,1,0)</td><td></td></tr><tr><td>UL</td><td>(-1,1,0)</td><td></td></tr><tr><td>DR</td><td>(1,-1,0)</td><td></td></tr><tr><td>DL</td><td>(-1,-1,0)</td><td></td></tr><tr><td>TOP</td><td>(0,FRAME_Y_RADIUS,0)</td><td>屏幕最上方</td></tr><tr><td>BOTTOM</td><td>(0,-FRAME_Y_RADIUS,0)</td><td>屏幕最下方</td></tr><tr><td>RIGHT_SIDE</td><td>(FRAME_X_RADIUS,0,0)</td><td>屏幕最右方</td></tr><tr><td>LEFT_SIDE</td><td>(-FRAME_X_RADIUS,0,0)</td><td>屏幕最左方</td></tr><tr><td>OUT</td><td>(0,0,1)</td><td></td></tr><tr><td>IN</td><td>(0,0,-1)</td><td></td></tr></tbody></table><h2 id="变换函数"><a href="#变换函数" class="headerlink" title="变换函数"></a>变换函数</h2><p>以下都是Mobject对象的成员函数。</p><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>shift</td><td>移动物体</td></tr><tr><td>move_to</td><td>移动物体到指定位置</td></tr><tr><td>scale</td><td>缩放物体</td></tr><tr><td>rotate</td><td>旋转物体</td></tr><tr><td>flip</td><td>翻转物体</td></tr><tr><td>stretch</td><td>拉伸物体</td></tr><tr><td>to_corner</td><td>移动物体到屏幕角落</td></tr><tr><td>to_edge</td><td>移动物体到屏幕边缘</td></tr><tr><td>align_to</td><td>对齐物体</td></tr><tr><td>next_to</td><td>排列物体</td></tr><tr><td>set_height</td><td>设置物体高度</td></tr><tr><td>set_width</td><td>设置物体宽度</td></tr></tbody></table><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>以下为部分举例，因为内容过多，不同函数参数也有不同，所有不方便记。但相关内容我也没在文档里找到，不过我发现在源码里可以找到。每个类可用的参数，都作为字典写在了类结构里，翻翻几个基类的源文件就知道了。</p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>aligned_edge</td><td>设置物体相对于目标点的对齐方式</td></tr><tr><td>coor_mask</td><td>限制物体在部分轴上不运动</td></tr><tr><td>about_edge</td><td>设置相对于边沿的运动</td></tr><tr><td>about_point</td><td>设置相对于点位的运动</td></tr><tr><td>buff</td><td>设置相对于默认变换结果的空间空隙</td></tr><tr><td>submobject_to_align</td><td>使用子物体进行对齐</td></tr><tr><td>index_of_submobject_to_align</td><td>对齐到目标的子物体</td></tr></tbody></table><h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><p>需要配合scene.play使用，下方为举例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">self.play(<br>    image.shift,<br>    np.array([<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])<br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
      <category>Manim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【软件开发】Git 概念与常用命令</title>
    <link href="/posts/3993342442.html"/>
    <url>/posts/3993342442.html</url>
    
    <content type="html"><![CDATA[<h1 id="【软件开发】Git-概念与常用命令"><a href="#【软件开发】Git-概念与常用命令" class="headerlink" title="【软件开发】Git 概念与常用命令"></a>【软件开发】Git 概念与常用命令</h1><h2 id="Git-概念"><a href="#Git-概念" class="headerlink" title="Git 概念"></a>Git 概念</h2><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>Git 是分布式存储，每一个 clone 下来的仓库都可以看成独立的个体，只是 Git 有提供同步功能，因此 Git 支持离线使用，因为本质上本地和云端是两个仓库。</p><h3 id="仓库构成"><a href="#仓库构成" class="headerlink" title="仓库构成"></a>仓库构成</h3><h4 id="提交（commit）"><a href="#提交（commit）" class="headerlink" title="提交（commit）"></a>提交（commit）</h4><p>提交是存储文件的最基本元素，记录了每次对文件的修改信息，同时也是仓库文件状态判断的基点。多个提交对文件的修改可能是顺序进行也可能是同步进行，同步的结果往往会导致冲突。</p><h4 id="分支（branch）"><a href="#分支（branch）" class="headerlink" title="分支（branch）"></a>分支（branch）</h4><p>分支引用了提交并将其串成一条时间线，外界也由此得以查看提交。不同分支引用的时间线可能重叠也可能分离，形成一个树状结构，但最终分支都是要合并的，这也意味着所有提交最终都会形成一条唯一的时间线。</p><h4 id="子模块（submodule）"><a href="#子模块（submodule）" class="headerlink" title="子模块（submodule）"></a>子模块（submodule）</h4><p>子模块是对其他仓库中的引用，具体而言是引用了分支-提交，对本仓库而言它也是一种受版本控制的文件，文件中存放着引用信息，所以和正常文件一样，修改时要添加到暂存区，删除时也要从仓库区中移除。</p><p>子模块所引用的分支版本信息可以从.git&#x2F;index 文件中找到。</p><h4 id="标签（tag）"><a href="#标签（tag）" class="headerlink" title="标签（tag）"></a>标签（tag）</h4><p>标签实质是给提交起一个别名从而方便识别，这是一个可选功能，通常人们会借此把一些关键的提交打上标签，如记录版本号和发布信息。</p><h4 id="远端（remote）"><a href="#远端（remote）" class="headerlink" title="远端（remote）"></a>远端（remote）</h4><p>远端是用于同步的其他仓库，以便备份或多人协助，因为是分布式存储，每个仓库都是独立的个体，所以不提供远端也是可以的。</p><h3 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h3><p>这两个区域是本地工作用仓库独有的内容，在云端的裸仓库中没有这两者的存在。这主要是为了安全和便于工作使用的临时区域，每一次的文件修改都要按顺序提交到每个区域，当仓库指向的提交变更时它们便会被重置。</p><ul><li>工作区：用户编写代码的地方，文件资源管理器能直接看到的部分。</li><li>暂存区：提交代码前必须先将工作区的所有的文件添加到暂存区。</li><li>仓库区：将暂存区的代码修改变成提交，真正的存储到仓库中。</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="通用项"><a href="#通用项" class="headerlink" title="通用项"></a>通用项</h3><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><ul><li>HEAD：表示最新的一次提交。</li><li>HEAD~1：表示最新提交的前一次提交。</li><li>-h：任何命令加该选项，可以快速查看使用方式。</li><li>–help：任何命令加该选项，可以查看命令的详细手册。</li></ul><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li><p>commit、tag、branch 互换：</p><p>tag 是 commit 的别名，两者等价。使用 branch 则会使用其 HEAD。</p></li><li><p>file 通配：</p><p>file 支持 glob 通配符，也可用“.”表示全部可处理文件。</p></li></ul><h3 id="仓库初始化和配置"><a href="#仓库初始化和配置" class="headerlink" title="仓库初始化和配置"></a>仓库初始化和配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init [--bare] <span class="hljs-comment">#在当前文件夹创建一个空仓库</span><br>git <span class="hljs-built_in">clone</span> --recursive &lt;url&gt; <span class="hljs-comment">#从远端克隆一个仓库到当前目录</span><br><br><br>git config &lt;name&gt; <span class="hljs-comment">#查看仓库的指定项配置</span><br>git config [--global] &lt;name&gt; &lt;value&gt; <span class="hljs-comment">#添加或修改[全局]仓库配置</span><br>git config [--global] --<span class="hljs-built_in">unset</span> &lt;name&gt; <span class="hljs-comment">#删除[全局]仓库配置</span><br>git config [--<span class="hljs-built_in">local</span>] --list <span class="hljs-comment">#查看[本地]仓库所有配置</span><br></code></pre></td></tr></table></figure><h3 id="仓库信息查看"><a href="#仓库信息查看" class="headerlink" title="仓库信息查看"></a>仓库信息查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -a <span class="hljs-comment">#查看仓库中的所有分支</span><br>git submodule <span class="hljs-comment">#查看当前分支的子模块</span><br>git <span class="hljs-built_in">log</span> <span class="hljs-comment">#查看当前分支的所有提交记录</span><br>git tag <span class="hljs-comment">#查看当前仓库所有标签</span><br>git status <span class="hljs-comment">#查看存储区状态</span><br>git diff <span class="hljs-comment">#查看文件差异</span><br>git reflog <span class="hljs-comment">#查看当前仓库操作记录（可用于还原reset）</span><br></code></pre></td></tr></table></figure><h3 id="存储区处理"><a href="#存储区处理" class="headerlink" title="存储区处理"></a>存储区处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">git ls-files [--cached] <span class="hljs-comment">#查看工作区[暂存区]文件</span><br><br>git add &lt;file&gt; <span class="hljs-comment">#提交工作区文件到暂存区</span><br>git <span class="hljs-built_in">rm</span> [--cached] &lt;file&gt;... <span class="hljs-comment">#删除工作区[暂存区]文件</span><br>git restore [--staged] &lt;file&gt; <span class="hljs-comment">#复原工作区[暂存区]文件</span><br>git commit -m <span class="hljs-string">&#x27;&lt;message&gt;&#x27;</span> <span class="hljs-comment">#提交暂存区文件到仓库区</span><br><br>git stash <span class="hljs-comment">#暂存工作区修改，使工作区看起来干净了，从而安全执行切换分支等命令</span><br>git stash pop <span class="hljs-comment">#取出暂存的工作区修改</span><br><br>git reset [--hard] &lt;commit&gt; <span class="hljs-comment">#将当前分支[包含工作区]重置到某次提交的状态</span><br></code></pre></td></tr></table></figure><h3 id="分支处理"><a href="#分支处理" class="headerlink" title="分支处理"></a>分支处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch &lt;new-branch&gt; <span class="hljs-comment">#创建一个基于当前分支最新提交的新分支</span><br>git branch &lt;new-branch&gt; &lt;commit&gt; <span class="hljs-comment">#创建一个基于目标提交的新分支</span><br>git branch -m &lt;new-name&gt; <span class="hljs-comment">#重命名当前分支</span><br>git branch -d &lt;branch&gt; <span class="hljs-comment">#删除目标分支</span><br><br>git checkout --orphan temp <span class="hljs-comment">#保持工作区不变，创建并切换到一个空分支，</span><br>git switch -c &lt;new-branch&gt; &lt;commit&gt; <span class="hljs-comment">#创建并切换到基于某次提交的新分支</span><br>git switch &lt;branch&gt; <span class="hljs-comment">#切换到目标分支</span><br>git switch --detach &lt;commit&gt; <span class="hljs-comment">#创建并切换到以某次提交为头的临时匿名分支</span><br><br>git rebase -i &lt;commit&gt; <span class="hljs-comment">#进入提交融并功能，可融并指定提交之后的所有提交（使用空融并配置可以退出该功能）</span><br>git rebase &lt;branch&gt; <span class="hljs-comment">#将目标分支覆盖到当前分支</span><br>git merge &lt;branch&gt; <span class="hljs-comment">#将目标分支合并到当前分支</span><br></code></pre></td></tr></table></figure><h3 id="子模块处理"><a href="#子模块处理" class="headerlink" title="子模块处理"></a>子模块处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git submodule add &lt;url&gt; &lt;path&gt; <span class="hljs-comment">#添加一个子模块到目标路径</span><br>git submodule init <span class="hljs-comment">#初始化子模块，将子模块信息填入config中</span><br>git submodule update <span class="hljs-comment">#检出父项目期望版本的子模块内容，使用前需确保子模块已初始化</span><br>git submodule deinit &lt;path&gt; <span class="hljs-comment">#移除子模块，恢复到未初始化的状态（不是删除仓库对子模块的引用）</span><br></code></pre></td></tr></table></figure><h3 id="标签处理"><a href="#标签处理" class="headerlink" title="标签处理"></a>标签处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag -f &lt;tagname&gt; [&lt;commit&gt;] <span class="hljs-comment">#给当前[指定]提交打上标签</span><br>git tag -d &lt;tagname&gt; <span class="hljs-comment">#删除指定标签</span><br></code></pre></td></tr></table></figure><h3 id="远端处理"><a href="#远端处理" class="headerlink" title="远端处理"></a>远端处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote <span class="hljs-comment">#查看当前所有的远端仓库</span><br>git remote show &lt;name&gt; <span class="hljs-comment">#查看指定远端仓库的具体信息，包括pull、push的目标设置</span><br>git remote add &lt;name&gt; &lt;url&gt; <span class="hljs-comment">#添加一个远端仓库</span><br>git remote rename &lt;name&gt; &lt;new-name&gt; <span class="hljs-comment">#重命名远端仓库</span><br>git remote remove &lt;name&gt; &lt;new-name&gt; <span class="hljs-comment">#删除远端仓库</span><br>git remote set-url &lt;name&gt; &lt;url&gt; <span class="hljs-comment">#修改远端仓库地址</span><br>git remote set-url &#123;--add|--delete&#125; &lt;name&gt; &lt;newurl&gt; <span class="hljs-comment">#为远端仓库额外添加或删除地址，借此实现多端提交。</span><br><br>git fetch <span class="hljs-comment">#获取所有远端分支</span><br>git pull <span class="hljs-comment">#获取并合并远端分支到当前状态，等同于 fetch + merge</span><br>git push [--force] <span class="hljs-comment">#将当前本地分支状态[强制]推送到远端分支</span><br>git push &lt;remote&gt; -d &lt;branch&gt; <span class="hljs-comment">#删除目标远程上的分支</span><br></code></pre></td></tr></table></figure><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="处理网络代理"><a href="#处理网络代理" class="headerlink" title="处理网络代理"></a>处理网络代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加网络代理，url例如http://localhost:10809，具体根据不同的代理软件可能有所不同。</span><br>git config --global http.proxy &lt;url&gt;<br>git config --global https.proxy &lt;url&gt;<br><span class="hljs-comment"># 清除网络代理</span><br>git config --global --<span class="hljs-built_in">unset</span> proxy.http<br>git config --global --<span class="hljs-built_in">unset</span> proxy.https<br></code></pre></td></tr></table></figure><h3 id="彻底删除子模块"><a href="#彻底删除子模块" class="headerlink" title="彻底删除子模块"></a>彻底删除子模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git submodule deinit &lt;path&gt; <span class="hljs-comment">#将子模块转为未初始化状态</span><br>git <span class="hljs-built_in">rm</span> &lt;path&gt; <span class="hljs-comment">#在子模块未初始化时调用，能彻底删除子模块引用，且自动修改.gitmodules文件</span><br><span class="hljs-built_in">rm</span> -rf .git/modules/&lt;path&gt; <span class="hljs-comment">#删除失效的子模块仓库</span><br></code></pre></td></tr></table></figure><h3 id="撤回上次提交版本"><a href="#撤回上次提交版本" class="headerlink" title="撤回上次提交版本"></a>撤回上次提交版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset HEAD~1 <span class="hljs-comment">#将仓库区和暂存区撤回到上次提交之前的状态</span><br>git push --force <span class="hljs-comment">#强制覆盖远端分支以丢弃上次提交版本</span><br></code></pre></td></tr></table></figure><h3 id="清除所有历史记录"><a href="#清除所有历史记录" class="headerlink" title="清除所有历史记录"></a>清除所有历史记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout --orphan temp <span class="hljs-comment">#创建并切换到一个新的空分支，保留工作区文件</span><br>git branch -D &lt;branch&gt; <span class="hljs-comment">#删除旧分支</span><br>git branch -m &lt;branch&gt; <span class="hljs-comment">#空分支继续使用旧分支的名称</span><br>git add . <span class="hljs-comment">#提交当前所有文件到空分支暂存区</span><br>git commit -m <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-comment">#提交暂存区文件作为初始提交</span><br>git push --force <span class="hljs-comment">#强制覆盖到远程仓库，分支记录将重新开始</span><br></code></pre></td></tr></table></figure><h3 id="清除工作区中所有未被跟踪的文件"><a href="#清除工作区中所有未被跟踪的文件" class="headerlink" title="清除工作区中所有未被跟踪的文件"></a>清除工作区中所有未被跟踪的文件</h3><p>无法撤销，用前一定要备份！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -dfx <span class="hljs-comment">#清除工作区中所有未被跟踪的文件</span><br></code></pre></td></tr></table></figure><h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title="gitignore 文件"></a>gitignore 文件</h2><h3 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式"></a>书写格式</h3><ul><li><p>每行一个忽略项。</p></li><li><p>支持<code>*</code>作为通配符。</p></li><li><p>限定忽略项类型：</p><ul><li>文件或目录：只填完全名称，如<code>test</code>、<code>text.txt</code>。</li><li>仅目录：添加<code>/</code>后缀，如<code>test/</code>。</li></ul></li><li><p>限定忽略项位置：</p><ul><li>从当前目录匹配：带<code>/</code>前缀，如<code>/test</code>。</li><li>从任意目录匹配：不带任何前缀，如<code>test</code>。</li></ul></li><li><p>添加<code>!</code>前缀取消忽略，如<code>!test.txt</code>。</p><p>注意如果整个目录都被忽略了，那没法生效。</p></li></ul><h3 id="取消跟踪"><a href="#取消跟踪" class="headerlink" title="取消跟踪"></a>取消跟踪</h3><p>gitignore 只能忽略未跟踪文件，如果文件已被跟踪需先从仓库中删去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> --cached &lt;file&gt; <span class="hljs-comment"># 删除暂存区中的某文件</span><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/156615362">Git Submodule 命令与理解</a></li><li><a href="https://zhuanlan.zhihu.com/p/139321091">Git 合并多个提交的正确方式</a></li><li><a href="https://www.freecodecamp.org/chinese/news/gitignore-file-how-to-ignore-files-and-folders-in-git/">如何在 Git 中忽略文件和文件夹</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【软件开发】设计模式个人解读</title>
    <link href="/posts/2553791405.html"/>
    <url>/posts/2553791405.html</url>
    
    <content type="html"><![CDATA[<h1 id="【软件开发】设计模式个人解读"><a href="#【软件开发】设计模式个人解读" class="headerlink" title="【软件开发】设计模式个人解读"></a>【软件开发】设计模式个人解读</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是一种针对面向对象语言的软件设计方法，是对类设计的约束和指导。</p><p>设计模式由“原则”和“方法”两部分组成，一个设计良好的项目结构应能完美符合“原则”中的要求，而为了实现完美往往需要按照“方法”的指导去设计。</p><ul><li>原则：<br>这是必须要记住的内容，但要注意的是原则是一种思想，仅靠死记硬背一点用都没有，必须要真正理解后才能使用。</li><li>方法：<br>方法在各个不同的开发环境中可能会有所区别，所以仅是一种参考，具体还需要配合相关原则因地制宜的使用，若不知其意却强行使用结果只会东施效颦。而且只要真正理解了设计原则，并且对编程语言足够熟悉的话，设计方法是可以自己推导出来的，所以若是特意要去背着玩意我觉得有点吃力不讨好。</li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>对于一个设计良好项目所应具有的特征，设计模式提出了7点原则。</p><h3 id="一、开闭原则"><a href="#一、开闭原则" class="headerlink" title="一、开闭原则"></a>一、开闭原则</h3><p>这是设计模式最根本的原则，可以说其他原则也都是为满足这一原则而产生的，同时这也是面向对象方法的特点和优势，正因为面向对象语言中的种种特性开闭原则才得以实现。</p><blockquote><p>程序的功能扩展不能以直接修改源代码的方式进行。</p></blockquote><p>程序出Bug的根本原因就是增改代码，只要现有代码被改动就可能导致出错，如果代码间存在耦合那其他功能也必然会受到牵连，而且这种方式对团队协作也很不友好。</p><p>所以通过直接改原代码来扩展功能是很不明智的，为此我们要发挥面向对象方法，另辟蹊径的解决它，而在设计对象时按以下原则进行，可以更好的满足需求。</p><h3 id="设计父子关系（继承方案）"><a href="#设计父子关系（继承方案）" class="headerlink" title="设计父子关系（继承方案）"></a>设计父子关系（继承方案）</h3><h3 id="二、里氏替换原则"><a href="#二、里氏替换原则" class="headerlink" title="二、里氏替换原则"></a>二、里氏替换原则</h3><blockquote><p>确保任何基类可以出现的地方，一定可以子类实现并代替，且替换后子类不会影响原功能的运行。</p></blockquote><p>利用继承和多态，我们便可以实现完全不动老代码方式扩展功能，从而满足开闭原则，而针对这种编程方式，我们给它命名为“面向接口编程”，而针对面向接口编程的设计方案又给我们带来了下面的这些原则。</p><h3 id="三、依赖倒转原则"><a href="#三、依赖倒转原则" class="headerlink" title="三、依赖倒转原则"></a>三、依赖倒转原则</h3><blockquote><p>如果某功能存在扩展的需求，那我们应当将这部分代码接口化来隐藏细节，实现让功能依赖于接口而非实现。</p></blockquote><p>实现不再被依赖，所以它可以成为一个个独立自由的个体，我们可以很方便很安全的进行开发和修改，且不会干扰到原有模块，因为他们只认接口而非实现。</p><h3 id="四、接口隔离原则"><a href="#四、接口隔离原则" class="headerlink" title="四、接口隔离原则"></a>四、接口隔离原则</h3><blockquote><p>在设计接口时应保证模块化，保证任何接口内容的使用都是必要的。</p></blockquote><p>面向接口编程时，在设计上应尽可能保证提供多个相互独立的接口，而非臃肿的一整块，这可以减少耦合性，不然这些接口反而会成为累赘，逼着别人违反单一职责原则。</p><h3 id="设计对象关系（组合方案）"><a href="#设计对象关系（组合方案）" class="headerlink" title="设计对象关系（组合方案）"></a>设计对象关系（组合方案）</h3><h3 id="五、合成复用原则"><a href="#五、合成复用原则" class="headerlink" title="五、合成复用原则"></a>五、合成复用原则</h3><blockquote><p>实现功能复用时优先采用组合或聚合，其次才考虑继承。</p></blockquote><p>继承仍然会产生耦合性，子类将无法摆脱父类的存在，在部分开发框架下还会水土不服（如Unity中替换父子组件依旧需要删除重建），所以合成复用原则引导我们使用另一种解决方案“组合”。</p><p>组合是直接通过增设更多的功能模块从而实现功能的扩展，它不受一些继承问题带来的限制，产生的耦合性也小的多，而具体的模块设计方案，则引出了下面的原则。</p><h3 id="六、单一职责原则"><a href="#六、单一职责原则" class="headerlink" title="六、单一职责原则"></a>六、单一职责原则</h3><blockquote><p>每个模块都应该仅负责少量且专精的功能（模块内高内聚）。</p></blockquote><h3 id="七、最少知道原则（迪米特原则）"><a href="#七、最少知道原则（迪米特原则）" class="headerlink" title="七、最少知道原则（迪米特原则）"></a>七、最少知道原则（迪米特原则）</h3><blockquote><p>一个模块应尽可能减少对其他模块的使用，使系统功能相对独立（模块间低耦合）。</p></blockquote><h2 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h2><p>创建型模式（5）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构型模式（7）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式（11）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Unity中采用设计模式的例子？"><a href="#Unity中采用设计模式的例子？" class="headerlink" title="Unity中采用设计模式的例子？"></a>Unity中采用设计模式的例子？</h3><p>Unity框架中，所有碰撞体都继承了Collider类，通过里氏替换原则，子类得以可以自由扩展功能，且Unity还不需要做任何额外工作，一套旧代码就能处理任何新子类。</p><p>不同碰撞体间的差异需求导致产生了诸如BoxCollider，SphereCollider等子类，这些子类符合单一职责原则和最少知道原则，仅额外简单的实现了些形状上的差异，所以开发和使用时也不会相互影响。</p><p>但一个刚体往往需要的形状是非常复杂的，上述这些碰撞体由于过于简单都无法满足需求，此时Unity便采用组合的方式，支持将不同碰撞体同时使用，这样不需要写任何代码就能随意搭配更复杂的碰撞形状来。</p><p>假如不采用上述方案，那每一个子类都要单独写处理的代码，每一个新需求又会导致要重新写一个新子类，一两个还好，要是几十几百个，那项目维护开发绝对是灾难性的。</p><h3 id="为什么设计模式中只提到了类和接口而没提事件委托？"><a href="#为什么设计模式中只提到了类和接口而没提事件委托？" class="headerlink" title="为什么设计模式中只提到了类和接口而没提事件委托？"></a>为什么设计模式中只提到了类和接口而没提事件委托？</h3><p>虽然上文只提到了类和接口，但实际上包括一些语言中的委托事件这些都应该算在内，因为它们都有一个共同特点就是都有将算法的一部分参数化的功能。那为何此处只提到了类和接口呢？如果使用过java就很容易理解了，因为java中不存在委托类型，到处使用的都只有接口和匿名类，而它们其实就是委托事件的前身。</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【COM3D2Mod 制作教程（6）】实战！制作身体部分（下）</title>
    <link href="/posts/3074968628.html"/>
    <url>/posts/3074968628.html</url>
    
    <content type="html"><![CDATA[<h1 id="【COM3D2Mod-制作教程（6）】实战！制作身体部分（下）"><a href="#【COM3D2Mod-制作教程（6）】实战！制作身体部分（下）" class="headerlink" title="【COM3D2Mod 制作教程（6）】实战！制作身体部分（下）"></a>【COM3D2Mod 制作教程（6）】实战！制作身体部分（下）</h1><p>有了上一章制作帽子的经验，此时做头发很多就不必再重复赘述了，但如果用完全一样的流程和方法，把头发做好后直接装扮就会导致游戏报错，这就是我之前说的，不同装扮的制作需求并不是一成不变的，所以本章就也就此开始。</p><h2 id="一-制作头发-Mod"><a href="#一-制作头发-Mod" class="headerlink" title="一. 制作头发 Mod"></a>一. 制作头发 Mod</h2><p>头发装扮的大部分制作流程和帽子的流程都是一样的，比如也要绑骨骼，写 menu，设置 mate、tex 这些，但光这些还不够，因为头发是支持更换颜色的，它额外有一套帽子没有的颜色系统需要我们处理。</p><p>重复的流程我就不展示了，利用和上一章类似的做法制作就行，<strong>但提醒一点：如 mate、tex 等文件是可以共用的，在 blender 中共用材质就行，可千万别傻傻的又去做一遍</strong>。</p><p>那接下来我就直接开始讨论关于头发中的新增流程</p><h3 id="menu-中的颜色选项"><a href="#menu-中的颜色选项" class="headerlink" title="menu 中的颜色选项"></a>menu 中的颜色选项</h3><p>头发的 menu 比帽子多了很多新条目，但还是那句话多一事不如少一事，看不懂就不需要管，那些选项里大部分都是内置数据所以当成默认值就好，唯有一个“Color-Set”选项里面引用了一个外部文件，显然这个我们肯定是要处理的。</p><p><img src="/assets/images/2454431-20230909163619028-2072944300.jpg" alt="img"></p><h4 id="这个外部-menu-是什么？"><a href="#这个外部-menu-是什么？" class="headerlink" title="这个外部 menu 是什么？"></a>这个外部 menu 是什么？</h4><p>从命名来看这个 menu 显然不属于任何一个特定模型，应该是某种官方的通用文件，那简单，我们直接用我们的导出器找来看看就知道了：<br><img src="/assets/images/2454431-20230909170200300-711403226.jpg" alt="img"></p><p>并没有找到名为“haircolor_*.menu”的文件，但如果不限定“ * ”内容，那就可以找到好多同类文件，有理由怀疑此处的“ * ”是起到一种通配符的作用，那样的话这个条目应该是起到了一个提供大量颜色选项的功能。这么一说的话你联想到了吗？没错，这就是头发装扮中额外的发色菜单。<br><img src="/assets/images/2454431-20230909164915656-404335355.jpg" alt="img"></p><h4 id="如何选择发色选项？"><a href="#如何选择发色选项？" class="headerlink" title="如何选择发色选项？"></a>如何选择发色选项？</h4><p>现在我们已经知道了上述 menu 就是发色选项而已，因此我们的头发也必须要选择一种颜色（我已经试过删除这个条目了，那样会报错），但实际上由于我们的的原贴图上本身就有颜色，所以我们是不需要二次发色调整的，因此如果必须要混合颜色，那我们需要的是白色，但显然菜单里没有白色选项啊，别慌看一下这些菜单选项的具体内容（下图），就可以从中发现这些端倪。</p><p><img src="/assets/images/2454431-20230909170428129-132852622.jpg" alt="img"></p><p>黑色的 rgb 值明明是(0,0,0)结果上图的画线处却是(255,255,255)，这不明明是白色吗？而且想想也很不对劲，要是真拿黑色做混合颜色，那不就相当于原贴图内容完全失效了吗？所以啊，其实这个名为黑色的选项实际上就是我们想要的白色。</p><p>另外一件可怕的事是上图的画圈处，里面大量使用了些外部 tex 文件，而且不少都是带“ * ”通配符的，所以这些贴图很可能是需要我们准备的，而且每种颜色需要的 tex 都不同，想想就头大，所以也是为了偷懒，我们就定死一个颜色选项，黑色好了。</p><h4 id="实战结果"><a href="#实战结果" class="headerlink" title="实战结果"></a>实战结果</h4><p>根据上文分析，我们的 menu 文件就知道如何修改了，把原颜色选项定死为黑色（如下图），另外上文那些未知 tex 需求，也将推动我们下一节的任务。<br><img src="/assets/images/2454431-20230909171320817-1497398796.jpg" alt="img"></p><h3 id="额外的颜色贴图"><a href="#额外的颜色贴图" class="headerlink" title="额外的颜色贴图"></a>额外的颜色贴图</h3><p>将新的 menu 文件导出到游戏并选上黑色选项后，我们的装扮仍然没法使用，游戏会呈现如下错误，头发的模型轮廓出现但表面呈粉红色，左上角也弹出了报错信息（该报错信息在小黑窗中也可见）：<br><img src="/assets/images/2454431-20230909162240713-474194464.jpg" alt="img"></p><p>显然这是贴图丢失的表现，没错，正是我们上一节提到的那些未知 tex，并且此时可以看出之前的那些“ * ”所代表的其实就是对应头发 model 的名称。不过有了上一节的分析我们可以从颜色的 menu 文件中很容易的看出这些贴图的作用，其实就是更换颜色贴图那些而已，那这个贴图我们早有了，多复制几份改个名就行：<br><img src="/assets/images/2454431-20230909173144505-4067507.jpg" alt="img"></p><h4 id="实战结果-1"><a href="#实战结果-1" class="headerlink" title="实战结果"></a>实战结果</h4><p>成功，头发问题完美解决了，另一个头发照葫画瓢的做就行，另外别忘了，<strong>如果不重开游戏，那每次添加新文件都要用插件重载 Mod 文件</strong>哦。<br><img src="/assets/images/2454431-20230909173129365-612895391.jpg" alt="img"></p><h3 id="完善头发-Mod"><a href="#完善头发-Mod" class="headerlink" title="完善头发 Mod"></a>完善头发 Mod</h3><p>我有罪我又干了件蠢事。还记得我们之前选材质的时候吗？那时候为了便于后续做单面衣服，我选择了轮廓线材质，接着帽子头发也都用了同一个材质，对帽子来说无所谓，但头发就很尴尬了，因为头发是前后发组合完成的，结果因为轮廓线的原因，导致两模型接缝处额外多了条黑线。必须要解决啊，那具体咋搞呢？</p><p>还记得我们讨论材质参数的时候吗？那时说过轮廓线材质中有一个轮廓线宽度参数，如果不想要轮廓线我们只要把它设成 0 即可，这样不需要更换材质，双面效果也得以保留：<br><img src="/assets/images/2454431-20230909181515050-26094055.jpg" alt="img"></p><p>接着我们重新导出 mate 和 model 文件（<strong>没错，修改 mate 后，<del>相关 model 文件也要重新导出，不然 mate 不会生效，原因不明</del>，因为 model 文件包含 mate 文件，所以实际上根本不需要单独的 mate 文件，直接导出 model 文件就行</strong>）。现在再让我们看看效果，有内味了哈哈：<br><img src="/assets/images/2454431-20230909182743959-741951060.jpg" alt="img"></p><h2 id="二-制作眼睛-Mod"><a href="#二-制作眼睛-Mod" class="headerlink" title="二. 制作眼睛 Mod"></a>二. 制作眼睛 Mod</h2><h3 id="1-观察示例-menu-文件"><a href="#1-观察示例-menu-文件" class="headerlink" title="1. 观察示例 menu 文件"></a>1. 观察示例 menu 文件</h3><p>老规矩，不会就抄，我们先随便导出一个官方眼睛 Mod 做参考</p><p><img src="/assets/images/2454431-20230909183615680-427638088.jpg" alt="img"></p><p>可以观察到官方眼睛 Mod 是有多个 menu 文件构成的，并且大多是颜色后缀，比较特殊的是里面有一个“folder”后缀的 menu 文件。打开后又可以看到哪个熟悉的通配符了，显然这是眼睛的颜色选项实现。</p><p><img src="/assets/images/2454431-20230909184103289-798935148.jpg" alt="img"></p><p>继续观察后我们可以发现，眼睛的 menu 文件中没有我们熟悉“Add Item”显然它不需要 model 文件，取而代之的是眼睛颜色贴图，且没用通配符，简单粗暴的把全名写在了选项 menu 文件中（画圈处），自此我们的后续目标就确定了：</p><ul><li>ayaka_eye_folder.menu：<br>等同于上图“_i_eye_005_folder.menu”的作用，用于声明眼睛装扮提供的颜色选项。</li><li>ayaka<em>eye_black.menu：<br>等同于上图“_i_eye_005</em>任意颜色.menu”的作用，用于声明当前颜色对应的眼睛贴图。眼睛颜色没有 black，因为它们直接使用贴图，所以不需要特殊的混合颜色，这里我是受发色的影响，所以继续用 black 命名。</li><li>ayaka_eye_black.tex：<br>眼睛贴图。</li></ul><h3 id="2-制作眼睛贴图"><a href="#2-制作眼睛贴图" class="headerlink" title="2. 制作眼睛贴图"></a>2. 制作眼睛贴图</h3><p>我们将上图中官方的眼睛贴图“EyeL005_blue.tex”导出来做参考，用工具转换回 png 格式接着用 GIMP 打开，可以看到就是如下这样一个简单的图片：<br><img src="/assets/images/2454431-20230909190148892-909749643.jpg" alt="img"></p><p>模型是移植的，眼睛也是同样，我们的原模型贴图中就有眼睛的部分，所以我们只要用修图工具扣下来，摆放到和官方眼睛一样的状态即可，最后将这个新图片保存成 png 文件，我们的眼睛贴图也就算做好了：<br><img src="/assets/images/2454431-20230909192123834-1677520495.jpg" alt="img"></p><h3 id="3-编写-menu-文件"><a href="#3-编写-menu-文件" class="headerlink" title="3. 编写 menu 文件"></a>3. 编写 menu 文件</h3><p>有了之前编写 menu 的经验，相信这次各位就知道怎么改了，所以其他的老面孔我就不说了，下图只给出主要的差异条目：</p><p><img src="/assets/images/2454431-20230909194133787-1316906835.jpg" alt="img"></p><ul><li>左侧是“ayaka_eye_folder.menu”，和头发一样把通配符去掉，改成我们自定的颜色选项 menu。</li><li>右侧是“ayaka_eye_black.menu”，也是把眼睛贴图换成我们自己的。</li></ul><h3 id="4-导出-Mod-文件"><a href="#4-导出-Mod-文件" class="headerlink" title="4. 导出 Mod 文件"></a>4. 导出 Mod 文件</h3><p>三个文件都以做好，现在让我们把它们导出到游戏 Mod 文件夹中。重载 Mod，见证奇迹，成功又完成一种新 Mod。<br><img src="/assets/images/2454431-20230909194831121-914187723.jpg" alt="img"></p><h2 id="三-制作体型和脸型"><a href="#三-制作体型和脸型" class="headerlink" title="三. 制作体型和脸型"></a>三. 制作体型和脸型</h2><p>体型和脸型的制作在第三章中已经提过，直接使用游戏内置的功能捏制即可，这个非常简单我就不做说明了，而且你们也不想看我再啰啰嗦嗦写上一大堆吧，太累了，这个 Mod 教程的文稿大小已经远超我的预期了，为了你我他的身心健康，这种游戏内置功能我就不管了。</p><h3 id="有关捏制体型的提示"><a href="#有关捏制体型的提示" class="headerlink" title="有关捏制体型的提示"></a>有关捏制体型的提示</h3><p>blender 中的 com3d2 插件，提供一个创建预览体型的功能，只要创建该身体后在其姿势菜单中使用连接滑块功能，就能获得一个和游戏内体型参数一一对应的菜单，接着配合我们的原模型进行比对，或许能更方便的捏出原设人物哦！<em>（注意该身体是 CM3D2 版，和 COM3D2 版略有区别，所以不能用于细致的模型制作）</em></p><p><img src="/assets/images/2454431-20230909202400487-1647626945.jpg" alt="img"></p><h2 id="四-验证完善-Mod"><a href="#四-验证完善-Mod" class="headerlink" title="四. 验证完善 Mod"></a>四. 验证完善 Mod</h2><p>终于要结束了，现在把我们的角色装扮好，把体型脸型捏捏好，让角色摆几个 Pose，看看有没有出问题，比如头发穿模，破面，过于僵硬之类的。比如我的话发现头发似乎太高了、耳朵处出现了破洞、后发穿模进了后脑勺……要么调位置要么刷权重，这些问题或多或少都要改改，好在我们这期做的是头部，自动权重还是比较给力的不需要什么大修。</p><p>确定无误后，保存好我们角色 Preset 文件，因为接下来我们要退出编辑模式，站在一个玩家的视角去试用唱唱歌跳跳舞，看看 Mod 能否经过更严苛的考验，如果依旧不出问题，那可以宣布我们的 Mod 已经制作成功了。</p><h2 id="五-打包发布-Mod"><a href="#五-打包发布-Mod" class="headerlink" title="五. 打包发布 Mod"></a>五. 打包发布 Mod</h2><p>最后一步将我们的 Mod 文件整理打包成一个整合包，一个规范的 Mod 整合包才更利于 Mod 的分享和使用，具体我们应进行以下检查：</p><ul><li>是否有冗余文件：比如 png，bak 后缀之类的文件，这些游戏都用不到，所以全部删去。</li><li>是否有 Preset 文件：Preset 可以帮助用户选择正确的选项，比如头发颜色那些，不选对的话依然会有贴图丢失的问题。</li><li>是否有预览图：这可以让用户识别你的 Mod，也能用于判断 Mod 在游戏中的运行状态是否正确。</li><li>是否有说明文件：说明文件可以标注来源、记录版本号、备注一些前置需求等，有利于指导用户使用和后续跟踪 Mod。</li><li>文件布局是否符合游戏根目录：Mod 和 Preset 等文件应放对应的文件夹储存，这样结构清晰也便于让用户能有效安装。</li><li>文件夹分类是否规范，比如可以按装扮分类好文件，这有助于我们开发者编辑文件时的可读性。</li></ul><p>依据上述要求我对我的 Mod 进行了整理和打包，目前发布在了 3DMMod 站上，各位可以参考参考：<br><a href="https://mod.3dmgame.com/mod/202044">https://mod.3dmgame.com/mod/202044</a></p><blockquote><p>我无偿分享自己的 Mod 和教程，也是希望能尽可能的优化这款游戏的国内环境。我所有的游戏资源，原材料，制作工具都是别人无偿公开分享的，所有我也同样希望无偿公开的分享出去，也希望这份精神也能同样传递到你的身上。</p></blockquote><blockquote><p>有人说国内环境是倒狗害的，其实不然，比如我一定不会因为倒狗而自我封闭，因为我的目标是分享，那样只会本末倒置。国内大量的资源其实都是从国外转手过来的，不管是付费还是所谓的免费，都不会留下原地址，为什么？如果说有信息差就有倒狗的话，那国内其实只有大倒狗和小倒狗的区别罢了。</p></blockquote><blockquote><p>后续我会将 Mod 转到 3DMMod 站投稿，那里是公开网站，曝光率更高，且满足我对直链下载的需求，希望各位也能在那试试投稿，无头苍蝇式的组织没法站稳脚跟，必须靠大家的力量，这款游戏在国内的环境才能改善。</p></blockquote><h2 id="第一期完结"><a href="#第一期完结" class="headerlink" title="第一期完结"></a>第一期完结</h2><p>祝贺在此的各位，你们成功完成了第一期的实战教程。</p><p>最后，新老婆 get，嘿嘿~<br><img src="/assets/images/2454431-20230909222153832-181322621.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
      <category>COM3D2Mod制作教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【COM3D2Mod 制作教程（5）】实战！制作身体部分（中）</title>
    <link href="/posts/4213549019.html"/>
    <url>/posts/4213549019.html</url>
    
    <content type="html"><![CDATA[<h1 id="【COM3D2Mod-制作教程（5）】实战！制作身体部分（中）"><a href="#【COM3D2Mod-制作教程（5）】实战！制作身体部分（中）" class="headerlink" title="【COM3D2Mod 制作教程（5）】实战！制作身体部分（中）"></a>【COM3D2Mod 制作教程（5）】实战！制作身体部分（中）</h1><p>帽子是很典型的装扮类型，较为简单适合入门，所以我们先制作帽子 Mod，流程基本和第二章中的概述相符。因为导入插件及其功能位置也都已在第二章说明，所以这些相关内容我不会再重复。</p><p><em>这里选择帽子而非头饰也是有意为之，头饰的情况更复杂，其使用一套独立的骨架，所以移植时需要在 menu 中设定额外的位置参数，这太复杂了。而帽子和头发等头部部位有共用的根骨骼，也即是相同的坐标系，所以不需要动任何位置就可以完美匹配，在移植 Mod 中头饰往往和头发绑定，所以为减轻工作量，将所有头饰改用帽子的做法，最为合适。</em></p><h2 id="一-制作-menu-文"><a href="#一-制作-menu-文" class="headerlink" title="一. 制作 menu 文"></a>一. 制作 menu 文</h2><h3 id="1-观察示例-menu-文件"><a href="#1-观察示例-menu-文件" class="headerlink" title="1. 观察示例 menu 文件"></a>1. 观察示例 menu 文件</h3><p>导入刚导出的官方帽子 Mod 中的 menu 文件进行观察，其内容如下：</p><p><img src="/assets/images/2454431-20230907222641620-339591100.jpg" alt="img"></p><p>很不幸，其实里面大部分内容至今我也不知道是干啥的，但我很清楚因为现在要做的同为帽子菜单，所以大部分内容应该都是相通而无需改动的，而其余部分通过我过去的观察和实验我也有一些自己的经验，具体而言我会将这个菜单解读为如下内容：</p><ol><li><p>以“版本”为第一行，那前五行，也即“Folder”之上的内容：<br>可以很明显的观察到它们都在下方深色区域之外，这些都用不到，其中有些改了也不起作用，所以你完全不需要动他们。</p></li><li><p>Folder、Item Category、Item Category Number：<br>看样子是类别信息，因为同为帽子，所以这些也不要动。</p></li><li><p>addattribute：<br>不清楚是干啥的，但结合后续的一些同类条目来看，似乎是将内容进行了分割而导致了区域的产生，或许也正是导致前五行无效的罪魁祸首，因为前五行中的部分内容在这一区域内也重复出现了，或许因此导致发生了覆盖，而这也正好符合了这一条目的名称。</p></li><li><p>优先级：<br>是菜单中的排列顺序，值越小，对应的装扮选项越显示在前面，不重要所以也不动（动了也没用，因为想插队的不止你一个，结果导致队伍排序直接失去了意义，如果装扮太多建议使用“CM3D2.EditMenuFilter.Plugin”插件来辅助筛选）。</p></li><li><p>Menu Name、Menu Description、Icon(Small)<br>字如其名，就是显示给用户的菜单名、菜单描述、图标，这个不同装扮肯定不同，所以要改一下，但为了图省事我一般只填名称，描述留空，所有装扮一个图标，结果就类似下方这样。<br><img src="/assets/images/2454431-20230907224757050-92781946.jpg" alt="img"></p></li><li><p>onclickmenu<br>很明显又是一个分区，看名字应该是表示“当用户点击菜单时所该发生的事”，该区域内的两项条目也均为动词，很好的证明了这一点。</p></li><li><p>Add Item<br>非常重要的一项，观察其内容会发现里面填写着该菜单对应 model 文件名，这一项告诉了游戏当玩家点击菜单时应该让角色穿上哪个装扮模型，由于我们也是自己准备 model 文件，所以这一项显然也要改。</p></li><li><p>Material Change<br>观察后会发现和“Add Item”很类似，显然这是表示点击时该让 model 文件使用哪个 mate 文件，但根据第一章我们可知 model 文件实际天生带有对 mate 文件的引用，所以此项可有可无，为了省事我们可以直接它他删掉。之所以官方使用该条目或许是为了实现装扮换色功能，一个装扮有多个颜色选项，于是就有了一个 model 对应多个 mate、menu 的情况。</p></li><li><p>消去 node 设定开始<br>又是一个新区域，这里的 node 指的是角色身体部位，所以这个区域的功能就是可以将人物的特定部位隐藏起来。那为什么需要这个功能呢？想象一下你要做一个紧身衣，因为要贴合身体还不能穿模那工作量显然相当之大，一种取巧的办法就是去掉原本的部位，让紧身衣直接替代它，这样就不存在重叠也不存在穿模了。</p></li><li><p>Node Hide<br>只要在这里填上正确的部位名就可以隐藏相关部位了，可惜这个参考 menu 这里填了空，所以什么也不会隐藏，想想也很简单，因为帽子根本不会遇上上述的穿模问题。因此我另外找了一个隐藏了脊柱的示例，给大家直观的看看效果。<br><img src="/assets/images/2454431-20230907235950846-650350963.jpg" alt="img"></p></li><li><p>消去 node 设定终了<br>预示着消去 node 的功能分区到此结束了。话说为什么其他分区没有这种显式的结束标注？观察插件的添加命令功能，我还发现这个分区并没有出现在里面，理应出现的位置被“自定义”条目代替了，难道这些信息只是没有实际作用的注释？对于你的疑惑接下来我将进行补充。</p></li></ol><h4 id="关于-menu-文件的补充"><a href="#关于-menu-文件的补充" class="headerlink" title="关于 menu 文件的补充"></a>关于 menu 文件的补充</h4><ul><li>区域的作用？<br>上述文件解析中可以看到 menu 内是由多个区块组成，但经我实测后发现即使不分区，不放在区域内，相应的条目也可继续生效。所以我猜测这些分区实际只是方便编者阅读的注释而已，不起实际作用，又或者是因为区域具有默认值。但反正多一事不如少一事，非必要情况我建议是不管它们。</li><li>条目的参数该填啥？<br>这个问题问我，我也不知道，唯一能靠得住的只有你自己，因为解决办法只有一个，那就是一定要学会多观察多实验。多去导出官方 Mod 做参考，大胆的去修修改改，去游戏中观察现象。比如我上面那个脊柱的例子，我原本根本不知道“Node Hide”是隐藏部位，“Spine1”是脊柱，但我会导出官方 Mod，我导出了一件上衣，发现这些新玩意，于是我会尝试比如这条去掉并观察实验结果，所以我才发现了它们的作用。</li></ul><h3 id="2-修改成自己的-menu-文件"><a href="#2-修改成自己的-menu-文件" class="headerlink" title="2. 修改成自己的 menu 文件"></a>2. 修改成自己的 menu 文件</h3><p>根据上述解析此时改成我们自己的 menu 文件就非常简单了：</p><ol><li>“Menu Name”以上全部不动，既省事又安全。</li><li>“消去 node 设定”和“Material Change”全部删除，因为不用。</li><li>“Menu Name”我改为了“绫华头饰”，这很符合我们源模型的名称。</li><li>“Menu Description”偷懒不写，但至少要把原本的装扮描述去除，所以留空就行。</li><li>“Icon(Small)”需要一个图标图片，我们先预填一个“ayaka.tex”，具体后面再做。</li><li>“Add Item”需要一个模型文件，恰好就是我们之前拆出来的帽子模型，所以改成“ayaka_hat.model”</li></ol><p>改完后大概这样，由于条目太多截图不方便，具体细节大家自己脑部吧，总之帽子装扮的 menu 文件，此时我们就制作完成了：<br><img src="/assets/images/2454431-20230908195113687-2133073443.jpg" alt="img"></p><h3 id="3-通过-menu-文件得出后续制作目标"><a href="#3-通过-menu-文件得出后续制作目标" class="headerlink" title="3. 通过 menu 文件得出后续制作目标"></a>3. 通过 menu 文件得出后续制作目标</h3><p>通过上述 menu 文件的编写可以看出 menu 里还关联了一些其他文件，不同的装扮 menu 可能有不同的关联情况，目前我们的帽子 menu 里就需要下面这两个。</p><ul><li>ayaka_hat.model</li><li>ayaka.tex</li></ul><p>这两个分别是帽子模型和菜单图标，也正是我们接下来要做的任务。</p><h2 id="二-制作-model-文件"><a href="#二-制作-model-文件" class="headerlink" title="二. 制作 model 文件"></a>二. 制作 model 文件</h2><p>用于移植的 model 原模型，我们在前几节就准备好了，那接下来只要完成绑定骨架这一项即可。</p><h3 id="1-导入参考-Model"><a href="#1-导入参考-Model" class="headerlink" title="1. 导入参考 Model"></a>1. 导入参考 Model</h3><p>骨架存在于官方 model 文件中，所以我们现在将所有参考的 Mod 的 model 文件导入 blender 中，可以看到我们需要的骨架已经出现，就是下图那些黑色条状物。</p><p><img src="/assets/images/2454431-20230908201035543-1254168265.jpg" alt="img"></p><p>你可能会好奇明明我们只是做帽子，为什么要把所有 model 都导入呢？这是一个制作技巧，因为我们是移植 Mod，新模型都是从原本的一个整体模型上分离出来的，为了保证日后不要因此留下接缝，所有我们应该整体移动所有的新模型，因此后面对齐骨架时我们不仅要对齐帽子，包括头发这些也要同时对齐好。</p><h3 id="2-对齐至参考-Model"><a href="#2-对齐至参考-Model" class="headerlink" title="2. 对齐至参考 Model"></a>2. 对齐至参考 Model</h3><p>接着我们开始对齐新模型和参考模型，缩放移动都可以，只要记得所有头部模型整理调整就行，越是贴合参考模型，后续用插件自动复制权重时就会越准确。下图就是我调整后的结果，把两边的模型都尽可能的放在了一起。</p><p><img src="/assets/images/2454431-20230908201930839-317228283.jpg" alt="img"></p><h3 id="3-重新绑定骨架"><a href="#3-重新绑定骨架" class="headerlink" title="3. 重新绑定骨架"></a>3. 重新绑定骨架</h3><p>在身体制作环节，源模型的骨架对我们来说没有作用，现在我们要把新模型的骨架改为参考模型的骨架，这个应该算是 blender 基本操作了，我就不细说了，记得先把属于旧骨架的顶点组之类的无用数据都清除，这样可以减少模型大小。</p><h3 id="4-进行权重转移"><a href="#4-进行权重转移" class="headerlink" title="4. 进行权重转移"></a>4. 进行权重转移</h3><p>接着最终要的一个环节来了，就是刷权重，真从头刷肯定累死，好在插件有功能让我们可以把参考模型的权重自动转移到我们的新模型上。权重转移的功能位置如下，只需要保证被转移模型和目标模型都在同一骨架下，接着先选被转移模型再选目标模型，即可使用该功能，虽然名字叫转移，但实际是起到复制的效果。</p><p><img src="/assets/images/2454431-20230908214212490-1050231052.jpg" alt="img"></p><p>接着通过权重绘制模式我们就可以观察到我们的帽子新模型的权重已经被刷好了。</p><p><em>介绍一个 blender 技巧，先选骨架再选模型，然后进入权重绘制模式，这时我们就可以通过“alt+鼠标左键”自由切换所要绘制权重的骨骼了</em></p><p><img src="/assets/images/2454431-20230908214710407-709260574.jpg" alt="img"></p><p>当然这是因为帽子的骨架较为简单，在更复杂的情况下，还有一些要点要注意：</p><ol><li>权重毕竟是自动计算的，多少都会有些不正确，所以通常权重转移后我们还会需要人工检查修补一下。</li><li>查看权重后会发现部分骨骼是完全没有权重的，这是正常的，有部分骨骼确实不能用来刷权重，否则模型将无法导出，具体参考官方模型的权重刷取方式就行。</li></ol><h3 id="5-通过-model-文件得出后续制作目标"><a href="#5-通过-model-文件得出后续制作目标" class="headerlink" title="5. 通过 model 文件得出后续制作目标"></a>5. 通过 model 文件得出后续制作目标</h3><p>这样子我们的 model 文件就基本做好了，但之前说过 model 和 mate 文件有关联关系，所以此时是不能直接导出 model 的，这也指引了我们的下一个步骤：制作 mate 文件。</p><h2 id="三-制作-mate-文件"><a href="#三-制作-mate-文件" class="headerlink" title="三. 制作 mate 文件"></a>三. 制作 mate 文件</h2><p>现在开始制作 mate 文件，mate 文件的编辑位置在第二章也已说过，进入后可以发现，模型原本就已经自带了一些材质，但由于 shader 的不同，材质并不能直接通用，所以我们必须要进行些处理才能做出 mate 文件。</p><p>shader 功能就是下图“使用节点”中的内容，blender 默认的 shader 是“原理化 BSDF”，而我现在用的是之前 pmx 导入插件提供的“MMDShaderDev”，你可以在图中看到这一点。所以自然 COM3D2 的也有着自己的 shader 格式，我们必须将材质与之匹配才行。</p><p><img src="/assets/images/2454431-20230908220404954-53447749.jpg" alt="img"></p><h3 id="1-整理原模型材质"><a href="#1-整理原模型材质" class="headerlink" title="1. 整理原模型材质"></a>1. 整理原模型材质</h3><p>虽然原模型材质并不能直接使用，但其上面的信息有助于告诉我们转换材质时的一些信息该如何填写。</p><ol><li><p>确定所用贴图<br>基本上我们只要注意颜色贴图就行，其他贴图可以不管，特别是对于这种卡通风格人物，很多阴影高光信息都会额外在颜色贴图上有所表示，所以通常一个颜色贴图就可以通吃了。<br>现在通过分析上图的材质，我们可以发现“帽”中用了贴图“体.png”，而“帽花”和“叶子”同用了另一张贴图“裙.png”<br><img src="/assets/images/2454431-20230908224516429-1539173667.jpg" alt="img"></p></li><li><p>确定透明方式<br>通过观察模型显示效果我们可以发现“帽”和“叶子”是不透明的，而“帽花”是半透明的，这将导致我们后面转换材质时要选择不同的选项。<br><img src="/assets/images/2454431-20230908225454895-1725546770.jpg" alt="img"></p></li><li><p>简化材质<br>“帽”肯定是单独占一个材质了，因为他所用的贴图不同，但“叶子”如果选择使用透明材质，那就可以和“帽花”合并起来。第一章我们说过关于透明材质的一个风险问题（pmat 的起因），但考虑“叶子”空间占比不大且和“帽”之类的不透明物体较为贴合（因为不透明物体有深度信息，能起遮挡作用），所以可以选择直接偷懒和“帽花”共用，这样我们要做 mate 文件就缩减成两个了，实际合并后效果如下，显然并无太大影响。<br><img src="/assets/images/2454431-20230908230301119-1149784186.jpg" alt="img"></p></li></ol><h3 id="2-转换材质至-COM3D2-格式"><a href="#2-转换材质至-COM3D2-格式" class="headerlink" title="2. 转换材质至 COM3D2 格式"></a>2. 转换材质至 COM3D2 格式</h3><p>现在开始转换上述的“帽”和“帽花”材质，转换按钮就在下方，另外我还给这两个材质球按照之前的命名要求进行了改名，便于我们后续导出 mate 文件。<br><img src="/assets/images/2454431-20230908230854202-51506173.jpg" alt="img"></p><p>可转换到 COM3D2 材质类型有多种（如下图），但还是那句话，我自己也搞不清这些具体都是干啥的，只能给出一些我个人的经验之谈。</p><p><img src="/assets/images/2454431-20230908231118547-1791496168.jpg" alt="img"></p><ul><li>右侧“种类”栏：<br>可以直接无视，这些都是一些特效材质，我们的普通装扮并不需要。</li><li>左侧栏：<br>可以观察到这一栏的材质全是相同的日语前缀，这句日语是一种卡通风格的名称，显然这些就是我们卡通人物最常用的材质。</li><li>带“NoZ”：<br>不要用这种，Z 是深度意思，正常材质都需要深度信息，所以这材质也只有一些特效会使用，我们不需要。</li><li>带“轮廓线”：<br>这会给模型额外加一圈描边效果，这个效果倒是看个人喜好，真正的重点是这个材质提供双面效果，给模型背面也加上颜色，如果是单面的衣服，用这个会比较方便。</li><li>带“透过”：<br>带了就是启用半透明效果，没有就是不透明，用半透明就会出现 pmat 的问题，所以如无必要优先使用不透明。</li><li>带“Cutout”：<br>一种特殊的半透明效果，正常透明一般根据阿尔法值可实现渐变透明，而这个就是完全无法渐变，它通过比较设定的阈值使表面要么完全透明要么完全不透明，适合于如树叶，布料之类的效果。</li><li>其他：<br>抱歉剩下的我也没玩过，或者没看出啥名堂。还是那句话多一事不如少一事，当然如果有兴趣，你可以自行研究。</li></ul><p><em>因为 COM3D2 是使用 Unity 开发，所以上述的很多材质类型包括后续的一些参数都和 Unity 中有所关联，这也是为什么我会知道这些，下方是他们所在 Unity 开发手册中的内容，包括 pmat 问题，手册也有提到。</em></p><p><em>关于深度测试：</em><br><a href="https://docs.unity.cn/cn/2019.4/Manual/SL-CullAndDepth.html">https://docs.unity.cn/cn/2019.4/Manual/SL-CullAndDepth.html</a></p><p><em>关于材质类型：</em><br><a href="https://docs.unity.cn/cn/2019.4/Manual/StandardShaderMaterialParameterRenderingMode.html">https://docs.unity.cn/cn/2019.4/Manual/StandardShaderMaterialParameterRenderingMode.html</a></p><h4 id="实战结果"><a href="#实战结果" class="headerlink" title="实战结果"></a>实战结果</h4><p>根据上述说明我们可以就正式将我们的材质转换成合适的 COM3D2 格式了：</p><ul><li>“ayaka_body”转化为“轮廓线”材质（用于启用双面以解决单面衣服背面不显示的问题）</li><li>“ayaka_clothing”转换为“透过”材质（不使用轮廓线，是防止双面效果加剧 pmat 的问题）</li></ul><h4 id="3-填写-COM3D2-材质参数"><a href="#3-填写-COM3D2-材质参数" class="headerlink" title="3. 填写 COM3D2 材质参数"></a>3. 填写 COM3D2 材质参数</h4><p>COM3D2 的材质中有多个参数可用，不同的材质间参数也会有些许差异，但不用害怕，基本上大部分参数插件都会自动帮我们填好默认值，我们只要改动我们需要的地方就行，这里我使用“ayaka_body”材质做示范，“ayaka_clothing”同理即可。</p><p><img src="/assets/images/2454431-20230909101037815-1811563061.jpg" alt="img"></p><ul><li><p>从整体来看的前三项：<br>这部分是“名称”、“着色器”信息：“名称”根据之前我们的材质命名此处插件已经自动填好了；“着色器”也是根据之前我们选择的着色器类型由插件自动填写的，所以着三项内容都不需要动。</p></li><li><p>材料特性中的前四项：<br>可以看到前四项是图片参数，这意味着会关联到其他外部文件，因此这部分必须确保无误。通过插件填好的默认值，我们能从中看出一些端倪：比如带“ayaka”前缀的显然是我们自己的文件，所以需要我们按其准备；其余文件通过数字后缀我们可以看出同名纹理已被重复创建了多次，显然这是一个公共纹理，所以我们只要把它的名称修复好就行。<br>其中“_MainTex”是颜色贴图的意思，这个贴图原模型已经提供给我们了，身体加衣装的贴图共两张；“_ShadowTex”是阴影贴图，这个我们没有，但我之前说过，很多卡通风格贴图，光照阴影这些往往在颜色贴图上也会有所表示，所以我们可以直接通过颜色贴图代替实现。</p></li><li><p>剩下的其他项：<br>这些都是存在材质中的内置参数，不需要我们额外准备什么，所以为了省事我们不动它们，直接使用默认值就行。如果你想尝试修改，通过名称也能看出些其作用，比如“OutLine”是轮廓线的意思，那显然“_OutlineColor”就是轮廓线颜色，“_OutlineWidh”就是轮廓线宽度。</p></li></ul><h4 id="实战结果-1"><a href="#实战结果-1" class="headerlink" title="实战结果"></a>实战结果</h4><p>根据上述解析，我们对转换后的材质进行修改，结果如下（遵照命名要求纹理的名称被我从原来的“体”改成了“ayaka_body”）：</p><p><img src="/assets/images/2454431-20230909104139905-1958939894.jpg" alt="img"></p><h4 id="4-通过-mate-文件得出后续制作目标"><a href="#4-通过-mate-文件得出后续制作目标" class="headerlink" title="4. 通过 mate 文件得出后续制作目标"></a>4. 通过 mate 文件得出后续制作目标</h4><p>这样子我们的 mate 文件也做好了，但其中对贴图的引用，又指向了我们的下一个目标，tex 文件的制作。</p><h2 id="四-制作-tex-文件"><a href="#四-制作-tex-文件" class="headerlink" title="四. 制作 tex 文件"></a>四. 制作 tex 文件</h2><p>因为 tex 是纯图片，不存在后续引用文件，所有说总算到了最后一个文件制作环节了，制作也很简单，使用“TexTool.exe”直接转换即可。通过上述的环节我们共获知需要制作三个 tex 文件。</p><ul><li>ayaka_body.tex：<br>由于贴图已经由原模型提供了，所以我们直接将其转换然后改个名即可。</li><li>ayaka_clothing.tex：<br>上一节我省略了“ayaka_clothing”材质的转换过程，但不代表你可以不做，既然 model 需要两个材质那我们都要准备好，这个纹理就是另一个省略材质中所用的贴图。</li><li>ayaka.tex：<br>图标文件要我们自己制作一下，具体看个人喜好，我是选择直接用立绘裁张大头照，然后转换就行。</li></ul><p><img src="/assets/images/2454431-20230909115620458-1782821105.jpg" alt="img"></p><h2 id="七-导出帽子-Mod-文件"><a href="#七-导出帽子-Mod-文件" class="headerlink" title="七. 导出帽子 Mod 文件"></a>七. 导出帽子 Mod 文件</h2><p>现在将我们上面做的所有文件进行导出，导出方式我在上一章已有简述，<strong>有一点要说的是导出 model 文件时可千万别忘了应用变换，不归零的话导出到游戏后可能会出现错位拉伸等问题</strong>，具体导出后是以下这些文件：</p><p><img src="/assets/images/2454431-20230909122410266-667142156.jpg" alt="img"></p><ul><li>一个 menu：帽子装扮菜单项。</li><li>一个 model：帽子模型。</li><li>两个 mate：帽子模型用到两个材质。</li><li>三个 tex：其中两个是材质所用贴图，另一个是菜单图标。</li></ul><p>现在让我们将上述文件放入 COM3D2 游戏的 Mod 文件夹中，启动游戏，编辑女仆（<strong>如果游戏已启动，则需要使用重载插件，相关插件在第二章已说明，每次添加新文件都必须使用重载功能</strong>）……恭喜你！你成功做出了第一件 Mod。</p><p><img src="/assets/images/2454431-20230909120734655-2146151955.jpg" alt="img"></p><h2 id="八-完善帽子-Mod"><a href="#八-完善帽子-Mod" class="headerlink" title="八. 完善帽子 Mod"></a>八. 完善帽子 Mod</h2><p>话说你发现上图的一个问题了吗？原本在背后的叶子出现在了帽花的前方，结果我们还是触发了 pmat 问题啊。不过教程写完后我才发现这个问题，那就在最后一步处理吧。现在让我们看看如何解决这个问题？</p><ul><li>使用 pmat 调整渲染顺序：<br>麻烦且不是第一期实战教学的内容，更关键的是这种方法，根本没法解决前后两种方向都能观察时的渲染顺序问题，所以无法使用。</li><li>不在材质球上偷懒，还是将叶子单独分配一个不透明材质：<br>推荐，实际上最后做完你就会发现这些材质基本也都是需要做的，那不如这次顺带把它做好了。</li></ul><p>所以我重新添加了一个新材质，为了区分新旧材质，将旧的“ayaka_clothing”材质名增加了个符合其特征的后缀，改为了“ayaka_clothing_trans”，并将叶子和帽花模型所有的材质进行重设，结果如下：<br><img src="/assets/images/2454431-20230909145851877-813050485.jpg" alt="img"></p><p>最后重新导出帽子的 model 文件和相关 mate 文件到游戏 Mod 文件夹，在游戏中重载 Mod 并重新装扮帽子，可见问题成功解决了：<br><img src="/assets/images/2454431-20230909150148965-1003255621.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
      <category>COM3D2Mod制作教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【COM3D2Mod 制作教程（4）】实战！制作身体部分（上）</title>
    <link href="/posts/2178139815.html"/>
    <url>/posts/2178139815.html</url>
    
    <content type="html"><![CDATA[<h1 id="【COM3D2Mod-制作教程（4）】实战！制作身体部分（上）"><a href="#【COM3D2Mod-制作教程（4）】实战！制作身体部分（上）" class="headerlink" title="【COM3D2Mod 制作教程（4）】实战！制作身体部分（上）"></a>【COM3D2Mod 制作教程（4）】实战！制作身体部分（上）</h1><h2 id="教程介绍"><a href="#教程介绍" class="headerlink" title="教程介绍"></a>教程介绍</h2><p>现在正式进入实战教程环节，我会以我的实际制作过程详尽的教授每个细节，也因此受限于篇幅大小，“实战！制作身体部分”被分为了上中下三个过程。</p><ul><li><p>上：</p><p>我们将首先确定我们的制作目标，并以此进行环境搭建和资源准备工作，目标是将正式制作 Mod 的前置需求全部完成。</p></li><li><p>中：</p><p>现在正式开始制作 Mod，以典型的帽子 Mod 为例，我们会一步步将“上”中准备的资源逐渐转化为 COM3D2 中的 Mod，并在最终实际放入游戏中，完成第一个 Mod 制作。</p></li><li><p>下：</p><p>在累计了“中”的制作经验后我们开始完成剩下的头发 Mod 部分，并简单介绍身体和脸型的制作流程，并最终将 Mod 打包发布至网络，彻底完成一套完整制作流程。</p></li></ul><p>接下来我们正式开始教程。</p><h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><p>我们这次只制作身体部分，身体部分是最简单最实用的部分，是人物最重要的特征点，快的话一个小时就能搞定，但足以达到让人直呼老婆的水平，毕竟衣服是可以随意换的，但身体始终不变。</p><p>所谓的身体部分是实际按照游戏中右侧装备栏的身体分栏确定的，具体而言我们一般需要做以下几个部分，在这之后我们便开始根据第二章的流程概述实际做 Mod。</p><h3 id="头发"><a href="#头发" class="headerlink" title="头发"></a>头发</h3><p>头发具体在游戏中有多个分类，其中必须装备的是“前发”和“后发”两种，为简化制作流程，我们也只做这两者。</p><p><img src="/assets/images/2454431-20230906222649162-2104290613.jpg" alt="img"></p><h3 id="眼睛"><a href="#眼睛" class="headerlink" title="眼睛"></a>眼睛</h3><p>眼睛并非模型而是纯贴图。我们将使用修图软件进行处理，当然作为游戏装扮的一员，它也是有一套自己的 menu 文件要填写的。</p><h3 id="帽子（头饰）"><a href="#帽子（头饰）" class="headerlink" title="帽子（头饰）"></a>帽子（头饰）</h3><p>头饰按道理是服装装扮的部分，为何此处也需要制作？因为大部分游戏模型会将部分光照阴影直接绘制在贴图上，由于我们的头发是移植的，这些阴影也直接反应在了头发上，如果不带上原本的头饰遮掩，就会存在黑斑问题（如下图）。</p><p><img src="/assets/images/2454431-20230906222433577-1459596474.jpg" alt="img"></p><h3 id="脸型"><a href="#脸型" class="headerlink" title="脸型"></a>脸型</h3><p>我们将直接使用 DLC“GP-01Fb”提供的特制捏脸脸型选项制作。</p><p><img src="/assets/images/2454431-20230906223103346-514500570.jpg" alt="img"></p><h3 id="体型"><a href="#体型" class="headerlink" title="体型"></a>体型</h3><p>体型也是直接使用游戏自带的系统捏制即可。</p><p><img src="/assets/images/2454431-20230906223212283-1290250791.jpg" alt="img"></p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>这些基本是第二章已讲述的内容，你需要将其配置好，才可开始制作 Mod。</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>第二章所说的各种编辑工具，你需要将他们安装好，安装方式在第二章已有说明，此处不再重复。</p><h3 id="移植模型"><a href="#移植模型" class="headerlink" title="移植模型"></a>移植模型</h3><p>这是第二章提到模之屋以及导入 pmx 文件的内容。由于是实战，所以这次我们要实际准备一个模型，因为我是原批，所以这里用原神中的角色“神里绫华”做参考。</p><p><img src="/assets/images/2454431-20230906174403829-1045284516.jpg" alt="img"></p><h3 id="参考-Mod"><a href="#参考-Mod" class="headerlink" title="参考 Mod"></a>参考 Mod</h3><p>由于脸型和体型是游戏内置功能，我们只需要考虑“头发”，“眼睛”，“帽子”的 Mod 文件制作即可。我们需要导出与之相关的官方 Mod 文件做移植参考，具体操作还要根据移植模型所拆分出的装扮类型和形状来定。</p><h2 id="原模型预处理"><a href="#原模型预处理" class="headerlink" title="原模型预处理"></a>原模型预处理</h2><h3 id="装扮拆解"><a href="#装扮拆解" class="headerlink" title="装扮拆解"></a>装扮拆解</h3><p>本次我们只制作身体部分，所以移植模型的衣服部分我们可以直接排除，这样就只剩下头部，将头部模型拆解整理后，我们可以得到以下三种装扮：“前发”、“后发”、“帽子”，这和我们上述的 Mod 目标正好对应。</p><p><img src="/assets/images/2454431-20230906233737603-2140221409.jpg" alt="img"></p><p>提示：导入 pmx 的那个插件支持按材质拆分模型，可以方便我们的拆解工作（见下图）</p><p><img src="/assets/images/2454431-20230906232009064-791421149.jpg" alt="img"></p><h3 id="网格优化"><a href="#网格优化" class="headerlink" title="网格优化"></a>网格优化</h3><p>为了方便后续权重绘制、顶点调整等操作我们要检查网格是否整洁规范，比如是否有断面或重叠面之类的问题，这些若不处理都会对后续操作产生不良影响。</p><h4 id="合并断面"><a href="#合并断面" class="headerlink" title="合并断面"></a>合并断面</h4><p>比如我这个“神里绫华”模型就存在断面问题，解决方法很简单，利用 blender 的按距离合并顶点功能即可，使用时记得勾上锐边选项，因为断面似乎是模型有意为之，下图那些蓝色的地方就是断面处，也恰好是应该锐边的地方。</p><p><img src="/assets/images/2454431-20230909155338505-800571183.jpg" alt="img"></p><h4 id="消除重叠面"><a href="#消除重叠面" class="headerlink" title="消除重叠面"></a>消除重叠面</h4><p>我这个模型实际上也同时有着重叠面的问题，和断面问题一样也是模型有意为之，这个主要和材质有关，一个面如果有多个材质原模型就会多一层面，所以通过材质选中加删除的方式就能解决，当然因为我上一节“装扮拆解”中恰是通过材质拆解的模型，所以整理好后问题正好解决了。</p><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><h4 id="为什么要注意文件命名？"><a href="#为什么要注意文件命名？" class="headerlink" title="为什么要注意文件命名？"></a>为什么要注意文件命名？</h4><p>COM3D2 识别区分 Mod 的方式就是靠文件名，包括不同文件间的引用关系也是靠文件名指明的，文件名一旦设置有误就很可能导致 Mod 无法使用，有关文件名必须遵循以下几个注意点。</p><ul><li><p><strong>文件名无视路径。</strong></p><p>如果有同名文件，但所在文件夹不同，对 COM3D2 来说依旧是同一个文件，结果就会导致覆盖或重复加载。</p></li><li><p><strong>文件名不能为中文。</strong></p><p>因为导出插件是只考虑了英语环境做的，所以使用非英语语言，如日语，汉语等都会导致文件无法导出。</p></li><li><p><strong>文件名不区分大小写。</strong></p><p>如果文件名除字母大小写外都相同，对 COM3D2 来说这也是同一个文件，那也会出现上述的问题。</p></li></ul><h4 id="推荐的命名规范？"><a href="#推荐的命名规范？" class="headerlink" title="推荐的命名规范？"></a>推荐的命名规范？</h4><p>由于上述问题所以对于文件命名我们需要一定规范：</p><ul><li><p><strong>使用角色名做前缀。</strong></p><p>因为第一点，所以我们要尽可能保证文件名不重复，所以可以选择加一些前缀，我一般会选择角色名做前缀，这够用了毕竟角色 Mod 太难找了。</p></li><li><p><strong>使用全小写英文，并用下划线做单词分隔符。</strong></p><p>因为第二点所以我们要用英文名称，而因为第三点不区分大小写，所以我们统一全用小写，并用额外的符号分割英文单词，我一般都是用下划线“_”作为分隔符。</p></li><li><p><strong>使用部位名做名称主体。</strong></p><p>最后为了让文件具有可读性且保证多个装扮名不重复，我们需要提供一个名称主体，我一般会使用部位名做主体，这样清晰易懂还不会重复。</p></li></ul><h4 id="实战结果"><a href="#实战结果" class="headerlink" title="实战结果"></a>实战结果</h4><p>以此命名方式对我们的示例模型进行重命名可得如下结果，且后续的其他文件我们也将遵照上述规则。</p><p><img src="/assets/images/2454431-20230907204717866-1199253546.jpg" alt="img"></p><h2 id="导出参考-Mod"><a href="#导出参考-Mod" class="headerlink" title="导出参考 Mod"></a>导出参考 Mod</h2><p>由于制作 Mod 的源模型已经到手，根据其形状我们可以正式导出用于参考的官方 Mod 了，这是必须的一环。</p><h3 id="为什么要导出官方-Mod？"><a href="#为什么要导出官方-Mod？" class="headerlink" title="为什么要导出官方 Mod？"></a>为什么要导出官方 Mod？</h3><ul><li><p><strong>只有观察官方 Mod 文件构成我们才知道要准备什么。</strong></p><p>不同的装扮可能有着不同的需求，有些是单纯的建模，有些是要专门的贴图，有些需要特制 menu 文件，等等，并不是所有装扮的文件需求都是一成不变的。</p></li><li><p><strong>只有通过官方 menu 文件我们才知道应该填写什么。</strong></p><p>menu 文件相当复杂，也相当重要，没写好就会导致无法使用或事倍功半，但我们没有途径也没有精力将其完全摸透，所以只有通过观察官方 menu 文件，在其基础上修改才是上策。</p></li><li><p><strong>只有通过官方 model 文件我们才能进行骨架绑定。</strong></p><p>人物建模最重要的就是骨架绑定，这是实现原理，也是后面最费时间的地方，只有通过官方 model 文件我们才能获得用于绑定的源骨架，以及知晓正确的权重刷取要求。</p></li></ul><h3 id="为什么要根据源模型形状选取官方-Mod？"><a href="#为什么要根据源模型形状选取官方-Mod？" class="headerlink" title="为什么要根据源模型形状选取官方 Mod？"></a>为什么要根据源模型形状选取官方 Mod？</h3><p>因为我们需要绑定骨架，不同装扮对骨架的需求是不同的，比如：裙子就需要带裙骨的；双马尾就需要有两条骨链的。所以必须根据形状选择官方 Mod，这样得到的骨架才能匹配。</p><p>比如我们源模型发型都是双耳前后有两簇头发，那我们选择的官方 Mod 也应如此，因为这几簇头发一定是需要骨骼的；而帽子我们也是尽可能选择一个形状位置最像的。</p><h3 id="实战结果-1"><a href="#实战结果-1" class="headerlink" title="实战结果"></a>实战结果</h3><p>所以根据我们的示例模型特征，我选取了以下三个对应的官方装扮（此处改口叫装扮没有问题，是因为官方装扮就是官方 Mod，这是上一章描述过的）。</p><p><img src="/assets/images/2454431-20230907214302579-1055089432.jpg" alt="img"></p><p>接着我们使用 SybarisArcEditor 导出这三个装扮的 Mod 文件（导出方式也已在第二章讲过）。</p><p><img src="/assets/images/2454431-20230909132149112-1518513392.jpg" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章我们获取到了用于移植的原模型，并进行了一些必要的预处理操作，接着我们借此推断并导出了用于参考的官方 Mod，所以此刻所有的前置文件都已经准备好了，接下来我们可以正式制作 Mod 了。</p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
      <category>COM3D2Mod制作教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【COM3D2Mod 制作教程（3）】Mod 制作概要</title>
    <link href="/posts/41755669.html"/>
    <url>/posts/41755669.html</url>
    
    <content type="html"><![CDATA[<h1 id="【COM3D2Mod-制作教程（3）】Mod-制作概要"><a href="#【COM3D2Mod-制作教程（3）】Mod-制作概要" class="headerlink" title="【COM3D2Mod 制作教程（3）】Mod 制作概要"></a>【COM3D2Mod 制作教程（3）】Mod 制作概要</h1><p>制作工具整合包：<a href="https://mod.3dmgame.com/mod/205516">https://mod.3dmgame.com/mod/205516</a></p><p>该工具包简单整合了些本章需要的小型工具、插件、以及其他一些后续教程必要的资源，所以你<strong>必须下载</strong>它。但如 GIMP、Blender、CMI，这些则需要你自行下载。</p><h2 id="Mod-制作工具"><a href="#Mod-制作工具" class="headerlink" title="Mod 制作工具"></a>Mod 制作工具</h2><p>书接上文，我们知道了 Mod 由五种文件构成，而特制的文件自然要用特制的工具制作，具体需要以下工具。</p><h3 id="GIMP"><a href="#GIMP" class="headerlink" title="GIMP"></a>GIMP</h3><p><a href="https://www.gimp.org/downloads/">https://www.gimp.org/downloads/</a></p><p>修图软件，和 Blender 一样免费开源。这类软件易于获取且干净体积小，这也是为什么选择 GIMP 而不是 PS。但如果你会使用 PS 或其他修图软件也建议继续使用，基本上我们只会使用抠图之类的简单功能，所以没有强制要求。</p><h3 id="Blender"><a href="#Blender" class="headerlink" title="Blender"></a>Blender</h3><p><a href="https://www.blender.org/download/lts/3-3/">https://www.blender.org/download/lts/3-3/</a></p><p>建模软件，使用 3.3LTS 是因为这是 Blender-CM3D2-Converter 插件的推荐版本。</p><h3 id="Blender-CM3D2-Converter"><a href="#Blender-CM3D2-Converter" class="headerlink" title="Blender-CM3D2-Converter"></a>Blender-CM3D2-Converter</h3><p><a href="https://github.com/luvoid/Blender-CM3D2-Converter/releases/tag/luv.2023.08.16a">https://github.com/luvoid/Blender-CM3D2-Converter/releases/tag/luv.2023.08.16a</a></p><p>一款 Blender 插件。既是 CM3D2 文件转换器，同时也是建模辅助工具，可以实现在 Blender 中导入导出<strong>menu</strong>，<strong>model</strong>，<strong>mate</strong>文件，预览人物体型，转移权重形态建等操作。</p><h4 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h4><p>根据官网描述，安装时插件需要安装依赖性（这是自动进行的），所以首次安装可能会失败，根据报错提示，此时我们需要重启 Blender，再尝试重新安装。</p><p>如果多次重装都失败，请尝试删除所有和 Blender，Python 等有关的软件和文件，并按推荐版本重新安装。之前我遇到过这种情况，并以此成功解决了。</p><p><em>自行顺着 WIKI 上的链接下了本插件，但和我这个不一样？这就是我之前提到 WIKI 过时的问题之一，这个插件的原作者早就退坑了，但这是款开源插件，因此所有人都有机会接力，第二位作者也退坑了，现在是第三位作者在接力，且仍在更新。</em></p><h4 id="使用简介"><a href="#使用简介" class="headerlink" title="使用简介"></a>使用简介</h4><p>根据上一章可知基本上 Mod 文件在 Blender 中都有对应的类型，也因此编辑和导出他们的地方就可以确定了。（注意导出时检查文件名是否有填写、类型是否正确，不然无法导出。）</p><ul><li><p>mate 文件在材质面板编辑和导出（交配按钮实则是导出按钮，此处翻译有问题）</p><p><img src="/assets/images/2454431-20230909112128642-985543154.jpg" alt="img"></p></li><li><p>menu 文件在物体面板编辑和导出（虽然物体不是 menu，但两者是最接近的层次）</p><p><img src="/assets/images/2454431-20230909112218954-357619950.jpg" alt="img"></p></li><li><p>model 文件像正常的模型一样编辑和导出就行</p><p><img src="/assets/images/2454431-20230905171143921-1727872284.jpg" alt="img"></p></li></ul><h3 id="TexTool"><a href="#TexTool" class="headerlink" title="TexTool"></a>TexTool</h3><p><a href="https://github.com/ghorsington/TexTool/releases/tag/v3.0.1.0">https://github.com/ghorsington/TexTool/releases/tag/v3.0.1.0</a></p><p>COM3D2 的<strong>tex</strong>文件转换工具。Blender-CM3D2-Converter 也提供相应功能，但似乎有漏洞无法正常使用，所以使用该工具单独处理。</p><h4 id="使用简介-1"><a href="#使用简介-1" class="headerlink" title="使用简介"></a>使用简介</h4><p>该应用无法直接打开，需要配合命令提示符使用。使用命令提示符将该应用作为启动程序，并将要处理的图片路径作为参数，这样就可以在原图片目录转换出结果（如下图）。另外一种更简便的使用方式是将需要转换的图片直接拖拽到该应用程序图标上即可。支持多种图片格式，如 png，jpg 文件等，反向转换 tex 文件也可以。</p><p><img src="/assets/images/2454431-20230905102653857-1449053777.jpg" alt="img"></p><h3 id="pmat-編集"><a href="#pmat-編集" class="headerlink" title="pmat 編集"></a>pmat 編集</h3><p><a href="https://www.mypcrun.com/file-download-for-windows/2/264755/3264e7053f02241ea42525bcd2d5bf38/">https://www.mypcrun.com/file-download-for-windows/2/264755/3264e7053f02241ea42525bcd2d5bf38/</a></p><p>用于编辑<strong>pmat</strong>文件。初始的 pmat 文件可以通过 SybarisArcEditor 导出官方文件。</p><h4 id="使用简介-2"><a href="#使用简介-2" class="headerlink" title="使用简介"></a>使用简介</h4><p>我未找到自行创建 pmat 文件的方法，所以只能通过修改官方文件来实现，官方的 pmat 文件都被存储在&#x2F;GameData&#x2F;prioritymaterial.arc 文件中，需要用 SybarisArcEditor 进行导出。<br><img src="/assets/images/2454431-20230905205146150-1772205157.jpg" alt="img"></p><h2 id="Mod-移植工具"><a href="#Mod-移植工具" class="headerlink" title="Mod 移植工具"></a>Mod 移植工具</h2><p>现在工具已经有了，但我想没人真准备从头开始做吧，反正我没那实力，那咋搞？抄作业呗，国内基本都是抄作业，甚至有人拿抄来的作业盈利，所以我们这些圈外人就更不用担心了。</p><h3 id="模之屋"><a href="#模之屋" class="headerlink" title="模之屋"></a>模之屋</h3><p><a href="https://www.aplaybox.com/">https://www.aplaybox.com/</a></p><p>一个 MMD 模型分享网站，上面有很多免费分享的模型，并且最关键的是大部分游戏官方为了鼓励二创都会在上面发布自己的官模，作为源模型再合适不过了。</p><h3 id="Cats-Blender-Plugin"><a href="#Cats-Blender-Plugin" class="headerlink" title="Cats-Blender-Plugin"></a>Cats-Blender-Plugin</h3><p><a href="https://github.com/absolute-quantum/cats-blender-plugin">https://github.com/absolute-quantum/cats-blender-plugin</a></p><p>模之屋的模型是 pmx 格式，是 MMD 软件的专属格式，所以在 Blender 中我们必须要用专门的插件导入。</p><h4 id="使用简介-3"><a href="#使用简介-3" class="headerlink" title="使用简介"></a>使用简介</h4><p>从模之屋下载到 MMD 模型文件后，像正常导入模型一样导入 pmx 文件，接着使用插件提供的修复功能，即可轻松获得我们的移植源模型。（如果点击修复后模型贴图仍然异常，可以尝试删除模型后重新导入）<br><img src="/assets/images/2454431-20230905204317754-105834988.jpg" alt="img"></p><h3 id="SybarisArcEditor-和必要优化插件"><a href="#SybarisArcEditor-和必要优化插件" class="headerlink" title="SybarisArcEditor 和必要优化插件"></a>SybarisArcEditor 和必要优化插件</h3><ul><li><p><strong>SybarisArcEditor</strong></p><p>模之屋只是解决了模型来源的问题，但其他 menu，pmat 等文件你不会想自己从头写吧，反正我记不住里面该填啥，另外包括骨架模型和权重信息这些，我也没有也不想自己刷啊。但如果有现成的模板，我肯定能稍微改改，那这个软件就能解决这些问题，他能直接导出官方 Mod 用于参考，配合 Blender 插件甚至能一键抄作业。</p></li><li><p><strong>MaidLoader</strong></p><p>一个游戏插件，优化了官方的 Mod 加载功能，并增加了很多其他加载项，比如 pmat 文件，否则我们只能通过改系统文件实现，那做出来的 Mod 根本没法分享。另外这个插件还支持在游戏中实时重载 Mod 文件，这太方便了，否则每次我们添加新文件必须要重启游戏，那速度简直龟速。</p></li><li><p><strong>ExtendedErrorHandling</strong></p><p>一个游戏插件，优化了装扮文件丢失时的处理方式，在原版游戏中一旦文件缺失就是直接弹窗加自动退出，然而几乎所有第三方 Mod 都是“缺文件”的，比如官方头发有多种颜色选项，如果 Mod 没有做支持那从官方发色切换过来时基本都会触发。如果坚持原版的处理方式，这对玩家体验影响太大同时也大幅增加了 Mod 制作者的工作量（当然也有通过 menu 参数人为矫正的方法，但这无疑增加了 Mod 制作的复杂度），如果不想累死，这个插件也是必装的。</p></li></ul><h4 id="安装说明-1"><a href="#安装说明-1" class="headerlink" title="安装说明"></a>安装说明</h4><p><a href="https://krypto5863.github.io/COM-Modular-Installer/">https://krypto5863.github.io/COM-Modular-Installer/</a></p><p>建议直接使用 CMI 的开发者预设安装上述工具和插件，这是最简单的做法。如果你想要单独安装，请自行参考 WIKI。</p><h4 id="使用简介-4"><a href="#使用简介-4" class="headerlink" title="使用简介"></a>使用简介</h4><ul><li><p><strong>SybarisArcEditor</strong></p><ol><li><p>首先 SybarisArcEditor 必须放在游戏根目录才能起效。</p></li><li><p>既然是导出器，那第一件事就是要确定我们要导出的文件名。一般获取装扮文件名的方式是首先在游戏中同时按下“M”,“O”,“D”三个字母，调出游戏左上角内置的导出菜单，接着选择装扮再点击导出按钮即可从导出弹窗中看到装扮名称信息。（实际上 SybarisArcEditor 也内置装扮菜单的可视化，可借此获取文件名，但想要实时预览肯定没有游戏内方便）</p><p><img src="/assets/images/2454431-20230905201210100-455058798.jpg" alt="img"></p></li><li><p>接着使用该名称在 SybarisArcEditor 中搜索即可找到目标文件，右键导出即可（可以看到官方装扮本质也是 Mod，其文件结构和类型和我们上一章讨论的一致）。</p><p><img src="/assets/images/2454431-20230905202631527-1952624995.jpg" alt="img"></p></li></ol></li><li><p><strong>MaidLoader</strong></p><p>加载功能为自动触发，刷新 Mod 功能则在右上角工具栏中。<br><img src="/assets/images/2454431-20230905200409032-612299575.jpg" alt="img"></p></li><li><p><strong>ExtendedErrorHandling</strong></p><p>自动触发。</p></li></ul><h2 id="Mod-兼容性确定"><a href="#Mod-兼容性确定" class="headerlink" title="Mod 兼容性确定"></a>Mod 兼容性确定</h2><blockquote><p>如果你希望把 Mod 分享给别人，或让 Mod 在未来也可继续使用，那你必须要考虑兼容性的问题。</p></blockquote><p>所要制作的目标和制作工具都已齐全，现在我们可以正式制作 Mod 了，但为了保证我们做出的 Mod 持久易用，开工之前我们还要明确有关 Mod 兼容性的问题。</p><p>所谓兼容性就是指 Mod 对不同游戏环境下的适应能力，比如是否能不依赖插件运行，在不同版本的游戏中是否继续有效等。兼容性越好的 Mod，可以使用的人群就越多，需要维护的代价也越小，所以无论是为别人还是为自己这都是要考虑的一点。</p><h3 id="版本兼容性"><a href="#版本兼容性" class="headerlink" title="版本兼容性"></a>版本兼容性</h3><blockquote><p>旧版游戏可用的 Mod 在新版游戏中也肯定可用，但反之不行。所以制作 Mod 的游戏版本越低，可用的玩家就越多。</p><p>本教程使用 COM3D2 2.28 版本。</p></blockquote><p>版本兼容性是来自官方的功能，是保障游戏更新后 Mod 能继续使用的重要指标。COM3D2 的系列已有多代作品，每一代都有自己的 Mod 功能，如果每次出新游戏 Mod 都得全部重做，所有过去累积的 Mod 化为乌有，那玩家肯定不会买账。游戏官方总是希望玩家能玩最新版，且不希望因此流失玩家，所以 COM3D2 的 Mod 具有向后兼容的功能。</p><p>目前国外应该是主流使用 COM3D2.5，国内是 COM3D2，而 CM3D2 我未曾接触过。COM3D2 的 Mod 在 COM3D2.5 中也可正常使用，所以本教程的游戏版本选择使用目前国内主流的 COM3D2 2.28 版本。</p><ul><li>CM3D2-&gt;COM3D2（我们在这）-&gt;COM3D2.5</li></ul><h3 id="插件兼容性"><a href="#插件兼容性" class="headerlink" title="插件兼容性"></a>插件兼容性</h3><blockquote><p>存在版本不兼容风险，无法确保安装环境统一，会增加额外学习成本，少用慎用。</p><p>本教程仅使用“MaidLoader”和“ExtendedErrorHandling”两个插件，这是必要的游戏优化插件。</p></blockquote><p>插件可以为游戏添加很多额外的功能，但问题是插件并非官方内容。虽然得力于游戏具有向后兼容的原因，插件具有一定的版本适应能力，但这终究是不稳定的，实际上现在已经出现了很多过去很常用的插件在新版游戏中无法使用的情况。所以过多的使用插件功能会把这层风险转移到你的 Mod 身上，而且你并不能确保每位玩家都和你装着同样的插件。</p><p>另外插件属于扩展功能，这就代表这需要额外的学习成本。而且因为来自第三方，所以其功能可能并不稳定，资料也会更匮乏，所付出的学习成本可能相当大。</p><p>但另一方面插件又能给我们带来很多原版游戏享受不到的便利性，有些功能甚至达到了必要的程度，并且因为 CMI 之类整合包的普及，插件具有一定的广泛性，完全拒之门外也是很愚蠢的行为。</p><p>因此我们择情选择，会使用少许游戏优化性的必要插件，但其他功能扩展类插件一律不会使用，比如高跟鞋，额外体型编辑，高画质材质等，实际上这里面的一些插件在新版游戏中已经不兼容，所以如果你想用这些扩展性功能，你需要自行研究。</p><h3 id="DLC-兼容性"><a href="#DLC-兼容性" class="headerlink" title="DLC 兼容性"></a>DLC 兼容性</h3><blockquote><p>官方内容，比插件兼容性好，但也无法保证安装环境一致。一般可作为移植源模型，或当成允许缺失的占位装扮使用。</p><p>本教程会使用 GP-01Fb 中的捏脸系统做人物脸部，并使用部分 DLC 装扮做移植源模型。</p></blockquote><p>DLC 相当于是官方 Mod，增加了大量的额外装扮选项，对于我们开发者来说这就相当于一下增加了好多可以抄作业的对象，或者也能拿来偷懒，少做件衣服什么的，另外还有部分功能性的 DLC 也相当实用，比如 GP-01Fb，可以为游戏增加额外的捏脸系统，大幅降低人物面部的制作难度。</p><p>由于 DLC 是官方内容也因此具有一定普及性，几乎网上的所有 COM3D2 游戏资源都是连带 DLC 的版本，另外受插件功能影响，衣装面部即使丢失也会被正确回退到原本的默认值，但那样 Mod 也可能因此失去意义。</p><p>总体来说 DLC 的兼容性比插件好一些，毕竟是官方支持的功能，但依旧无法确保用户安装环境统一，而且单纯用 DLC 偷懒的 Mod 我觉得很不厚道，所以 DLC 更大的作用是作为无关紧要的的临时替补，是允许用户丢失的存在，另外就是给移植时增加更多的参考对象，又因为本身是官方文件，所以没有“版权风险”，发布 Mod 时根据需要我们可以连带打包。</p><h3 id="第三方-Mod-兼容性"><a href="#第三方-Mod-兼容性" class="headerlink" title="第三方 Mod 兼容性"></a>第三方 Mod 兼容性</h3><blockquote><p>请不要使用这种方式，除非你能保证会连带打包，否则产出的 Mod 毫无分享价值。</p></blockquote><p>第三方 Mod 兼容性是指你在自己的 Mod 中引用第三方 Mod 的情况，这种方式和上述的三种兼容性有一个本质区别。“游戏，插件，DLC”这三者都存在后天获取的途径，因此即使出了问题，也有办法修复，但第三方 Mod 则不同，这基本没有官方站点的东西本来就很难找到，算上如今的环境更是雪上加霜，几乎不可能保证用户拥有或能找到该 Mod。</p><p>如果你想在你的 Mod 中额外使用第三方的 Mod 文件，请确保你会连带打包，否则产出的 Mod 毫无分享价值。但通常 Mod 制作者对于自己的 Mod 都有很强烈的版权意识，基本不可能同意你用来二次生产或分享，所以你也无法做到这一点。</p><p>所以请杜绝这种做法，但如果你是故意要这么干，那我也没法阻止，只能表示深感遗憾。</p><h2 id="Mod-制作流程"><a href="#Mod-制作流程" class="headerlink" title="Mod 制作流程"></a>Mod 制作流程</h2><h3 id="Mod-加载顺序"><a href="#Mod-加载顺序" class="headerlink" title="Mod 加载顺序"></a>Mod 加载顺序</h3><p>了解文件的加载顺序有利于我们理清文件之间的依赖关系，并便于后续制作流程的规划，COM3D2 的 Mod 加载顺序有以下几个流程。</p><ol><li>游戏先识别 menu 文件，这些文件会显示在玩家的装扮菜单中，menu 中指明了装扮对应的 model 文件。</li><li>model 文件提供了模型点线面信息，并告知绘制模型时该用哪一个 mate 文件。</li><li>mate 文件告诉游戏如何绘制画面（即用什么 shader），并描述绘制的参数和用到的 tex 文件。</li><li>pmat 文件则在特殊情况下出现，用于应对绘制顺序问题。</li></ol><p>总结可得以下先后结论：</p><ol><li>menu（所有文件的指路人，确定了我们要做的文件）</li><li>model-&gt;mate-&gt;tex（凑成了一套完整 3D 模型）</li><li>pmat（可选作）</li></ol><h3 id="Mod-制作顺序"><a href="#Mod-制作顺序" class="headerlink" title="Mod 制作顺序"></a>Mod 制作顺序</h3><p>因为依赖关系的原因，前者的需求可能导致对后者有特殊要求（如 model 的 uv 变了，导致 tex 要重新绘制），所以 Mod 的制作顺序应与 Mod 加载顺序一致，具体而言大致的通用顺序可以如下规划（更细致的实际制作流程我将在后续章节讲述）。</p><ol><li><p><strong>准备用于移植的原始模型</strong></p><ol><li>浏览“模之屋”网站，挑选一个自己喜好的模型并下载。</li><li>使用“Cats-Blender-Plugin”导入下好的模型文件。</li><li>理清大概的模型结构，按装扮分类将源模型拆成多个单件装扮模型。</li></ol></li><li><p><strong>准备用于仿制的官方 Mod</strong></p><ol><li>根据准备移植的装扮模型，用“SybarisArcEditor”导出一份与其最接近的官方 Mod。</li><li><em>观察官方 Mod 文件组成，通过模仿，我们就能知道如何从零制作相应的 Mod。</em></li></ol></li><li><p><strong>制作 menu 文件</strong></p><ol><li>使用“Blender-CM3D2-Converter”导入官方 Mod 文件中的 menu 文件。</li><li>对官方 menu 文件进行适当修改，比如修改装扮名，图标，所用 model 文件等信息。</li><li>此时 menu 文件制作成功。</li><li>依据该 menu 文件，确定我们下面要制作的目标，一般都是需要 model 文件（但也可能是需要 tex）。</li></ol></li><li><p><strong>制作 model 文件</strong></p><ol><li>使用“Blender-CM3D2-Converter”导入官方 Mod 文件中的 model 文件。</li><li>将装扮模型调整至和官方模型差不多的位置大小，重新绑骨为官方骨架。</li><li>利用权重转移形态键转移等功能，将官方模型相关数据转移到新装扮模型上。</li><li>此时 model 文件制作成功，这个新装扮模型就是实际的 model 文件。</li></ol></li><li><p><strong>制作 mate 文件</strong></p><ol><li>找出刚做好的 model 文件所用的材质，使用“Blender-CM3D2-Converter”将其转换为 CM3D2 格式，具体不同情况可能要选择不同转换材质，如透明不透明等。</li><li>正确填写好新材质中的各种参数，包括对贴图的引用信息等。</li><li>此时 mate 文件制作成功，这个刚被转换的材质就是实际的 mate 文件。</li></ol></li><li><p><strong>制作 tex 文件</strong></p><ol><li>找出刚做好的 mate 文件所用的贴图，并依据 model 的情况进行些额外处理，比如制作额外的图标贴图，扣除皮肤部分使其隐藏等。</li><li>此时 tex 文件制作成功，这个刚处理的贴图就是实际的 tex 文件。</li></ol></li><li><p><strong>导出 Mod 文件</strong></p><ol><li>将上述的所有文件进行简单的检查，确保各文件名无误，引用信息正确。</li><li>接着将他们全部导出到游戏的 Mod 文件夹中。“menu、model、mate”直接通过“Blender-CM3D2-Converter”插件即可导出；“tex”可能需要用外部的“TexTool”工具进行导出。</li></ol></li><li><p><strong>Mod 文件查修</strong></p><ol><li>启动游戏，找到对应的装扮菜单项，穿上新做的 Mod。</li><li>检查各种情况下的穿模情况，并以此修改模型重新导出。</li><li>进行各种常规的游戏活动，确保 Mod 文件无问题。</li></ol></li><li><p><strong>Mod 文件发布</strong></p><ol><li>穿好完整的 Mod，保存其 Preset 文件，并拍照保存预览图。</li><li>将相关所有文件进行整理分类，确保文件完整无冗余。</li><li>将文件打包发布至网络。(我用这个：<a href="https://mod.3dmgame.com/COM3D2">https://mod.3dmgame.com/COM3D2</a>)</li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章主要是正式制作 Mod 前的一个准备环节，指明了进行 Mod 制作所需的各种工具，以及确定了 Mod 的运行环境兼容性，并对整体制作流程进行了概述。</p><p>不过看了这些你可能仍然处于懵逼状态，因为这些仍然是概念性的前置课程，但将上文所说的这些都配置好后，我们便可以正式开始制作 Mod 了。</p><p>下一章我们将真正站在实战的角度去做 Mod 中的身体部分，我会将更具体的流程和注意点写在其中。</p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
      <category>COM3D2Mod制作教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【COM3D2Mod 制作教程（2）】Mod 底层原理</title>
    <link href="/posts/4079335571.html"/>
    <url>/posts/4079335571.html</url>
    
    <content type="html"><![CDATA[<h1 id="【COM3D2Mod-制作教程（2）】Mod-底层原理"><a href="#【COM3D2Mod-制作教程（2）】Mod-底层原理" class="headerlink" title="【COM3D2Mod 制作教程（2）】Mod 底层原理"></a>【COM3D2Mod 制作教程（2）】Mod 底层原理</h1><h2 id="Mod-是什么？"><a href="#Mod-是什么？" class="headerlink" title="Mod 是什么？"></a>Mod 是什么？</h2><p>Mod 一词想必你已经听过很多次了，因为很多游戏都可以装 Mod，而 Mod 可以为游戏增添一些额外的乐趣。但在 COM3D2 这款游戏中，Mod 和常规的意思并不一样，常规的 Mod 在这里叫做插件，两者不能混为一谈。</p><h3 id="Mod-是一种官方功能"><a href="#Mod-是一种官方功能" class="headerlink" title="Mod 是一种官方功能"></a>Mod 是一种官方功能</h3><blockquote><p>一种用于增加额外的人物卡及其装扮的方法。</p></blockquote><p>在 COM3D2 中 Mod 是一项官方功能，这是很特殊的一点，实际上官方所有的角色装扮和我们自己所做 Mod 本质是一样的，所以它的作用也有了明确表示：一种用于增加额外的女仆及其装扮的方法。</p><p>我们外部之所以也能做 Mod，是因为围绕着下方两个文件夹展开了，官方会自动加载这两个文件夹下的文件，这两个文件夹也分别代表着两种功能方向。</p><ul><li><p>Mod 文件夹：</p><p>用于增加女仆装扮选项，但相关文件在游戏中仅有加载功能，所以无法直接制作，制作时需要额外借助第三方工具。</p></li><li><p>Preset 文件夹：</p><p>用于储存女仆身体信息，包括体型面部的参数，是游戏内置的捏人系统，虽然用 Mod 文件夹也可实现类似的功能，但难度过大一般不考虑。</p></li></ul><p><em>可见 Mod 由 Mod 和 Preset 两种文件组成，但因为 Preset 的内容在课程中的占比非常小，所以后续的 Mod 都默认指 Mod 文件夹的这部分。</em></p><h3 id="Mod-可能被插件扩展"><a href="#Mod-可能被插件扩展" class="headerlink" title="Mod 可能被插件扩展"></a>Mod 可能被插件扩展</h3><blockquote><p>可以提供更多额外功能，但存在兼容性问题。</p></blockquote><p>原版的 Mod 功能是比较弱的，所以一些技术玩家为此专门开发了一些插件，这些插件使得 Mod 可以额外加载一些文件，比如声音，剧本等（COM3D2.MaidLoader），更炫酷的材质效果（COM3D2.NPRShader.Plugin），额外的体型参数（CM3D2.AddModsSlider.Plugin）等等。</p><p>其中一些插件非常重要，以至于没有他们部分装扮将无法制作，再加上玩家一般都会通过 CMI 或类似的插件整合包安装插件，所以你基本可以默认玩家的游戏环境是带有这些插件的，但要注意这终究是第三方提供的功能，不一定百分百兼容，再考虑受众范围的问题，所以部分插件还是建议保守使用。</p><h2 id="Mod-的运行原理"><a href="#Mod-的运行原理" class="headerlink" title="Mod 的运行原理"></a>Mod 的运行原理</h2><p>我们知道 Mod 就是实现装扮功能，所以让我们先不考虑 Mod，考虑如何自己实现人物装扮的效果。</p><h3 id="人体模型实现"><a href="#人体模型实现" class="headerlink" title="人体模型实现"></a>人体模型实现</h3><blockquote><p>人形模型绑定上人形骨架即可。</p></blockquote><p>首先装扮是穿在角色身体上的，所以必须先考虑这些这些身体是如何做的，如果你有完成前置要求的任务，那这个问题应该相当简单，就是捏个人型模型在绑上一套人形骨架就行。另外为了实现动画的复用，一般多个角色的骨架都会使用同一套，即便略有区别那也是能向下兼容的那种。</p><h3 id="装扮模型实现"><a href="#装扮模型实现" class="headerlink" title="装扮模型实现"></a>装扮模型实现</h3><blockquote><p>单独的装扮模型但绑上和人体模型相同的骨架即可。</p></blockquote><p>人体模型有了，现在我们要给他做一个能够替换和拆卸的衣服，很显然这样的衣服和人体一定不能是同一个模型，可我们需要让衣服和人体一起运动。我们知道模型是受骨架控制而运动的，而且不同模型依旧可以绑上相同的骨架，所以只要骨架一样就能同时控制装扮和身体，于是就有了种穿上衣服的感觉。也因此对装扮便只有了骨架的要求，模型得以随意替换。</p><h3 id="体型变化实现"><a href="#体型变化实现" class="headerlink" title="体型变化实现"></a>体型变化实现</h3><blockquote><p>把人体模型和装扮的胖瘦都捏一份，通过形态键计算过渡。</p></blockquote><p>体型的变化是显然通过网格变化体现的，但游戏不是建模软件也不可能现场改模型，所以必须有成熟便利的功能自动修改网格形状。骨骼就是一种，但这种实时计算的方式不可控，而要严格保证网格变化前后是符合要求的方法就是形态键，但形态键的缺点是必须提前确定变化前后的形状，所以要做两遍，人体模型和装扮模型都要。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p>Mod 的本质其实就是特制的 3D 模型而已。</p></blockquote><p>我们知道 Mod 是和装扮有关，所以第一点和我们没关系，我们只要用官方的人体模型就行，但这也指明了我们制作装扮时所要绑定的骨架。而第三点太麻烦了，所以我们可以不考虑体型变化。那有关的只有第二点，而这一点说明了装扮实现的原理，也即 Mod 的原理。</p><h2 id="模型的组成原理"><a href="#模型的组成原理" class="headerlink" title="模型的组成原理"></a>模型的组成原理</h2><p>上述我们谈到 Mod 就是 3D 模型，那如何把这个 3D 模型放到游戏内？使用 FBX 这些格式肯定不可能的了，COM3D2 是 Unity 开发的，Unity 内部有着自己的格式，但你也别怕，因为模型的本质在哪都是一样的，我们可以先看看在 Blender 中模型是如何构成的。</p><h3 id="模型文件构成"><a href="#模型文件构成" class="headerlink" title="模型文件构成"></a>模型文件构成</h3><ol><li>随意创建一个正方体，通过右上角的大纲视图可以看到它由<strong>物体</strong>和<strong>网格</strong>组成。</li><li>接着我们可以为物体添加<strong>材质</strong>，材质中有一个节点功能，它的专属编辑面板在 Blender 中叫 Shading，换成名词就是<strong>着色器</strong>（Shader）.</li><li>材质的面板上可以设置各种参数，包括被称作<strong>纹理</strong>的图片。</li></ol><p><em>我为什么用这些名称称呼他们？通过大纲视图的 Blender 文件模式，你可以看到在 Blender 中就是这样称呼的（见下图标记处）。</em></p><p><img src="/assets/images/2454431-20230821172531502-932973070.jpg" alt="img"></p><h3 id="模型文件拆分"><a href="#模型文件拆分" class="headerlink" title="模型文件拆分"></a>模型文件拆分</h3><p>传统的单文件模式（FBX 这类格式），会把上述所有资源都打包在一起，但这不利于资源文件的复用和定制，所以最终到游戏引擎中会将各个资源分开储存，也即我们上述提到的那五种基本资源，简单描述一些他们各自的功能。</p><ul><li><p><strong>物体</strong></p><p>保存着父子关系，变换信息（位移旋转等），以及对网格和材质的引用信息。</p><ul><li><p><strong>网格</strong></p><p>点线面信息，包括 uv，权重，顶点色等。</p></li></ul></li><li><p><strong>材质</strong></p><p>表明所用的着色器，以及使用着色器时使用的资源（纹理）和参数。</p><ul><li><p><strong>着色器</strong></p><p>一段代码，用于指导电脑如何去绘制我们的屏幕画面。</p></li><li><p><strong>纹理</strong></p><p>图片文件</p></li></ul></li></ul><h2 id="Mod-的组成原理"><a href="#Mod-的组成原理" class="headerlink" title="Mod 的组成原理"></a>Mod 的组成原理</h2><p>你总算可以知道 Mod 里的文件都是干啥的了，所以现在请直接掏出一款现有的 Mod 做参照，因为下文所讲述的内容将会和 Mod 文件一一对应。</p><p><img src="/assets/images/2454431-20230821175923970-4172886.jpg" alt="img"></p><p>先让我们查看 Mod 制作 Wiki 的左侧的文件类别（上图），可以确定 Mod 的基本文件共有 5 种（最后一个不是文件类型），具体按功能可以分为以下三类（你不需要在意具体分类，对学习 Mod 制作来说这是无所谓的）。</p><p><em>为什么不做上图中最后一个日文标签的文件说明？因为那个不是文件类型，而是 menu 文件中一个属性，用于指明装扮类别（如指明装扮是头发，上衣，裤子等）。后续编写 menu 文件时，我们通常是直接对官方 menu 文件进行修改而不是从头创建，所以不需要去特别记忆。</em></p><h3 id="模型文件"><a href="#模型文件" class="headerlink" title="模型文件"></a>模型文件</h3><ul><li>model 文件（模型点线面信息）</li><li>mate 文件（如何绘制点线面）</li><li>tex 文件（绘制时用到的贴图）</li></ul><blockquote><p>广义理解的 3D 模型文件，可以想成被拆分存储的 FBX。</p></blockquote><p>这部分应该不需要过多解释了，就是上文“模型文件”两节提到的那些，这些文件凑成了一个基本模型所需的所有数据，具体到 COM3D2 中还进行了一定简化，结合上文对比下图你就知道对应关系和含义了，注意文件之间存在依赖关系。</p><p class='mermaid'>flowchart RL    object["物体</br>Object"]    mesh["网格</br>Mesh"]    material["材质</br>Material"]    shader["着色器</br>Shader"]    texture["纹理</br>Texture"]    subgraph Model文件      object      mesh      subgraph Mate文件        material      end    end    subgraph tex文件      texture    end    mesh-->object    material-->object    shader-->material    texture-->material</p><!-- ![img](/assets/images/2454431-20230821175122018-774464025.jpg) --><p>可以看到 model 文件中包含 mate 文件，所以 model 中用到的 mate 是不需要单独导出文件的，只要一个 model 文件即可。</p><p>着色器是内置在游戏中的，所以没有单独导出的文件，但着色器是由材质引用的，所以之后我们需要在材质中写明着色器信息。</p><h3 id="COM3D2-文件"><a href="#COM3D2-文件" class="headerlink" title="COM3D2 文件"></a>COM3D2 文件</h3><ul><li>menu 文件</li></ul><blockquote><p>对应游戏内装扮菜单，告诉游戏如何使用模型文件。</p></blockquote><p>现在我们有模型了，但如何告知 COM3D2 去使用它呢？这就需要 menu 文件。menu 是一个由多个键值对组成的文件，他直接对应着女仆编辑菜单中的菜单项，所以理所当然的它必须要知道一些基本的菜单信息，比如装扮名，装扮描述，装扮类别图标等。他的功能相当强大，以至于指定“点击该菜单项为女仆穿上特定模型文件”这一功能只是他的可选项之一，其他还能做到比如，调整颜色，隐藏部位，特定时刻更换材质球模型（常见如插入时内裤改为半脱状态）等操作。</p><h3 id="Unity-文件"><a href="#Unity-文件" class="headerlink" title="Unity 文件"></a>Unity 文件</h3><ul><li>pmat 文件</li></ul><blockquote><p>透明模型专用，用于处理绘制顺序问题。</p></blockquote><p>这个文件只包含了一个整数值和一个材质球名称，他决定了使用该材质球的模型绘制顺序，具体顺序为其整数值的正序排列。为什么需要控制绘制顺序？因为计算机绘制画面是按材质球为单位一层一层覆盖上去的，所以材质球绘制的先后顺序可能会对画面产生影响。在不透明物体中，这点不重要，因为有一个叫深度值的东西会帮我们避免错误覆盖，但在透明物体中就存在问题了，因为透明的性质导致绘制时必须要先知道前一个颜色才行，所以先后顺序必须确定。比如我们通常都是先看到裙子再看到内裤，所以如果裙子是半透明的，那必须要让计算机先画上内裤，然后再画上裙子才行。</p><p><em>为什么我按如上方式进行文件分类？这是站在 Unity 的角度来分类的。模型文件都是由外部工具制作再导入 Unity 的，是构成完整模型的必要资源；COM3D2 文件则是 COM3D2 独有，是游戏开发者自定的文件；而 pmat 则确实是 Unity 自身的资源，是在 Unity 中进行编辑的。</em></p><h3 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h3><blockquote><p><em>不在教程范围内</em></p></blockquote><p><em>实际上除了上述几种文件之外，游戏或插件还额外提供了一些文件类型，但考虑难易度和兼容性，教程中不会使用也不会教授，如有需求可自行去了解。</em></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这章主要讲述了 COM3D2 的 Mod 运行原理及其文件构成，偏理论课程，所以看起来会比较枯燥困难，但实际制作中会更轻松的一些，比如上述的很多文件，到时我们是不需要从头创建的，即使是建模环节也是通过移植第三方模型来解决。下一章我们将正式开始搭建制作环境，并了解 Mod 文件是如何制作出来的。</p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
      <category>COM3D2Mod制作教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【COM3D2Mod 制作教程（1）】教程简介</title>
    <link href="/posts/2633666094.html"/>
    <url>/posts/2633666094.html</url>
    
    <content type="html"><![CDATA[<h1 id="【COM3D2Mod-制作教程（1）】教程简介"><a href="#【COM3D2Mod-制作教程（1）】教程简介" class="headerlink" title="【COM3D2Mod 制作教程（1）】教程简介"></a>【COM3D2Mod 制作教程（1）】教程简介</h1><p>教程来自：<a href="https://bdffzi.github.io/opencom3d2/">https://bdffzi.github.io/opencom3d2/</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>没有<a href="https://seesaawiki.jp/com3d2mod_wiki/d/%bb%c8%cd%d1%a5%c4%a1%bc%a5%eb">Mod 制作 WIKI</a>就没有这篇 Mod 制作教程，所有信息都是先从 Wiki 上取得再发展出来的。WIKI 上也有简易的教程，虽然有些过时了（WIKI 上面用到的很多第三方工具都已经失去支持了，不过也都有后继者在传承，所以 Mod 制作至今依旧可行），但其他信息仍具有参考价值。</p><p>另外该文章是起笔记大纲的作用，无基础阅读起来可能会很困难，所以请优先看后续推出的教学视频，视频会大幅简化文章内容，并配合实战教学，更适合学习使用。</p><h2 id="观前须知"><a href="#观前须知" class="headerlink" title="观前须知"></a>观前须知</h2><h3 id="本教程的适用人群"><a href="#本教程的适用人群" class="headerlink" title="本教程的适用人群"></a>本教程的适用人群</h3><p>适用于和我一样没人脉没金钱，死活搞不到想要的 Mod，但动手能力强，不介意付出一点时间代价，愿意自学的 Mod 制作的小伙伴。</p><h3 id="本教程的前置要求"><a href="#本教程的前置要求" class="headerlink" title="本教程的前置要求"></a>本教程的前置要求</h3><p>本教程是面向非专业人士的教程，做的是移植 Mod（国内 99%都是移植，包括很多内部和商用 Mod，这种 Mod 简单效果好），大部分工作也是使用插件自动化处理，不需要从头建模刷权重等，所以技术要求较简单，但希望能尽力保证有以下基础功底。</p><ol><li><p><strong>建模能建方块人</strong></p><p>会使用建模软件 blender 的基本功能，不需要美术功底，但应能自制简易的低多边形风格人物模型，会绑骨刷权重，会通过编辑或雕刻模式简单调整模型，会画简单的贴图。</p></li><li><p><strong>绘画能画火柴人</strong></p><p>能简单操作一些修图软件，如 PS，GIMP 等（教程中使用 GIMP），用于微调贴图。</p></li></ol><h2 id="目前的-Mod-生态环境"><a href="#目前的-Mod-生态环境" class="headerlink" title="目前的 Mod 生态环境"></a>目前的 Mod 生态环境</h2><h3 id="困境"><a href="#困境" class="headerlink" title="困境"></a>困境</h3><p>COM3D2 这款游戏的生态是真的糟糕，没有人脉和金钱你基本不可能在这找到想要的特定 Mod，原因有两点：</p><ol><li><p><strong>制作门槛高</strong></p><p>相比之下 COM3D2 的 Mod 制作门槛太高了，需要一定专业技术，普通玩家很难参与其中，导致很多 Mod 都是带有利益性质的。</p></li><li><p><strong>共享条件差</strong></p><p>技术只掌握在少数人手中再加上国内大环境影响，大部分人表示为防范倒狗都不愿意对外公开自己的作品，只在小圈子里发布，层层嵌套，恶性循环。</p></li></ol><h3 id="机遇"><a href="#机遇" class="headerlink" title="机遇"></a>机遇</h3><ol><li><p><strong>插件成熟</strong></p><p>相比恶劣的 Mod 环境，COM3D2 的插件生态简直是天堂，程序界本就弘扬开源精神，此刻还有大佬相助，著名插件加载器 BepinEx 的代码贡献排行榜中，一位龙头选手就是一名 COM3D2 资深爱好者（同列的还有隔壁的恋活爱好者，果然色色才是第一生产力）。所以目前市面上已经有了一套较为成熟的工作流程，有大量的辅助工具和插件帮助我们开发和加速 Mod 制作，道路已被打通，需要的仅是学习成本。</p></li><li><p><strong>模型现成</strong></p><p>现在越来越多的人会在网上公开自己的模型，尤其是很多游戏公司为鼓励二创环境，基本都会在网上发布自家游戏的角色官模，这就导致我们完全不需要从头做开始就能获得质量超好的模型，而且 COM3D2 这款游戏的官方装扮也是可以一键导出的，所以基本上我们只要学会抄作业，修修改改就能做出 Mod。</p></li></ol><h2 id="本教程的具体规划"><a href="#本教程的具体规划" class="headerlink" title="本教程的具体规划"></a>本教程的具体规划</h2><p>根据难易度实用性等因素考虑，教程将会分两期发布，以文章做笔记大纲，视频做实践解读的方式进行教授。</p><h3 id="入门阶段"><a href="#入门阶段" class="headerlink" title="入门阶段"></a>入门阶段</h3><p>这是必学的阶段，同时也是最实用的阶段，二次元角色的特征主要就集中在眼睛头发等部位上，而衣服本就可以更换，所以只要搞定这部分就已经能满足绝大部分人对老婆的需求了，并且这部分也是最简单的部分，几乎不怎么需要动模型贴图即可完成，所以强烈推荐。</p><ul><li>目标：搞定动漫角色最重要的特征点，让别人看了能直呼老婆！</li><li>内容：人物体型，面部，头发（含头饰）的制作教程</li><li>难度：一晚上能搞定</li></ul><h3 id="进阶阶段"><a href="#进阶阶段" class="headerlink" title="进阶阶段"></a>进阶阶段</h3><p>衣服相关的装扮是最难的部分，因为模型需要调整的地方非常多，甚至要自己画贴图（当然也有相应的诀窍），如果想要随体型变动，工作量更是翻倍，但得到的效果很不好，穿模扭曲是家常便饭，基本上做了也不会使用，但原版衣服也算是一大特色，装逼时能起到较好的作用。</p><ul><li>目标：让老婆能穿上自己的原设衣装，让别人看了能直呼大佬！</li><li>内容：上衣，裤子，鞋子等衣装类制作教程</li><li>难度：需要折腾几天</li></ul>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
      <category>COM3D2Mod制作教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【杂谈】我该怎么做才能让自己进大厂</title>
    <link href="/posts/3769596179.html"/>
    <url>/posts/3769596179.html</url>
    
    <content type="html"><![CDATA[<h1 id="【杂谈】我该怎么做才能让自己进大厂"><a href="#【杂谈】我该怎么做才能让自己进大厂" class="headerlink" title="【杂谈】我该怎么做才能让自己进大厂"></a>【杂谈】我该怎么做才能让自己进大厂</h1><p>想进大厂做 Unity 游戏开发，可完全不知道自己应该准备啥。比起面试我甚至感觉 HR 那关更难通过，如何让自己拿到面试的机会？</p><p>应该做个游戏 Demo 吗？但游戏开发都烂大街了，各种现成的插件教程网上都有，很轻松的就可以做出一款看起来很成熟的游戏来。要想来点考验技术的，那就造轮子，可别人公司都有成熟的技术，你造的别人也看不上，而且不到面试的时候也用不上这个。</p><p>不同的应聘人，写代码的方式可能不同，但都是面向招聘需求开发，那最终呈现的效果都是一样的，HR 会去翻你的代码吗？不会吧，HR 每天要看上几百个简历，而且本身应该都不是计算机专业，那么一群人交过去项目演示对 HR 来说能有多少区别？</p><p>这样子对 HR 来说最适合的判断条件肯定就是学历，工作经历这些了吧，可这两行我都不占优。看学历只看第一学历，那我这辈子已经没机会了；看工作经历，我没进过大厂，所以也没有好的经历可看，而这又导致我没法得到进好公司的经验。</p><p>思来想去，我似乎根本没有机会进大厂了。</p><hr><p>我今年 21 岁，假如是大学生的话应该正好是大三，2018 暑假我开始接触 Unity，一开始只是存粹的爱好，后来自学的本科计算机，因为我本身的专业和计算机没有任何关系。</p><p>当我正式开始进入计算机的领域后，便不再进行独立游戏的开发，接着大部分时间都花在了研究底层上，我本身是不太喜欢用插件的，喜欢自己写，上班做的事也更偏科研方向。</p><p>前半年我开始尝试自己做个迷你游戏引擎，也是我第一个播放量过万的视频，原先想着可以应聘用，不过完全没有用，根本没人在意这个。</p><p>最近的一次面试，面试官基本没考我什么技术问题，主要就是问项目经验，最后他是这样评价我的“感觉我不像是干游戏开发的”，虽然很难受，但想想好像确实是这样，我已经很久没做过正儿八经的游戏了。</p><p>结果我总是宣扬着想做游戏开发，可如今心底里却根本没有想开发的游戏，到头来我只不过是贪恋进大厂的人生荣耀感罢了，不过恐怕我已经没这个机会了。</p><p>之前朋友帮我找了个米哈游内推，可惜因为投早了，内推没用上，不过我估计用上了结局也不会变的。那人说我能力没问题，不卡学历肯定可以，我朋友也说我和同龄人相比已经杀爆一大片了，听完这些我当时真的超级开心。假如我现在真的还在学校上学，真的是计算机专业的一名大三学生，或许我真的还有机会。</p><p>但现实是，我没有上大学，所以也早已不是学生，也没法使用校招的途径。我是一个已经走上社会的人，迎接我的只有来自社会的残酷。</p><p>所以我该怎么做才能让自己进大厂？分析过后，我感觉我这辈子都没机会了，甚至因此我失去了自己的人生目标。现在我还能感受到的只有迷茫，从想吃天鹅肉的那天开始，我弃坑了多个曾经难以割舍的爱好，现在不仅对做游戏起不了兴趣，甚至连玩游戏都不想玩了。也没有朋友什么的，因为在学校的最后几年所有邀请都被我拒绝了。</p><p>所以我现在还剩下啥？我该干嘛？</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【杂谈】突破自己可解锁人生隐藏内容</title>
    <link href="/posts/2800689653.html"/>
    <url>/posts/2800689653.html</url>
    
    <content type="html"><![CDATA[<h1 id="【杂谈】突破自己可解锁人生隐藏内容"><a href="#【杂谈】突破自己可解锁人生隐藏内容" class="headerlink" title="【杂谈】突破自己可解锁人生隐藏内容"></a>【杂谈】突破自己可解锁人生隐藏内容</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>太离谱了，以前我好几次感到并明确说过这么一句话：</p><blockquote><p>这个世界好像有一种规律。当你费劲心思完成某件事，这个世界就会像试图打击你一样，忽然让你发现一堆优秀解决方案，就像是为了提醒你自己是多么愚蠢一样。</p></blockquote><p>今天我不出所料的再次遇到了这个现象，我现在已经逐渐相信了这个事实。所以今天我要重新概括这个现象：</p><blockquote><p>当你在某件事上得到突破时，世界就会为你解锁更多内容。无关你的突破方式的聪明或愚蠢，解锁的内容也可能完全出乎你的认知范围。</p></blockquote><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>我曾以为它只是一种巧合，又或是一种心理现象，但无法否认的是它的发生概率如此之高，同时也是为了研究和观察，所以我来举几个例子：</p><ul><li>当时我嫌打游戏刷关太废时间，可手机上又没有什么脚本软件，少数几个都还要 root 权限。</li></ul><p>于是我开始研究，最终成功利用 Adb 在安卓手机上实现免 root 执行按键脚本。</p><p>结果没过多少时间，手机上开始出现连点器软件，是利用无障碍功能的接口实现的，所以我的方案此时就显得很蠢了。</p><ul><li>当时我为了向非计算机专业的同学炫技，给他展示成为程序员的实用性，所以试图做一个自动玩跳一跳的软件。</li></ul><p>于是我开始研究，但对一个当时都不知道向量的我来说，这个真的蛮难的，一次又一次失败，心灰意冷中我去冲澡，结果偶然想到了一个取巧的办法。</p><p>通过从上到下扫描图形，找到目标跳台的两个端点就可以算出落脚点了，小人的位置也是类似，最终成功利用上述方法连续跳上好几百次。</p><p>结果没过多少时间，跳一跳调整了游戏内的阴影效果，受此影响上述识别图像的方法直接没法用了。</p><ul><li>当时我试图游玩一款老外的游戏，结果下载下来才发现没有汉化。</li></ul><p>上网找了半天一个汉化补丁都没有，而专门下载汉化版的话就得带上一堆东西，看看百度云盘的网速，想想就可怕，所以只能自食其力。</p><p>于是我开始研究，以前我见过一些别人的辅助汉化的软件，都是接入的第三方服务，而对游戏代码的修改则因为专业对口，所以很快就搞定了。秉着造福大众的想法，我还特意将其发到了网上。</p><p>结果没过多长时间，网友的互动来了，有些人指责我太蠢了，其实一直都存在一些通用的汉化工具，直接用就行，根本不用造轮子。还有些人则是问我“up 主，你要补丁不要？”，然后一堆我之前根本找不到甚至不知道的插件，包括汉化补丁，如洪水般向我袭来。</p><ul><li>这段时间我听了一首非常好听的歌曲，所以非常想把它演奏出来。</li></ul><p>但是 acg 的歌曲本来就偏小众，在加上乐器限制，对谱子也有特定要求，虽然原本找到了个差不多凑合的谱子，但加上一堆杂七杂八的原因，最后逐渐发展成了自己扒谱的状态，妈耶，真的累人。</p><p>这是我人生第一次扒曲，原本就没做功课也没做准备，所以工具极其粗糙，音调还是靠现场吹笛子人工识别，但是笛子好多音还吹不出来……结果忙来忙去，大半天都搭上面了。</p><p>很辛苦，所以为了让别人不要重蹈覆辙，我准备把最终扒下来的谱子发到网上去，再发布之前我一如既往的先在网上翻找一下，以防出现撞车的情况，结果我发现早有人扒好了。</p><p>但此时这已经不是重点了，因为我以此发现了一个神奇的网站，满满的都是 acg 歌曲谱子，并且都是简谱，而且支持自动转调，而这一切还都是免费的，就连广告都没有。没错这是个非商业的小团体社区，应该类似于早期 b 站吧。</p><p>我赶紧试着搜索了我的音乐库，不负所望，只要是稍微有点名气的不少都搜到了，哇，发现宝藏了属于是，我已经知道明天该干嘛了。而至于之前我自己扒的那谱子，那已经无所谓了，毕竟已经过时了，一如既往的那样。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>接下来进入分析环节，但在分析前我先备注一件事，因为“解锁内容”这个词本来就是个花俏的说法，所以我打算后续用“开门”一词来代替，虽然听着很俗，但更加形象通顺。</p><p>接着我们要明确讨论目标“开门和突破”。其中开门除了突破外其实还有很多种方式，目前我能想到两点。</p><ol><li><p>纯粹是凑巧。</p><p>如例子 1、2，这些触发时机和我自身关系不大，应该说是为了顺应市场需求，大家想到一块去了，其实即使没有我参一脚，相关内容也会自然而然的出现。</p></li><li><p>直接由别人帮助开门。</p><p>主动或被动的学习了别人留下的知识或经验。但该情况有特殊的地方，如例子 3，虽然最终我在别人的帮助下打开了新世界的大门，但我若没有发布相关视频也便不会有网友的互动，可以这么说，有时候帮你打开大门的人也是从门内来的。</p></li></ol><p>现在正式开始对此现象进行分析:</p><ol><li><p>突破只是开门的间接原因</p><p>首先打开新世界大门这只是并不是只在突破的时候发生，看了一本适合的书本遇上了一位好的老师，大门可以频繁打开好几回，这些触发时机的共性都有资料收集在内，实际上突破的这一过程往往会带有很多搜集资料的行为。</p></li><li><p>开门的关键在于凑齐隐藏要素</p><p>例子 4 中有个奇怪的地方，为什么我在最后才发现目标网站，既然能简单搜到为什么一开始没有发现？原因就在于，一开始我是用的手机看谱子，所以最开始是使用百度搜索，而百度是没法搜到的，也就是说其实即使我完成了扒谱完成了突破，若我最后没有换搜索引擎的话，依然是没法打开大门的。</p></li><li><p>隐藏要素间实际上是相辅相成的</p><p>有关例子 4 中的开门要素我能想到的有如下几点。</p><ol><li>搜索歌曲时使用的是国外搜索引擎，因为至少百度好像是搜不到的，甚至好多时候官网都放在广告下面</li><li>搜索的歌曲是 acg 歌曲，并且歌曲热度正正好，以便在搜索结果中不被其他商业网站淹没，又有人愿意扒谱</li><li>上传和搜索简谱的人要求是会玩音乐的程序员，因为该网站的编码方式是 Markdown，唯一支持的第三方登入还是 github</li></ol><p>单看每一条其实都能筛掉不少人，但是这三条其实又是相辅相成。</p><p>我自身是从宅开始的，因此了解了 acg 文化，acg 以及前辈们又让我对计算机产生了兴趣，于是我成为了程序员。</p><p>因为半路出家，和身边人越走越远，于是社交变少但又需要娱乐，很容易的就会想去玩一下音乐，学习过程中又接触的国外的软件比较多，慢慢的连搜索引擎都喜欢用国外的。</p><p>于是，无意间我就很自然的把大部分要素都凑齐了。</p></li><li><p>尝试突破依然是一个很好的开门方式</p><p>我们知道开门的根本原因搜集隐藏要素，但是实际上在开门前我们也不知道哪些是隐藏要素，所以有意去凑齐全部要素就显得不太现实，但通过分析 3 可知，要素都是互相关联的，也就是说我们只需要抓住一点开枝散叶，这一过程自然就可以包含起所有要素来，而恰巧对门的一点信息我们是可以掌握的。</p><p>如果把隐藏要素比作入口，那我们想要的结果即出口，有关出口这一点我们是明确的，所以利用两者的关联性，我们只需要专注于获取目标结果，便可以自然而然的逆向获取到所有隐藏要素，然后在不知不觉中打开一扇新的大门，即解锁更多内容。而这一过程便是突破。</p></li></ol><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>接下来我打算对该规律的实用性进行阐述，不过话说我好像没有对该规律的后半句进行分析，嘛，反正都是写着玩，所以我不写，不过论实用性，这后半句值得一讲。</p><blockquote><p>“无关你的突破方式的聪明或愚蠢。”</p></blockquote><p>这句话我觉得最实用，甚至能起到颠倒黑白的作用，把坏事变成好事。</p><p>最简单的例子，现在网上喷子蛮多的，特别是知识区，基本发啥都要有人反对或踩一脚（也不是那么严重啦，而且很多时候是为了严谨），总之你先尽管想办法解决问题，然后把你那极其愚蠢的解决方案发到网上再装作沾沾自喜的样子。</p><p>你放心，虽然你刚开始解决问题时那叫天天不应叫地地不灵的样子很凄惨，但是现在你被一堆忽然出现大佬团团围住，各种优秀解决方案向你铺面而来的样子真的很靓仔。有个成语怎么说的来着，“抛砖引玉”。</p><blockquote><p>“解锁的内容也可能完全出乎你的认知范围。”</p></blockquote><p>这句话我觉得最厉害，能凭空增加人生的选项，让绝望中也能诞生真正的希望。</p><p>现在有很多人都说自己迷茫啊，然后选择了躺平啥都不想干，不排除有人是纯粹懒，但每当问起来，回答的最多的可能是看不到未来。这话嘛其实也没问题，但得加个备注“真正的未来”。</p><p>实际上这些人已经看到了自认为的未来，因为当你劝说他们动起来时，他们总会以自认为的坏结局来推脱，所以说真正让他们迷茫的不是看不到未来，而是看到的未来里没有自己的想要的东西。</p><p>实际上我也经常有迷茫的时候，也因此这一句话便变得尤为重要：“我看到的未来并不是真正的未来，这一切都受我认知范围的影响”。也即我看不见自己想要的东西但这不代表它真的没有，或许我只要再往前走几步，一座桃花源就在前方了。</p><p>所以不要因为挫折和迷茫就倒下啊混蛋，倒下了就真的再也没机会了，可能性是可以创造的，看不见不代表不存在，要坚信着只要不停下脚步，道路就会…不断延伸！（BGM 起）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以最后来做过总结吧，不过没心思写了，再说哪有那么复杂啊，总之好好加油吧，就如俗话说得一样“只要功夫深，铁棒磨成针”。</p><p>你只管挑着目前自认为正确的方向，不断的学习研究，努力突破昨天的自己，你不用担心自己做的好不好，方向对不对，因为剩下的自然会水到渠成。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>真的这么简单吗？其实我自己对这话都保有怀疑态度，虽说确实这个规律确实已经生效好多次，但这些事件都还有个共性“可控性强”，而且基本从头至尾都是只有我一个人在参与，而要加入些其他不稳定因素，我感觉成功率有点低哦。</p><p>也正是因为这样，我努力排除各种不安全方案，所以与其说解锁内容是突破的必然结果，不如说是我所选择的突破方案就是为了解锁内容。但是吧，表面上看这是不断突破自己的励志故事，但同时也是不断失去的伤痛回忆，就如同升空的火箭一样，一节一节脱离，最后虽然成功突破大气层解锁了地外宇宙，但本身也就剩一颗小卫星了。</p><p>或许我能在某些事情上最终达到自己的目标，但有些恐怕永远也有没机会了，可我很贪心，偏偏又都想要，怎么办呢，想到这里我又有一些迷茫了…….啊，等等，这不是我刚刚讨论过的东西吗，又一次的，我被禁锢在了认知范围的牢笼里。</p><p>曾经又有多少次，我自喜自己“网络第一人”的身份，然而这可能吗？一切其实不过是片面的错误的认知，但这似乎也不能完全怪他，因为每个人的头上似乎都有一顶罩子。我曾经以为那就是全世界，直到偶然间我突破了一小块，如同一只刚出壳的小鸡，我露出半只脑袋窥探着外边的崭新世界。</p><p>新世界很大，但依然没有我的安身之处，所以我该就此堕落，浑浑噩噩毫无意义的过完我这只有一次机会的人生吗？看着天上穹顶，我陷入了沉思，外面还有什么？我一直认为世界最合理的状态便是一片虚无，虚无到连“虚无”这个词都毫无意义，但事实上它出现了，不仅有了光，有了水，有了土地，甚至还有了我，那还有什么？还会有另一个世界吗？这不仅是一个现实问题，也是一个哲学问题。但总之，我坚信外面一定还有东西！</p><p>“….3…2…1…点火，发射！”。</p><p>随着一声令下，我缓缓起飞了，我能感觉到自己正在远离地面。</p><p>“抛弃逃逸塔！”。</p><p>看着熟悉的建筑物在视野中越来越小，我知道我已经回不去了。</p><p>“助推器分离！”。</p><p>我已经能看到远处的云层了，结果回过神小小的发射塔已经消失在了视野中了，没有了，一切都没有了，甚至我连回顾也做不到了。</p><p>……</p><p>慢慢的，我升上了高空，在背后我看到了那大片大片的陆地和海洋，明明广袤无垠可又感到无比狭窄，这便是我本该生活的地方吗？可如今都和我没了关系。熟悉的一切都远去了，我感到不安，我开始东张西望，可目之所及之处一切都开始变得陌生。我闭上眼镜，开始思考着未来，我的结局是什么？幸福美满，还是一团糟糕？又或者中途我就会解体爆炸……</p><p>冷静一下吧，我尽力排除心中的杂七杂八的念头。“闭上眼睛果然容易胡思乱想啊。”，朝着前方我重新睁开眼睛，穹顶，我那朝思暮想的穹顶，就在我的眼前，一点一点靠我靠近。太大了太大了，以及那极其深邃的黑，如同剧院里的黑色幕帘，完完全全遮住了舞台以及我视野，那后面有什么？我不知道，我失去一切来到这里，我本有很多话想说但现在又什么都说不出来，因为我不知道，什么也不知道，在过去和未来的夹缝中，我愣愣的呆在原地。</p><p>恍惚间，我好似听到了幕帘后传来嘈杂的人群声，喧闹声越来越大，是不是还传来“叮叮铛铛”敲击三角铁的清脆声音，好似在催我赶紧入场，“啊，要开始了吗。”，我闭上眼睛微笑着呼出一口气，“唯独故事我不想错过啊。”。拉开幕帘的一角，我思考着等待我扮演的角色会是什么，一名演员，一位观众，又或者一只蟑螂，啊，无所谓了，再不行就努力参加下一场吧。把这一切都托付给未来，交付给命运吧，即使找不到适合我的舞台，那至少我也能真正带着“第一人”的身份安然下葬了吧。</p><p>掀开幕帘，我走进了那片无边无际的黑暗之中……</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【杂谈】关于我对数学和世界的感悟</title>
    <link href="/posts/254603757.html"/>
    <url>/posts/254603757.html</url>
    
    <content type="html"><![CDATA[<h1 id="【杂谈】关于我对数学和世界的感悟"><a href="#【杂谈】关于我对数学和世界的感悟" class="headerlink" title="【杂谈】关于我对数学和世界的感悟"></a>【杂谈】关于我对数学和世界的感悟</h1><p>前段时间中二病犯了，突发奇想了些个人感悟，这波总算趁着过年时间把病发完了。</p><p>别看标题有数学，放心，全文不用计算任何公式，很多前置知识还配有科普小视频，阅读起来毫无难度，除了写的乱七八糟外。</p><p>（高端的我也写不出来啊_(:з)∠)_）。</p><hr><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>“你听说过牛顿分形吗？”</p><p>“哎，没有吗？”</p><p>“那，不妨我们先来玩一个游戏吧。”</p><p>我这有三只不同颜色的笔，请用它们帮我在张空白的纸上作画，题目的要求是，能让我在纸上任意圈个圆圈都能圈到且只能圈到一种颜色或三种颜色。</p><p>你随意搭配着三种颜色，迅速涂满了白纸，这下圈哪都能有一种颜色了。但等等，我将圈画在两种颜色的交界处，“你看这里有两种颜色，而非只有一种或三种。”，“这不简单。”，你立即在我圈中的范围内画上了第三种颜色，并立即对所有的两两相交的颜色边界上涂上了一道细细的用第三种颜色画出的线。我没有停止游戏，而拿出放大镜，在刚刚涂上的线的一端又确定了新的范围，虽然很困难，但手巧的你任然接下了挑战，在旧线的两端画上了更细更细的新线。你两手叉腰，沾沾自喜的看着我，似乎在宣告着游戏的结束，直到……我从身后默默掏出了一台显微镜。</p><p>你怒斥我是作弊，表示游戏无法胜利，白纸上的颜色，永远都有交际，补上一道缝隙，又显两条边线，我叫你不要着急，有公式可以解题。（rap 起来了哈哈）</p><div class="bvideo"><a href="//www.bilibili.com/video/BV1HQ4y1q78v" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/c1013026f914fe6d9dcb92946328d793106504ac.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:26:06</span>            </div>            <div class="bvideo-info">                <p class="title">【官方双语】（牛顿本人都不知道的）牛顿分形</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>32.8万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>1637</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">3Blue1Brown</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>咳咳，先让我们将时空转换到现实，开始进入正题部分。</p><p>某天工作时间，我正在编写一个能够随机生成噪波图的功能，而我的同事被我通过将时间做偏移，多次迭代来产生随机数的方式引起了兴趣，我兴奋的向他分享有关混沌与分形的奇妙，可惜我口才不佳，加之时间久远，描述的那是不知所云。虽然最后未能引起他的共鸣，但却让我深深陷入了回忆。</p><div class="bvideo"><a href="//www.bilibili.com/video/BV1B7411W7LB" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/cac19245b3290d4925e0b633f659aeabbb45aeaf.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:37:18</span>            </div>            <div class="bvideo-info">                <p class="title">这个方程会改变你的世界观</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>36.9万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>1493</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">Veritasium真理元素</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><h3 id="数学可以感知世界"><a href="#数学可以感知世界" class="headerlink" title="数学可以感知世界"></a>数学可以感知世界</h3><p>回家的路上，天空飘起的小雨打湿了我的眼镜，原先路边昏暗的灯光透过粘上水滴的镜片，变成了一片片五颜六色的光晕，层层叠加映入我的眼眸，如此景象不由的让我回忆起记忆中的牛顿分形。</p><p>若说不断在交界处画小圈是符合游戏规则的话，那同样的，在小圈里不断画上三种颜色也一样奏效，两股力量互不相让，结果就导致了分形的发生。当然，学完泰勒展开式后，我已知晓有限和无限其实是可以相互的转换的，因而对于牛顿分形表现出的结果，其实也并无神奇之处。</p><p>虽然不是什么卡 BUG 的产物，但要论喜感，和其他那些克苏鲁风格的分形相比，牛顿分形绝对是第一名。看着牛顿分形就好似让我看到一个孩童，为了完成老师布置的根本不可能完成的作业，拆东墙补西墙，转头发现东墙坏了，又去拆了西墙，搞到最后只得不断的贴上一层又一层的画片。在此之前，我从未见过世界会像今天一样出戏，真是太可爱了啊。不得不感概，数学的力量是真的强大，如此稀奇古怪的东西，居然也可以用公式所表示，并证明出其的存在。</p><p>以此类推，那数学是否也可以表示出其他类似的特殊事物，即使它们闻所未闻？</p><p>我立即想到了一个非常符合的故事，黑洞最开始不就是先由数学公式推到得出的吗？最早在 18 世纪末就开始有人预言，算来到今天黑洞照片的问世，竟早了 200 多年，那么与此类似的大量天体类型，甚至像引力波这种连实体都没有的东西，等等全部都是先由公式带出结果，再出仪器实际验证，而且无一例外的都得到证实。只能呆在地球上依靠薄弱五官的人类，有太多太多无法感知的东西，但数学却能无一例外精准的描绘出来，充当了人类的第六感，而这份力量甚至可以超越时间空间，乃至形体的限制。</p><p><img src="/assets/images/977e78d176435ca3256439f23a4f8ad3ab240e09.jpg" alt="人类第一张真实黑洞照片"></p><p>我能感受到我心中的某样东西发生了不可逆转巨变。我意识到我必须要开始重新审视数学。回家坐在沙发上，我根本无法平静。一直以来我都不过把数学当做一个相对通用的工具，理科的垫脚石而已，但现在我忽然发现平时常出现在菜市场的它，背后似乎隐藏着整个世界的秘密，其所蕴含的力量，意义皆不可估量，若一定要用言语去形容，那我只能回答：∞。</p><h3 id="数学可以描绘世界"><a href="#数学可以描绘世界" class="headerlink" title="数学可以描绘世界"></a>数学可以描绘世界</h3><p>我并没有很高的知识水平，因而我开始尝试用数学去审视更贴近于我的事物。我开始好奇既然数学连天体和规则都能表示，那对于我周围的环境事物是否也有同样的效果。我回想起之前向我的表妹介绍建模软件基础知识的时候，以及向她解释点线面是如何从一个个向量通过渲染管线最终呈现到屏幕上。这每一步都是通过数学公式在解析，从简单但难以理解的数学量一步一步到宏伟且直观明了的 3 画面。那反过来岂不也可以将我的目之所及全部转化为一道道数学公式？我开始构思，逆推，化简.;….“等等，这不是就高数第一章的空间解析几何吗？”，以此类推高中的平面几何，初中的三角形，圆面积公式，小学的物体数量温度描述…….哈哈，原来很早很早，我们就已经开始尝试用数学描述世界了，只可惜今天我才如此清晰深刻的意识到这点。</p><p><img src="/assets/images/image.png" alt="从数字到图像"></p><p>小的时候，我还没有觉醒现在这种一口气讲一堆废话的能力，写作文一直都是我的一大痛处，费劲心事才勉强把字数凑够，但光靠数量还不够，我无法精准描述老师需要的内容。大戏剧家莎士比亚曾说过：“一千个观众眼中有一千个哈姆雷特。”，这既是文学的浪漫，也是文学的缺陷，人与人的交流总是会不可避免的丢失部分信息，对于要精准描述整个世界这样宏大的任务，唯有数学可以选择。将世界的一切化为一个个公式，像写作文一样填在一张无比巨大的纸上，而我只需分享这张纸，任何人便都可以从中无损的描绘出整个世界，这就好比计算机中的人们用来传递各种数据的资源文件一样。</p><h3 id="数学可以揭秘世界"><a href="#数学可以揭秘世界" class="headerlink" title="数学可以揭秘世界"></a>数学可以揭秘世界</h3><p>以此为原理，我脑中开始畅想另一个世界的模样。我虽未见过四维空间，但我知道二维三维的公式，并以此可以推出四维世界的一隅。我兴奋的把公式写在纸上，但一切不像猜想的那样顺利，我失败了，我完全无法解析这张”.world“文件。我知道它的属性，并拥有着当前世界做参照物，也有着五官作为大脑的输入设备，但我无法理解它。我用数学窥探到了这个世界的信息，但我无法将其转为我五官可接受数据的任何一个。</p><p><img src="/assets/images/0412b3820ac30052e638440e8c2b716cb2547942.jpg" alt="无法打开的.world文件"></p><p>名为世界的文件庞大又复杂，阅读它并不容易，实际上至今我对世界的了解，都不过是从已被前人解读后留下的笔记中取得的。只会复制粘贴，对我来说这是一种遗憾，但同时这也是人类或者说是生命的希望。我很高兴人类是一种生物一种生命而非普通的无机物，俗话说：”水往低处流，人往高处走。“，生命是不断发展，逆熵而行的物质，我也因此始终相信，只要投入足够的时间精力，即使和愚公移山一样，一点一点也终有一天，整个世界都可以拿下，将其变为一个真正的”.world“文件，从里面人类可以读取到有关这个世界的任何一条信息，甚至是时间的公式，乃至发展到控制时间使时间倒流也不无可能。</p><p>但是，但是若需要带入的参数并不在定义域内该怎么办？我忽然想到了这一绝望的可能，心情像到达了终点的过山车一样平稳了下来，只是略带一丝失望。晚上我和往常一样翻阅着网络视频，忽然一则有关虚数的故事让我眼前一亮。虚数！那个长着像未知数，却从未摘下它面具的家伙。我回忆起了有关它的故事。一个看不见摸不着，无法用任何仪器测量出，不是任何物质和能量的东西，可每当套公式时，我都能真真切切的感受到有一股我五感无法感知的力量在蠢蠢欲动，似乎有一种更高维度的东西发挥了作用。</p><div class="bvideo"><a href="//www.bilibili.com/video/BV11h411x7z5" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/1e66f1e48c0c76165f68e8ed33b6bd52861e22d0.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:45:02</span>            </div>            <div class="bvideo-info">                <p class="title">虚数的来源</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>37.6万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>1212</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">Veritasium真理元素</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><p>我幡然醒悟，意识到之前的鲁莽，我自大的将世界画在自己的圈中也错误的忘记了数学的发展力。世界很大很大，远比我想象的更加奇妙，任何一部科幻电影都无法与其媲美。而数学是解题的工具，是应人类需要而拥有了描绘世界的能力，同样应人类需要数学还可以不断进化。</p><h3 id="数学不止如此"><a href="#数学不止如此" class="headerlink" title="数学不止如此"></a>数学不止如此</h3><p>数学是人类用来链接世界的桥梁，它从远古时期随人类诞生于世界，到今天科学体系的完备建立，如影随形不断成长。它比我年长许多，是一位无所不知的聪慧老者；它比我年轻许多，是一个潜力无限的奋斗青年。我无比相信它的未来，和它所创造的未来，相信终有一天，即使是世界也将会成为它手中的玩物。它无比强大且稳定，是人类最忠诚的管家，是人类最成功的发明。</p><p>得数学者得天下，我这样相信着。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
